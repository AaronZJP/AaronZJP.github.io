{"meta":{"title":"Aaron的博客","subtitle":"Stay foolish,Stay hungry!","description":"好记性不如烂笔头，随便写写，想到啥就写啥。","author":"Aaron_36","url":"Aaronzjp.cn"},"pages":[{"title":"标签","date":"2014-12-22T04:39:04.000Z","updated":"2017-06-08T02:00:29.000Z","comments":true,"path":"tags/index.html","permalink":"Aaronzjp.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ReactiveCocoa 和 MVVM 的简单使用","slug":"ReactiveCocoa-and-MVVM","date":"2017-08-28T05:14:55.000Z","updated":"2017-08-31T06:51:40.776Z","comments":true,"path":"2017/08/28/ReactiveCocoa-and-MVVM/","link":"","permalink":"Aaronzjp.cn/2017/08/28/ReactiveCocoa-and-MVVM/","excerpt":"MVVM在 iOS 中最开始的时候以及我们一开始学习的时候就是使用的 MVC 的模式来进行iOS App 开发的。MVC 的模式总的来说就是分为三个部分 Model(数据模型)、View(界面，视图)、Controller(控制器)。 在 MVC 中他们的通信方式如下图所示，该图来自斯坦福公开课中的 PDF 文件。","text":"MVVM在 iOS 中最开始的时候以及我们一开始学习的时候就是使用的 MVC 的模式来进行iOS App 开发的。MVC 的模式总的来说就是分为三个部分 Model(数据模型)、View(界面，视图)、Controller(控制器)。 在 MVC 中他们的通信方式如下图所示，该图来自斯坦福公开课中的 PDF 文件。 如图所示，在 iOS 开发中 MVC 的模式之间的通信方式如图所示，在该模式中 Model 和 View 之间是无法相互通信的，都是通过 Controller 来完成 Model 和 VIew 之前的通信。如此一来 Controller 中的东西就会十分多，Controller 类就会十分的复杂和大量的代码。所以后来就出现了 MVVM 的模式。 MVVM 它分别是由 Model View View-Model 三个部分组成的。 Model：Model 在 MVVM 模式中没有太大的变化，主要还是数据的模型。可能也会在其中封装一部分的关于数据处理和业务逻辑的一些代码。 View：很明显就是说视图，在 iOS 中视图不单单是视图类的代码，其中也包括了 storyboard、xib等视图，同时也包括 Controller 在内。 View-Model：View-Model 在这里看起来应该是前面两种的组合，其实并不是。这里的 View-Model 其实是负责视图显示需要数据的处理的一个类，可以包括数据的请求，数据的处理等。View-Model 中的数据主要提供给 View 用来展示和显示。 MVVM 其结构图如下所示： 图片来自维基百科，在 iOS 中图上的 View 也应该包括 Controller。其中 View-Model 是介于 View(Controller) 和 Model 之间的。在 MVVM 模式中数据的获取和数据的获取以及数据的处理都是在 View-Model 中来完成的，其中 View-Model 再通过 Model 将数据转化成一个一个的 Model 用来供视图展示和显示出来。其实 MVVM 模型就是一个 MVC 经过优化后的模式。它将原来需要在 View(Controller) 中需要处理的数据单独提取到 View-Model 中来处理，这样 View(Controller) 只要负责显示即可，让 View(Controller) 更加的轻量化。 MVVM与ReactiveCocoaView-ModelView-Model 是和 Controller 在一起的，但是 View-Model 和 Controller 是相互独立的两个东西，View-Model 基本上是负责处理数据的获取和过滤的。Controller 通过 View-Model 获取数据来使用。 在例子中，有这样一个 UITableView 用来展示一些车辆审验的信息，这里结合了 ReactiveCocoa 来做控制数据请求后的数据流动。请求获取大数据后，通过在 Controller 对信号订阅从信号管道中获取到数据。我看到有的人是在请求到的数据通过只读属性暴露在外的，但是我绝既然这里使用了 ReactiveCocoa 来做处理，所以我还是把数据通过信号管道的方式来使用请求到的数据好一点。另外 View-Model 这个类在设计的时候因为对数据种类这点没考虑到所以这个类设计得不是很好，这里也就先不细化的说了。主要记录一下 MVVM + ReactiveCocoa 的简单的使用的一个范例。 CarCheckViewModel.h 1234567891011121314151617181920#import &lt;Foundation/Foundation.h&gt;#import &lt;ReactiveObjC.h&gt;#import &quot;CarCheckModel.h&quot;//数据种类typedef NS_ENUM(NSUInteger, CarCheckDataType) &#123; Plan = 0, History&#125;;@interface CarCheckViewModel : NSObject@property (nonatomic,strong,readonly) RACCommand *getCarCheckListCommand;//加载数据- (void)loadDataWithType:(CarCheckDataType)type;//加载更多数据- (void)loadMoreDataWithType:(CarCheckDataType)type;//刷新数据- (void)refreshDataWithType:(CarCheckDataType)type;@end CarCheckViewModel.m 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#import &quot;CarCheckViewModel.h&quot;#import &quot;CarCheckAPIManager.h&quot;#import &quot;AccountManager.h&quot;#import &quot;CarCheckModel.h&quot;@interface CarCheckViewModel()@property (nonatomic,strong,readwrite) RACCommand *getCarCheckListCommand;//Model数组@property (nonatomic,strong,readwrite) NSArray&lt;CarCheckModel *&gt; *carCheckList;@end@implementation CarCheckViewModel- (instancetype)init &#123; if (self = [super init]) &#123; if (!_getCarCheckListCommand) &#123; _getCarCheckListCommand = [[RACCommand alloc]initWithSignalBlock:^RACSignal * _Nonnull(id _Nullable input) &#123; return [self getCarCheckListSignalWithParameter:input]; &#125;]; &#125; &#125; return self;&#125;- (void)loadDataWithType:(CarCheckDataType)type &#123; NSDictionary *parameter = @&#123;@&quot;number&quot;:[[AccountManager sharedInstance]getStoredNumber],@&quot;first&quot;:@(0),@&quot;type&quot;:@(type)&#125;; [self.getCarCheckListCommand execute:parameter];&#125;- (void)loadMoreDataWithType:(CarCheckDataType)type &#123; NSDictionary *parameter = @&#123;@&quot;number&quot;:[[AccountManager sharedInstance]getStoredNumber],@&quot;first&quot;:@(_carCheckList.count),@&quot;type&quot;:@(type)&#125;; [self.getCarCheckListCommand execute:parameter];&#125;- (void)refreshDataWithType:(CarCheckDataType)type &#123; [self loadDataWithType:type];&#125;- (RACSignal *)getCarCheckListSignalWithParameter:(NSDictionary *) parameter &#123; RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [[[CarCheckAPIManager alloc]init]loadDataWithParams:parameter success:^(id data) &#123; [subscriber sendNext:data]; [subscriber sendCompleted]; &#125; failure:^(id data) &#123; [subscriber sendError:data]; [subscriber sendCompleted]; &#125;]; return nil; &#125;]; return [signal map:^id _Nullable(id _Nullable value) &#123; NSMutableArray *dicArray = value[@&quot;resultInfos&quot;]; _carCheckList = [[dicArray.rac_sequence map:^id _Nullable(id _Nullable value) &#123; return [[CarCheckModel alloc]initWithDictionary:value]; &#125;] array]; return _carCheckList; &#125;];&#125;@end Model他的 Model 类如下，该模型类是使用 JSONExport 自动生成的： CarCheckModel.h 1234567891011121314#import &lt;UIKit/UIKit.h&gt;@interface CarCheckModel : NSObject@property (nonatomic, strong) NSString * inspectionTime;@property (nonatomic, strong) NSString * plateNumber;@property (nonatomic, strong) NSString * remark;@property (nonatomic, assign) NSInteger type;@property (nonatomic, strong) NSString * waiteTime;-(instancetype)initWithDictionary:(NSDictionary *)dictionary;-(NSDictionary *)toDictionary;@end CarCheckModel.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#import &quot;CarCheckModel.h&quot;NSString *const kCarCheckModelInspectionTime = @&quot;inspectionTime&quot;;NSString *const kCarCheckModelPlateNumber = @&quot;plateNumber&quot;;NSString *const kCarCheckModelRemark = @&quot;remark&quot;;NSString *const kCarCheckModelType = @&quot;type&quot;;NSString *const kCarCheckModelWaiteTime = @&quot;waiteTime&quot;;@interface CarCheckModel ()@end@implementation CarCheckModel/** * Instantiate the instance using the passed dictionary values to set the properties values */-(instancetype)initWithDictionary:(NSDictionary *)dictionary&#123; self = [super init]; if(![dictionary[kCarCheckModelInspectionTime] isKindOfClass:[NSNull class]])&#123; self.inspectionTime = dictionary[kCarCheckModelInspectionTime]; &#125; if(![dictionary[kCarCheckModelPlateNumber] isKindOfClass:[NSNull class]])&#123; self.plateNumber = dictionary[kCarCheckModelPlateNumber]; &#125; if(![dictionary[kCarCheckModelRemark] isKindOfClass:[NSNull class]])&#123; self.remark = dictionary[kCarCheckModelRemark]; &#125; if(![dictionary[kCarCheckModelType] isKindOfClass:[NSNull class]])&#123; self.type = [dictionary[kCarCheckModelType] integerValue]; &#125; if(![dictionary[kCarCheckModelWaiteTime] isKindOfClass:[NSNull class]])&#123; self.waiteTime = dictionary[kCarCheckModelWaiteTime]; &#125; return self;&#125;/** * Returns all the available property values in the form of NSDictionary object where the key is the approperiate json key and the value is the value of the corresponding property */-(NSDictionary *)toDictionary&#123; NSMutableDictionary * dictionary = [NSMutableDictionary dictionary]; if(self.inspectionTime != nil)&#123; dictionary[kCarCheckModelInspectionTime] = self.inspectionTime; &#125; if(self.plateNumber != nil)&#123; dictionary[kCarCheckModelPlateNumber] = self.plateNumber; &#125; if(self.remark != nil)&#123; dictionary[kCarCheckModelRemark] = self.remark; &#125; dictionary[kCarCheckModelType] = @(self.type); if(self.waiteTime != nil)&#123; dictionary[kCarCheckModelWaiteTime] = self.waiteTime; &#125; return dictionary;&#125;/** * Implementation of NSCoding encoding method *//** * Returns all the available property values in the form of NSDictionary object where the key is the approperiate json key and the value is the value of the corresponding property */- (void)encodeWithCoder:(NSCoder *)aCoder&#123; if(self.inspectionTime != nil)&#123; [aCoder encodeObject:self.inspectionTime forKey:kCarCheckModelInspectionTime]; &#125; if(self.plateNumber != nil)&#123; [aCoder encodeObject:self.plateNumber forKey:kCarCheckModelPlateNumber]; &#125; if(self.remark != nil)&#123; [aCoder encodeObject:self.remark forKey:kCarCheckModelRemark]; &#125; [aCoder encodeObject:@(self.type) forKey:kCarCheckModelType]; if(self.waiteTime != nil)&#123; [aCoder encodeObject:self.waiteTime forKey:kCarCheckModelWaiteTime]; &#125;&#125;/** * Implementation of NSCoding initWithCoder: method */- (instancetype)initWithCoder:(NSCoder *)aDecoder&#123; self = [super init]; self.inspectionTime = [aDecoder decodeObjectForKey:kCarCheckModelInspectionTime]; self.plateNumber = [aDecoder decodeObjectForKey:kCarCheckModelPlateNumber]; self.remark = [aDecoder decodeObjectForKey:kCarCheckModelRemark]; self.type = [[aDecoder decodeObjectForKey:kCarCheckModelType] integerValue]; self.waiteTime = [aDecoder decodeObjectForKey:kCarCheckModelWaiteTime]; return self;&#125;/** * Implementation of NSCopying copyWithZone: method */- (instancetype)copyWithZone:(NSZone *)zone&#123; CarCheckModel *copy = [CarCheckModel new]; copy.inspectionTime = [self.inspectionTime copy]; copy.plateNumber = [self.plateNumber copy]; copy.remark = [self.remark copy]; copy.type = self.type; copy.waiteTime = [self.waiteTime copy]; return copy;&#125;@end 该类主要是数据模型的作用，用来存储和使用数据，以及对数据进行一些业务逻辑的处理的作用。 View(Controller)通过这样的方式后在 View 中主要做的事就很简单了，只需要把数据和 View 绑定起来并展示出来就可以。在这个类中涉及了项目中很多其他的类，所以不要在意其他的，重要的是看清思路，MVVM 大概就是这么个结构来做处理的。当然在这个页面中只是用来展示东西，没有了其他更多的操作。具体应用到项目中的时候，可能还要结合 ReactiveCocoa 来做一些其他的功能，比如登陆界面，也可以使用 MVVM + ReactiveCocoa 来做，使用 ReactiveCocoa 来监控用户的交互判断用户名和密码来决定是否可以登陆和是否登陆成功等。 CarCheckViewController.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#import &quot;CarCheckViewController.h&quot;#import &quot;CarCheckTableViewCell.h&quot;#import &quot;CarCheckViewModel.h&quot;#import &quot;AccountManager.h&quot;#import &quot;HLYHUD.h&quot;#import &quot;TaskVCHeaderView.h&quot;#import &quot;MJRefresh.h&quot;@interface CarCheckViewController () &lt;UITableViewDataSource,UITableViewDelegate&gt;@property (nonatomic,strong) UITableView *planTableView;@property (nonatomic,strong) UITableView *historyTableView;@property (nonatomic,strong) CarCheckViewModel *planViewModel;@property (nonatomic,strong) CarCheckViewModel *historyViewModel;@property (nonatomic,strong) NSArray&lt;CarCheckModel *&gt; *planDataSource;@property (nonatomic,strong) NSArray&lt;CarCheckModel *&gt; *historyDataSource;@property (nonatomic,strong) TaskVCHeaderView *segmentView;@property (nonatomic,strong) UIScrollView *scrollView;@property (nonatomic,assign) NSInteger currentPageIndex;@end@implementation CarCheckViewController- (CarCheckViewModel *)planViewModel &#123; if (!_planViewModel) &#123; _planViewModel = [[CarCheckViewModel alloc]init]; [_planViewModel.getCarCheckListCommand.executionSignals.switchToLatest subscribeNext:^(id _Nullable x) &#123; _planDataSource = x; [_planTableView.mj_header endRefreshing]; [_planTableView.mj_footer endRefreshing]; [_planTableView reloadData]; &#125;]; [_planViewModel.getCarCheckListCommand.errors subscribeNext:^(id _Nullable x) &#123; [HLYHUD hideHUDForView:_planTableView]; [_planTableView.mj_header endRefreshing]; [_planTableView.mj_footer endRefreshing]; [HLYHUD showHUDWithMessage:x[@&quot;message&quot;] addToView:_planTableView]; &#125;]; [_planViewModel.getCarCheckListCommand.executing subscribeNext:^(NSNumber * _Nullable x) &#123; if ([x boolValue]) &#123; [HLYHUD showLoadingHudAddToView:self.view]; &#125; else &#123; [HLYHUD hideHUDForView:self.view]; &#125; &#125;]; &#125; return _planViewModel;&#125;- (CarCheckViewModel *)historyViewModel &#123; if (!_historyViewModel) &#123; _historyViewModel = [[CarCheckViewModel alloc]init]; [_historyViewModel.getCarCheckListCommand.executionSignals.switchToLatest subscribeNext:^(id _Nullable x) &#123; _historyDataSource = x; [_historyTableView.mj_header endRefreshing]; [_historyTableView.mj_footer endRefreshing]; [_historyTableView reloadData]; &#125;]; [_historyViewModel.getCarCheckListCommand.errors subscribeNext:^(id _Nullable x) &#123; [HLYHUD hideHUDForView:_historyTableView]; [_historyTableView.mj_header endRefreshing]; [_historyTableView.mj_footer endRefreshing]; [HLYHUD showHUDWithMessage:x[@&quot;message&quot;] addToView:_historyTableView]; &#125;]; [_historyViewModel.getCarCheckListCommand.executing subscribeNext:^(NSNumber * _Nullable x) &#123; if ([x boolValue]) &#123; [HLYHUD showLoadingHudAddToView:self.view]; &#125; else &#123; [HLYHUD hideHUDForView:self.view]; &#125; &#125;]; &#125; return _historyViewModel;&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor]; self.title = @&quot;车辆审验&quot;; _currentPageIndex = 100; _segmentView = [[TaskVCHeaderView alloc]initWithFrame:CGRectMake(0, 0, kScreenWidth, 44)]; _segmentView.titleArray = @[@&quot;计划执行&quot;,@&quot;历史记录&quot;]; __weak CarCheckViewController *weakSelf =self; _segmentView.changeVCBlock = ^(NSInteger index) &#123; if (index == _currentPageIndex) &#123; return; &#125; else &#123; _currentPageIndex = index; if (index == 100) &#123; [weakSelf.scrollView setContentOffset:CGPointMake(0, 0) animated:YES]; [weakSelf.planViewModel loadDataWithType:Plan]; &#125; else &#123; [weakSelf.scrollView setContentOffset:CGPointMake(CGRectGetWidth(weakSelf.view.bounds), 0) animated:YES]; [weakSelf.historyViewModel loadDataWithType:History]; &#125; &#125; &#125;; [self.view addSubview:_segmentView]; _scrollView = [[UIScrollView alloc]initWithFrame:CGRectMake(0, 44, CGRectGetWidth(self.view.bounds) * 2, CGRectGetHeight(self.view.bounds) - 44)]; [self.view addSubview:_scrollView]; _planTableView = [[UITableView alloc]initWithFrame:CGRectMake(0, 0, self.view.bounds.size.width, self.view.bounds.size.height - 44) style:UITableViewStylePlain]; _planTableView.dataSource = self; _planTableView.delegate = self; _planTableView.rowHeight = UITableViewAutomaticDimension; _planTableView.estimatedRowHeight = 100; _planTableView.tableFooterView = [UIView new]; _planTableView.mj_header = [MJRefreshNormalHeader headerWithRefreshingBlock:^&#123; [_planViewModel refreshDataWithType:Plan]; &#125;]; _planTableView.mj_footer = [MJRefreshBackNormalFooter footerWithRefreshingBlock:^&#123; [_planViewModel loadMoreDataWithType:Plan]; &#125;]; [_scrollView addSubview:_planTableView]; _historyTableView = [[UITableView alloc]initWithFrame:CGRectMake(CGRectGetWidth(self.view.bounds), 0, self.view.bounds.size.width, self.view.bounds.size.height - 44) style:UITableViewStylePlain]; _historyTableView.dataSource = self; _historyTableView.delegate = self; _historyTableView.rowHeight = UITableViewAutomaticDimension; _historyTableView.estimatedRowHeight = 100; _historyTableView.tableFooterView = [UIView new]; _historyTableView.mj_header = [MJRefreshNormalHeader headerWithRefreshingBlock:^&#123; [_historyViewModel refreshDataWithType:History]; &#125;]; _historyTableView.mj_footer = [MJRefreshBackNormalFooter footerWithRefreshingBlock:^&#123; [_historyViewModel loadMoreDataWithType:History]; &#125;]; [_scrollView addSubview:_historyTableView]; [self.planViewModel loadDataWithType:Plan];&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; &#125;- (NSInteger) tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123; if (tableView == _historyTableView) &#123; return _historyDataSource.count; &#125; else &#123; return _planDataSource.count; &#125;&#125;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; static NSString *identifier = @&quot;CheckCarCell&quot;; CarCheckTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:identifier]; if (!cell) &#123; cell = [[CarCheckTableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:identifier]; &#125; CarCheckModel *carCheck; if (tableView == _historyTableView) &#123; carCheck = _historyDataSource[indexPath.row]; &#125; else &#123; carCheck = _planDataSource[indexPath.row]; &#125; [cell fillDataWithModel:carCheck]; return cell;&#125;@end","categories":[],"tags":[{"name":"Reactive Cocoa","slug":"Reactive-Cocoa","permalink":"Aaronzjp.cn/tags/Reactive-Cocoa/"},{"name":"MVVM","slug":"MVVM","permalink":"Aaronzjp.cn/tags/MVVM/"}]},{"title":"ReactiveCocoa的基本使用","slug":"Use-ReactiveCocoa","date":"2017-08-03T01:59:47.000Z","updated":"2017-08-28T05:13:25.000Z","comments":true,"path":"2017/08/03/Use-ReactiveCocoa/","link":"","permalink":"Aaronzjp.cn/2017/08/03/Use-ReactiveCocoa/","excerpt":"什么是ReactiveCocoa？最近因为公司的一个项目因为是用 ReactiveCocoa 结合 MVVM 来写的，所以在我接手的时候我也打算继续使用这种模式，因为我觉得这种模式还是有一定的好处的，通过 ReactiveCocoa 的使用强化了项目中围绕数据变化所做的改变。所以最近还是学习一下 ReactiveCocoa 的一些基本的使用。 ReactiveCocoa（其简称为RAC）是由Github工程师们开发的一个应用于iOS和OS X开发的函数响应式编程新框架。ReactiveCocoa 的灵感来源于 函数式响应式编程。ReactiveCocoa 的优点是可以很轻松的处理状态以及状态之间依赖过多的问题，同时也是一种很好的消息传递的机制。通过对 RACSignal (信号) 的使用，可以很好的处理事件流，以及事件的监控，状态改变的处理。","text":"什么是ReactiveCocoa？最近因为公司的一个项目因为是用 ReactiveCocoa 结合 MVVM 来写的，所以在我接手的时候我也打算继续使用这种模式，因为我觉得这种模式还是有一定的好处的，通过 ReactiveCocoa 的使用强化了项目中围绕数据变化所做的改变。所以最近还是学习一下 ReactiveCocoa 的一些基本的使用。 ReactiveCocoa（其简称为RAC）是由Github工程师们开发的一个应用于iOS和OS X开发的函数响应式编程新框架。ReactiveCocoa 的灵感来源于 函数式响应式编程。ReactiveCocoa 的优点是可以很轻松的处理状态以及状态之间依赖过多的问题，同时也是一种很好的消息传递的机制。通过对 RACSignal (信号) 的使用，可以很好的处理事件流，以及事件的监控，状态改变的处理。 ReactiveCocoa与传统iOS开发的比较在传统的代码中如果我们要去检测 TextFiled 中输入的变换可能需要像下面这样使用： 12345[self.usernameTextField addTarget:self action:@selector(usernameTextFieldChanged) forControlEvents:UIControlEventEditingChanged:];- (void)passwordTextFieldChanged:(UITextField *)sender &#123; NSLog(@“%@”,sender.text);&#125; 但是在 ReactiveCocoa 中我们就可以很巧妙的用极少的代码在 Block 中去处理 TextFiled 的输入状态的变化，代码如下： 123[self.usernameTextField.rac_textSignal subscribeNext:^(NSString * _Nullable x) &#123; NSLog(@&quot;%@&quot;,x);&#125;]; 是不是很简便，但是这只是简单的处理，所以看不出来特别大的优势，如果是稍微复杂一点的，ReactiveCocoa 的优势就可以很明显的展示出来了。 ReactiveCocoa的简单使用信号创建大部分情况下 ReactiveCocoa 框架中 UIKit 控件都已经添加了信号，供我们订阅信号进行处理。但是在有些时候我们也需要自己去创建信号。创建信号方式如下： 123456789101112// 1.创建信号RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;// 3.发送信号[subscriber sendNext:@&quot;ws&quot;];// 4.取消信号，如果信号想要被取消，就必须返回一个RACDisposable// 信号什么时候被取消：1.自动取消，当一个信号的订阅者被销毁的时候机会自动取消订阅，2.手动取消，//block什么时候调用：一旦一个信号被取消订阅就会调用//block作用：当信号被取消时用于清空一些资源return [RACDisposable disposableWithBlock:^&#123;NSLog(@&quot;取消订阅&quot;);&#125;];&#125;]; 信号订阅信号订阅，通过信号订阅我们可以做到实时观察需要的数据以及状态。比如要观察处理 UITextField 的输入： 123[self.usernameTextField.rac_textSignal subscribeNext:^(NSString * _Nullable x) &#123; NSLog(@&quot;%@&quot;,x);&#125;]; 上面的代码当 usernameTextField 在输入时，输入的文字改变就会触发 block 中代码的执行。 ReactiveCocoa 的信号会向信号的订阅者发送已订阅的事件流。其中发送的事件分为三种类型：next、error 和 completed。RACSignal 提供了多种方法用来订阅不同的事件类型。可以接受一个或多个 block 作为参数，当事件流传递到当前事件的时候，就会执行 block 中的代码。ReactiveCocoa 框架使用 Category 为大部分的标准的 UIKit 控件都添加了信号，通过这些已经添加的信号我们进行订阅，可以完成大部分常见的操作。同时我们也可以针对自己的控件自己定义信号。 信号可以被订阅，也可以被主动的取消订阅，取消订阅的方式如下： 1234567// 只要订阅信号就会返回一个取消订阅信号的类RACDisposable *disposable = [signal subscribeNext:^(id x) &#123;// block的调用时刻：只要信号内部发出数据就会调用这个blockNSLog(@&quot;======%@&quot;, x);&#125;];// 取消订阅[disposable dispose]; 信号过滤ReactiveCocoa还具有对事件流进行过滤的操作。比如下面这样，我们只需要在控制台打印字符串长度超过3的情况。 123456[[self.usernameTextField.rac_textSignal filter:^BOOL(NSString * _Nullable value) &#123; NSString *text = value; return text.length &gt; 3;&#125;] subscribeNext:^(NSString * _Nullable x) &#123; NSLog(@&quot;%@&quot;,x);&#125;]; 现在再 TextField 中输入，只有当字符串长度超过3点时候才会在控制台打印出来。 信号的处理在 ReactiveCocoa 中还可以对当前原始信号进行处理后在进入到事件流中。如下： 1234567[[[self.usernameTextField.rac_textSignal map:^id _Nullable(NSString * _Nullable value) &#123; return @(value.length);&#125;] filter:^BOOL(id _Nullable value) &#123; return [value integerValue] &gt; 3;&#125;] subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;%@&quot;,x);&#125;]; 上面的代码中我们就将 NSString 类型的 Vlue 进行了处理，当它传到下一步时就成了NSNumber 类型了。当然也可以对这里的 Value 做其他操作，传到下一步的时候就是其他类型的数据了。 信号合成在某些时候，我们可能需要多种信号都满足某个条件后再进行下一步的操作和执行。比如做一个登陆的时候，当账号和密码都满足的时候才可以进行下一步的处理。这个时候我们就可以使用信号合并，将账号验证的信号和密码验证的信号合并后来出来。 12345678910111213141516171819202122232425262728//账户验证的信号RACSignal *validUserNameSignal = [self.usernameTextField.rac_textSignal map:^id _Nullable(NSString * _Nullable value) &#123; return @([self isValidUsername:value]);&#125;];//密码验证的信号RACSignal *validPassWordSignal = [self.passwordTextField.rac_textSignal map:^id _Nullable(NSString * _Nullable value) &#123; return @([self isValidPassword:value]); &#125;]; //信号合并，完成登陆按钮的可点击RACSignal *mergeSignal = [RACSignal combineLatest:@[validUserNameSignal,validPassWordSignal] reduce:^id (NSNumber *userNameValid, NSNumber *passWordValid)&#123; return @([userNameValid boolValue] &amp;&amp; [passWordValid boolValue]);&#125;];//再次订阅合并的信号处理登陆按钮的响应[mergeSignal subscribeNext:^(id _Nullable x) &#123; self.signInButton.enabled = [x boolValue];&#125;];//账户和密码的验证方式- (BOOL)isValidUsername:(NSString *)username &#123; return username.length &gt; 3;&#125;- (BOOL)isValidPassword:(NSString *)password &#123; return password.length &gt; 3;&#125; 上面这段代码就使用信号合并，合并后的信号携带了一个 Bool 值，当每次其中一个发送新的信号时 reduce 中的block 就会执行返回的这个 Bool 值就会作为一个新的合成的这个信号发送出去，最终通过订阅这个合并后的信号携带的 Bool 值来判断登陆按钮是否可以被点击。 注意：RACSignal合成方法可以合成任意数量的信号，而reduce block的入参和源信号一一对应。ReactiveCocoa有一个巧妙的工具类RACBlockTrampoline，用以内部处理reduce block的可变入参列表。 信号中的信号有时候在信号中，我们可能还需要去创建一个新的信号，用来处理事件，但是这种信号中的信号，就是一个信号中又包含了另外一个信号。要怎么去处理呢？ ​ 可以通过在信号中去订阅这个内部的信号来获取里面信号的结果，但是这样做来说订阅嵌套会让代码很混乱，所以 ReactiveCocoa 为这样的情况提供了一个解决的方式。 使用 flattenMap 就可以过滤获取到内部的信号，在传到下一个事件的时候就传递的是内部的信号了。 12345678910111213141516171819[[[self.signInButton rac_signalForControlEvents:UIControlEventTouchUpInside] flattenMap:^__kindof RACSignal * _Nullable(__kindof UIControl * _Nullable value) &#123; return [self loginSignal];&#125;]subscribeNext:^(id _Nullable x) &#123; BOOL isLoginSucces = [x boolValue]; self.signInFailureText.hidden = isLoginSucces; [self performSegueWithIdentifier:@&quot;signInSuccess&quot; sender:self];&#125;];- (RACSignal *)loginSignal &#123; return [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [self.signInService signInWithUsername:self.usernameTextField.text password:self.passwordTextField.text complete:^(BOOL success) &#123; [subscriber sendNext:@(success)]; [subscriber sendCompleted]; &#125;]; return [RACDisposable disposableWithBlock:^&#123; NSLog(@&quot;信号订阅被取消&quot;); &#125;]; &#125;];&#125; 上面这段代码在处理按钮点击的信号中调用 [self loginSignal] 方法返回了一个新的信号，这就造成了信号中的信号，在下面的信号传递中获取到的 x 就获取到的是一个信号，而不是想要登陆的信号。所以这里用 flattenMap 去获取信号中的信号，以方便在接下来的信号传递中能方便的获取到信号中登陆信号中传递的值。 注入效果注入效果，主要的作用的是在信号发出的时候做出一些处理。注入效果有这样三种 -doNext: 、-doError: 、 -doCompleted: ，注入效果没有返回值，它只是在其对应的操作之前执行 block 中的代码。如下，在 -subscribeNext: 前作一些其他处理就可以使用 -doNext: 的注入效果： 123456789[[[[self.signInButton rac_signalForControlEvents:UIControlEventTouchUpInside] doNext:^(__kindof UIControl * _Nullable x) &#123; self.signInButton.enabled = NO;&#125;]flattenMap:^__kindof RACSignal * _Nullable(__kindof UIControl * _Nullable value) &#123; return [self loginSignal];&#125;]subscribeNext:^(id _Nullable x) &#123; BOOL isLoginSucces = [x boolValue]; self.signInFailureText.hidden = isLoginSucces; [self performSegueWithIdentifier:@&quot;signInSuccess&quot; sender:self];&#125;]; 这里就是在按钮被点击的时候在 -doNext: 的注入效果中将登陆按钮设置为不可用。 其余两个注入效果也是一样的，分别是在 -subscribeError: 和 -subscribeCompleted: 执行之前执行 block 中的代码，但是如果添加了注入效果，但是后面没有进行 -subscribeNext: 、 -subscribeError: 和 -subscribeCompleted: 操作的话注入效果是不会执行的。","categories":[],"tags":[{"name":"ReactiveCocoa","slug":"ReactiveCocoa","permalink":"Aaronzjp.cn/tags/ReactiveCocoa/"}]},{"title":"React Native开发环境搭建","slug":"React-Native IDE-setup","date":"2017-07-05T12:55:29.000Z","updated":"2017-07-26T06:09:08.000Z","comments":true,"path":"2017/07/05/React-Native IDE-setup/","link":"","permalink":"Aaronzjp.cn/2017/07/05/React-Native IDE-setup/","excerpt":"React Native的开发环境搭建Homebrew​ 首先需要安装一个包管理软件，Homebrew，该工具是在 Mac OS 下最受欢迎的一款包管理工具，但是在安装 Homebrew 之前最好是先确认是否安装了 Xcode ，因为这样就可以方便的使用基于 Xcode Command Line Tools 来安装该工具了。 打开 Terminal 输入如下命令： 12&gt; /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"&gt; 在安装 Homebrew 时可能会因为目录的写入权限问题安装失败，具体的使用Google查看解决方法。","text":"React Native的开发环境搭建Homebrew​ 首先需要安装一个包管理软件，Homebrew，该工具是在 Mac OS 下最受欢迎的一款包管理工具，但是在安装 Homebrew 之前最好是先确认是否安装了 Xcode ，因为这样就可以方便的使用基于 Xcode Command Line Tools 来安装该工具了。 打开 Terminal 输入如下命令： 12&gt; /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"&gt; 在安装 Homebrew 时可能会因为目录的写入权限问题安装失败，具体的使用Google查看解决方法。 Node安装完成 Homebrew 后就可以安装 Node 了，其实这里也可以选择不实用 Homebrew 来安装 Node ，可以直接访问 Node 的官网去下载安装包来进行安装。 使用 Homebrew 安装，在 Terminal 中输入如下命令： brew install node 安装完成后如果没有科学上网的梯子那就建议更改 npm 的镜像服务器吧。具体方法网上找。 YarnYarn是Facebook提供的替代 npm 的工具，可以加速 node 模块的下载。强烈建议安装这个插件，不但可以加速 React Native 中使用到的 node 模块的下载，同时 Hexo 也是可以的。 Yarn 和 npm 是一样需要翻墙的梯子才能使用的，不然速度很慢。如果速度太慢就设置镜像服务器吧。替换镜像服务器命令如下： yarn config set registry https://registry.npm.taobao.org –globalyarn config set disturl https://npm.taobao.org/dist –global 安装完yarn之后就可以用yarn代替npm了，例如用 yarn 代替 npm install 命令，用yarn add xxxx代替 npm install --save xxxx。 react-native-cli这个工具就不说了，是 React Native 的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。 安装命令如下： npm install -g react-native-cli 然后还要推荐的就是另外的一些工具包的安装 WatchmanWatchman 是由 Facebook 提供的监视文件系统变更的工具。安装此工具可以提高开发时的性能（packager可以快速捕捉文件的变化从而实现实时刷新）。 FlowFlow 是一个静态的 JS 类型检查工具。译注：你在很多示例中看到的奇奇怪怪的冒号问号，以及方法参数中像类型一样的写法，都是属于这个 flow 工具的语法。这一语法并不属于 ES 标准，只是 Facebook 自家的代码规范。所以新手可以直接跳过（即不需要安装这一工具，也不建议去费力学习flow相关语法）。 Nuclide这个工具主要是配合 Atom IDE 使用的，其他不使用该 IDE 的可以直接忽略掉这个工具包的安装。","categories":[],"tags":[{"name":"React Native","slug":"React-Native","permalink":"Aaronzjp.cn/tags/React-Native/"}]},{"title":"Swift-枚举","slug":"Swift-Enum","date":"2017-04-20T07:01:27.000Z","updated":"2017-08-01T07:06:31.000Z","comments":true,"path":"2017/04/20/Swift-Enum/","link":"","permalink":"Aaronzjp.cn/2017/04/20/Swift-Enum/","excerpt":"在 Swift 中枚举是一等类型。 Swift 中枚举是一个很强大的类型，在 C 语言中枚举会为一组整型值分配相关联的名称。但是在 Swift 中不是必须的，如果给枚举成员赋值(在 Swift 中又叫原始值)，则该值的类型可以是字符、字符串、整型、或者是一个浮点数。除了这些以为 Swift 中的枚举还可以指定任意类型的关联值到枚举成员中，还可以添加计算属性，实例方法，还可以定义构造函数，还可以遵守协议。","text":"在 Swift 中枚举是一等类型。 Swift 中枚举是一个很强大的类型，在 C 语言中枚举会为一组整型值分配相关联的名称。但是在 Swift 中不是必须的，如果给枚举成员赋值(在 Swift 中又叫原始值)，则该值的类型可以是字符、字符串、整型、或者是一个浮点数。除了这些以为 Swift 中的枚举还可以指定任意类型的关联值到枚举成员中，还可以添加计算属性，实例方法，还可以定义构造函数，还可以遵守协议。 枚举的定义枚举的定义如下： 123456789enum SomeFood &#123; case water case milk case bread&#125;//多个成员也可以使用逗号隔开的方式定义enum SomeFood &#123; case water, milk, bread&#125; 枚举中定义的值是这个枚举的成员值(成员)，可以用 case 来添加成员，其中这与 C 和 Obj-c 不同的是这里的枚举值不回被隐藏的赋值为整型，因为 Swift 中枚举的成员值本身就是完备的值，这些成员值的类型是已经被定义好的枚举的类型。 枚举其实就像是定义了一个全新的类型，就像 Swift 中其他的类型一样。如果枚举类型可以根据上下文推导出来，那么赋值一个枚举值的时候可以省略枚举类型。 123var food = SomeFood.bread//在初次的food = .milk 使用 switch 匹配枚举值 123456789var food = SomeFood.milkswitch food &#123;case .water: print(\"this is water\")case .milk: print(\"this is milk\")case .bread: print(\"this is bread\")&#125; 关联值在 Swift 中，枚举成员还可以添加任意类型的枚举关联值，但是在同一个枚举类型变量中，只能同时存在一个枚举成员的关联值。如下： 123456enum HttpStatus &#123; case errorCode(Int) case errorMessage(String)&#125;var code = HttpStatus.errorCode(5) 这些枚举值的关联值还可以通过变量/常量进行值绑定的方式提出来单独使用： 123456switch code &#123;case .errorCode(let code): print(\"\\(code)\")case .errorMessage(let message): print(message)&#125; 原始值在 Swift 中枚举除了关联值以为，枚举还可以有原始值(默认值)，原始值的类型必须相同，枚举的原始值需要显示的声明类型。原始值可以是字符串，字符，或者任意整型值或浮点型值。每个原始值在枚举声明中必须是唯一的。如下为枚举设置原始值： 123456enum Season: String &#123; case spring = \"春天\" case summer = \"夏天\" case autumn = \"秋天\" case winter = \"冬天\"&#125; 声明隐式原始值： 12345enum Number: Int &#123; case one,two,three,four,five,six,seven,eight,nine,ten&#125;let one = Number(rawValue: 0) 原始值为 Int 类型时默认是从0开始的，但是一旦设置了一个枚举成员的原始值，后面的原始值则依次递增1。原始值为 String 类型时默认原始值是该枚举成员的名称。原始值是其他类型的时候则需要一个一个的设置其原始值。 123456enum Constants: Double &#123; case π = 3.14159 case e = 2.71828 case φ = 1.61803398874 case λ = 1.30357&#125; 使用枚举成员的 rawValue 属性可以访问枚举成员的原始值： 123456enum Number: Int &#123; case one,two = 8,three,four,five,six,seven,eight,nine,ten&#125;let one = Number.eight.rawValue//输出 14 使用原始值初始化枚举成员，该方法会返回一个可选枚举成员，因为可能存在没有原始值对应的枚举成员： 12345enum Number: Int &#123; case one,two = 8,three,four,five,six,seven,eight,nine,ten&#125;let six = Number(rawValue: 6)//该值不回返回6，而是nil 递归枚举枚举递归可以让枚举包含枚举本身，如下嫁入文件夹和文件的关系就可以这样表示，因为文件夹中可以包含文件和文件夹： 12345678910enum FileNode &#123; case File(name: String) indirect case Folder(name: String, files: [FileNode])&#125;let fileName = FileNode.File(name: \"变形金刚\")let fileName2 = FileNode.File(name: \"西游记\")let fileName3 = FileNode.Folder(name: \"动作电影\", files: [FileNode.Folder(name: \"日本的\", files: [FileNode.File(name: \"MIAE-044 女子校生拷問フェラくらぶマニアックスvol.1\")])])let fileFolder = FileNode.Folder(name: \"电影\", files: [fileName,fileName2,fileName3]) 更多高阶用法参考Swift中枚举的高级用法与实践","categories":[],"tags":[{"name":"Swift","slug":"Swift","permalink":"Aaronzjp.cn/tags/Swift/"}]},{"title":"自定义转场动画（ViewController Transition）","slug":"TransitionAnimation","date":"2017-04-19T09:28:41.000Z","updated":"2017-07-27T02:52:28.000Z","comments":true,"path":"2017/04/19/TransitionAnimation/","link":"","permalink":"Aaronzjp.cn/2017/04/19/TransitionAnimation/","excerpt":"什么是转场动画，转场动画就是从一个 Controller 跳转到另一个 Controller 时呈现的动画。在现在的iOS App 中很多 App 都实现了自己的转场动画，要知道自定义转场动画在 iOS7 以前是没有这么轻松的，在 iOS7 以前要想自定义转场动画那就只能自己去一步一步的实现，很久以前我隐约记得我看过一篇文章是关于自定义控制器容易器转场动画的，大概意思就是自定","text":"什么是转场动画，转场动画就是从一个 Controller 跳转到另一个 Controller 时呈现的动画。在现在的iOS App 中很多 App 都实现了自己的转场动画，要知道自定义转场动画在 iOS7 以前是没有这么轻松的，在 iOS7 以前要想自定义转场动画那就只能自己去一步一步的实现，很久以前我隐约记得我看过一篇文章是关于自定义控制器容易器转场动画的，大概意思就是自定 义一个 ContainerViewController 将要转场的两个控制器放入到 ContainerViewController ，然后使用 UIView 的+ (void)transitionFromView:(UIView *)fromView toView:(UIView *)toView duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options completion:(void (^)(BOOL finished))completion; 方法，在该方法中去完成转场到操作，具体怎么做我也懒的去研究了，这里还是继续看一下 iOS7 提供的转场动画的 API 的使用。在 iOS7 之后苹果公开了一些接口可以让我们很轻松的来自定义转场动画。 自定义转场动画自定义转场动画总共的大概分为以下步骤： 提供一个遵守 &lt;UIViewControllerAnimatedTransitioning&gt; 协议的动画控制器（Animation Controller）。在动画控制器中我们需要完成转场时间以及转场动画的提供。 提供一个遵守 &lt;UIviewControllerInteractiveTransitioning&gt; 协议的交互控制器（Interaction Controller），该控制器其实不需要自己去实现，因为苹果已经提供了一个封装好了的交互控制器 UIPercentDrivenInteractiveTransition 。 自定义转场动画的控制器提供转场代理（Transition Delegate），遵守代理的规则。 转场代理目前来说有三种，分别对应了三种不同类型的转场情况，分别如下： 123&lt;UINavigationControllerDelegate&gt; //UINavigationController 的 delegate 属性遵守该协议。&lt;UIViewControllerTransitioningDelegate&gt; //UIViewController 的 transitioningDelegate 属性遵守该协议。&lt;UITabBarControllerDelegate&gt; //UITabBarController 的 delegate 属性遵守该协议。 在转场动画发生的时候这三个协议中都分别有不同的方法要求我们提供一个动画控制器和一个交互控制器，这都是可选的。 除了上面说的这些以外还有两个会用到的那就是转场环境（Transition Context）和转场协调器（Transition Coordinator），其中转场环境是必须的，转场环境遵守 &lt;UIViewControllerContextTransitioning&gt; 协议，不过这是系统提供给我们的，方便我们在转场时，获取转场中需要的数据。转场协调器目前我还没有具体的使用过，转场协调器遵守 &lt;UIViewControllerTransitionCoordinator&gt; 协议，可以通过控制器的 transitionCoordinator 属性获取转场协调器，不过它只在转场的过程中才会存在，如果处于非转场状态下该属性会返回 nil。 开始DemoPush／Pop 转场废话也不多说了，直接开始上代码。首先写一个 NavigationController 的 Push 和 Pop 的转场动画。 首先用 StoryBoard 快速的拖出两个控制器来。在我的 Demo 中根视图是一个 UITableViewController ，被 Push 的控制器是一个普通的 Controller。如图： 目前这个 Demo 就可以 Run 起来了，只不过动画是系统默认的，致于 Demo 中具体放什么东西就不说了，Demo 而已你想放啥就放啥。接下来我们开始自定义转场动画中需要的动画，就是动画控制器。 新建一个 PushAnimation 的类并遵守 &lt;UIViewControllerAnimatedTransitioning&gt; 协议如下： 1234567// PushAnimation.h#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;@interface PushAnimation : NSObject &lt;UIViewControllerAnimatedTransitioning&gt;@end 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// PushAnimation.m#import &quot;PushAnimation.h&quot;#import &quot;RootTableViewController.h&quot;#import &quot;RootDetailViewController.h&quot;#import &quot;RootTableViewCell.h&quot;@implementation PushAnimation- (NSTimeInterval)transitionDuration:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123; return 0.5;&#125;- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123; //通过转场环境获取 fromVC 和 toVC。 RootTableViewController *fromVC = (RootTableViewController *)[transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey]; RootDetailViewController *toVC = (RootDetailViewController *)[transitionContext viewControllerForKey:UITransitionContextToViewControllerKey]; //获取 fromVC 中被选中的 Cell RootTableViewCell *cell = [fromVC.tableView cellForRowAtIndexPath:fromVC.currentIndexPath]; //通过转场环境获取 容器视图 UIView *containerView = [transitionContext containerView]; //获取 Cell 中 headerView 的截图 UIView *cellImageView = [cell.headerView snapshotViewAfterScreenUpdates:NO]; //将获取到的 cell 的 headerView 的截图的 frame 转换成当前容器视图的位置 cellImageView.frame = [cell.headerView convertRect:cell.headerView.bounds toView:containerView]; //设置转场前初始的状态 toVC.view.alpha = 0; cell.headerView.hidden = YES; toVC.headerImageView.hidden = YES; //把需要参与到转场动画中的视图添加到容器视图中 [containerView addSubview:toVC.view]; [containerView addSubview:cellImageView]; //转场动画开始 [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^&#123; //需要更新布局 否则在横屏状态下 cellImageView 位置不正确 [containerView layoutIfNeeded]; cellImageView.frame = [toVC.headerImageView convertRect:toVC.headerImageView.bounds toView:containerView]; toVC.view.alpha = 1; &#125; completion:^(BOOL finished) &#123; [cellImageView removeFromSuperview]; toVC.headerImageView.hidden = NO; cell.headerView.hidden = NO; //动画结束后必须要向 Context 调用该方法通知动画结束，这里可以直接返回YES，如果动画有手势参与到话最好不要直接返回YES [transitionContext completeTransition:YES]; &#125;]; &#125;@end &lt;UIViewControllerAnimatedTransitioning&gt; 协议主要有两个方法： - (NSTimeInterval)transitionDuration:(nullable id &lt;UIViewControllerContextTransitioning&gt;)transitionContext; 该方法返回一个 NSTimeInterval ，即转场动画的时间长度，确定转场动画所需要的时间。在该方法中系统还提供了一个上文中提到的转场环境。 - (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext; 该方法没有返回值，同时也为我们提供了转场环境，转场的动画就需要在这个方法里面来完成。这里得说下 fromVc 和 toVC ，这两个是一个相对的概念，就是说当前正在显示的 Controller 就是 fromVC ，将要转场过去的 Controller 就是 toVC。 上面讲到的自定义转场动画的步骤到这已经完成了第一步，但是现在先跳过第二部，暂时不添加交互控制器到我们的转场动画中来，先完成转场动画后再添加。现在进入到第三步，遵守转场动画协议，为转场动画提供代理。 12345678// RootTableViewController.h#import &lt;UIKit/UIKit.h&gt;@interface RootTableViewController : UITableViewController//这个属性就是用来记录被选中的Cell的，在上面动画控制器中就通过这个属性来获取的Cell@property (nonatomic,strong) NSIndexPath *currentIndexPath;@end 1234567891011121314151617181920212223242526272829303132333435363738394041// RootTableViewController.m#import &quot;RootTableViewController.h&quot;#import &quot;PushAnimation.h&quot;@interface RootTableViewController () &lt;UINavigationControllerDelegate&gt;...@property (nonatomic,strong) PushAnimation *pushAnimation;...@end@implementation RootTableViewController- (void)viewDidLoad &#123; [super viewDidLoad]; ... ... self.pushAnimation = [PushAnimation new]; self.navigationController.delegate = self;&#125;#pragma mark - Table view data source......#pragma mark - Table view data delegate......#pragma mark - UINavigationControllerDelegate// 1.转场协议，返回一个 遵守 UIViewControllerAnimatedTransitioning 协议的类。（就是动画控制器）- (id&lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController animationControllerForOperation:(UINavigationControllerOperation)operation fromViewController:(UIViewController *)fromVC toViewController:(UIViewController *)toVC &#123; if (operation == UINavigationControllerOperationPush) &#123; return _pushAnimation; &#125; else &#123; return nil; &#125;&#125; 完成了上面的这些，现在这个 Demo 在 Push 的时候就已经是我们的自定义的转场动画了。测试一下，没问题。 Pop 动画呢这里就不详细说太多了，和 Push 是一样的，写个动画控制器，在转场协议的方法中（上面代码中标为1的那个方法）判断一下，返回一个 Pop 的动画控制器就可以了。 添加交互控制器上面已经讲了系统已经为我们封装好了一个交互控制器，我们继承这个类就可以了。代码如下： 12345678910// SwipInteractiveTransition.h#import &lt;UIKit/UIKit.h&gt;@interface SwipInteractiveTransition : UIPercentDrivenInteractiveTransition//该属性用来记录是否处于交互中，后面会用到这个属性@property (nonatomic,assign) BOOL interacting;//添加一个添加手势的方法- (void)addGestureInViewController:(UIViewController *)controller;@end 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// SwipInteractiveTransition.m#import &quot;SwipInteractiveTransition.h&quot;@interface SwipInteractiveTransition ()//该属性用来持有被添加手势的控制器，因为后面手势触发的时候要用改控制器Pop回去@property (nonatomic,strong) UIViewController *pushingViewController;@end@implementation SwipInteractiveTransition- (void)addGestureInViewController:(UIViewController *)controller &#123; self.pushingViewController = controller; [self prepareGesture];&#125;- (void)prepareGesture &#123; UIScreenEdgePanGestureRecognizer *gesture = [[UIScreenEdgePanGestureRecognizer alloc]initWithTarget:self action:@selector(handleGesture:)]; //设置手势方向 gesture.edges = UIRectEdgeLeft; //添加手势到控制器的View [self.pushingViewController.view addGestureRecognizer:gesture];&#125;- (void)handleGesture:(UIPanGestureRecognizer *)gesture &#123; //获取手势在View中当前的位置 CGPoint traslation = [gesture translationInView:self.pushingViewController.view]; //计算进度，这里按照当前控制器的宽来计算。 CGFloat progress = traslation.x / CGRectGetWidth(self.pushingViewController.view.bounds); //手势开始 if (gesture.state == UIGestureRecognizerStateBegan) &#123; //设置该属性，标记转场正在进行 self.interacting = YES; //Pop当前控制器 [self.pushingViewController.navigationController popViewControllerAnimated:YES]; //手势状态变化 &#125; else if (gesture.state == UIGestureRecognizerStateChanged) &#123; //更新手势控制器进度 [self updateInteractiveTransition:progress]; //手势结束或者取消的时候 &#125; else if (gesture.state == UIGestureRecognizerStateEnded || gesture.state == UIGestureRecognizerStateCancelled) &#123; //标记转场结束 self.interacting = NO; //如果进去大于50%就完成转场，否则取消转场 if (progress &gt; 0.5) &#123; [self finishInteractiveTransition]; &#125; else &#123; [self cancelInteractiveTransition]; &#125; &#125; else &#123; //对其他情况的处理 self.interacting = NO; [self cancelInteractiveTransition]; &#125;&#125;@end 做到这一步的时候手势控制器也完成了，那么如何把手势控制器添加到 Controller 并生效使用手势来进行转场？继续往下看。😄 这里回到 RootDetailViewController 这个类，遵守 &lt;UINavigationControllerDelegate&gt; 代理，实现该代理中的另一个方法即可。其实这里添加在那个控制器都可以的，但是这里还是添加到 RootDetailViewController 吧。 12345678910111213141516171819202122232425262728293031323334353637383940414243// RootDetailViewController.m#import &quot;RootDetailViewController.h&quot;#import &quot;PopAnimation.h&quot;#import &quot;SwipInteractiveTransition.h&quot;#import &quot;PushAnimation.h&quot;@interface RootDetailViewController () &lt;UINavigationControllerDelegate&gt;@property (nonatomic,strong) UIPercentDrivenInteractiveTransition *interactiveControler;@property (nonatomic,strong) SwipInteractiveTransition *swipInteractiveController;@property (nonatomic,strong) PopAnimation *popAnimation;@property (nonatomic,strong) PushAnimation *pushAnimation;@end@implementation RootDetailViewController- (void)viewDidLoad &#123; [super viewDidLoad]; _headerImageView.image = _image; _textView.text = _text; self.popAnimation = [PopAnimation new]; self.pushAnimation = [PushAnimation new]; self.swipInteractiveController = [SwipInteractiveTransition new]; [self.swipInteractiveController addGestureInViewController:self]; self.navigationController.delegate = self;&#125;- (id&lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController animationControllerForOperation:(UINavigationControllerOperation)operation fromViewController:(UIViewController *)fromVC toViewController:(UIViewController *)toVC &#123; if (operation == UINavigationControllerOperationPop) &#123; return _popAnimation; &#125; else if (operation == UINavigationControllerOperationPush) &#123; return _pushAnimation; &#125; return nil;&#125;//在该方法中返回手势控制器即可- (id&lt;UIViewControllerInteractiveTransitioning&gt;)navigationController:(UINavigationController *)navigationController interactionControllerForAnimationController:(id&lt;UIViewControllerAnimatedTransitioning&gt;)animationController &#123; return self.swipInteractiveController.interacting ? self.swipInteractiveController : nil;&#125;@end 完成后的效果如下： 这里可能手势取消后到动画有点问题（如果谁知道原因可以告诉我一下，谢谢😁），模拟器上动画表现的不是很好，后面我会把代码上传到Github，可以下载源码在真机上测试。 Modal转场普通的 Modal 转场就不详细的解释Demo，因为其实和 Push／Pop 转场是差不多的，只是转场代理不一样。 Modal 转场遵守 &lt;UIViewControllerTransitioningDelegate&gt; 协议，协议中的方法如下： 1234567891011//提供 Present 时的动画控制器- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source;//提供 Dismiss 时的动画控制器- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed;//提供 Present 时的交互控制器- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForPresentation:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator;//提供 Dismiss 时的交互控制器- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForDismissal:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator;//该方法是在 iOS8 之后提供的，其作用就是现在要讲的。- (nullable UIPresentationController *)presentationControllerForPresentedViewController:(UIViewController *)presented presentingViewController:(nullable UIViewController *)presenting sourceViewController:(UIViewController *)source; 在 Modal 转场中除了平时默认的动画外其实系统也默认的提供了其他四种的转场动画，设置控制器的 modalTransitionStyle 属性就可以很方便的使用这四种默认的转场动画，分别如下： 1234UIModalTransitionStyleCoverVerticalUIModalTransitionStyleFlipHorizontal UIModalTransitionStyleCrossDissolveUIModalTransitionStylePartialCurl 但是很多时候还是并不能满足对转场动画的需求，所以这里就需要自定义转场动画了。 自定义转场动画需要在 ViewController 的 modalPresentationStyle 分别为 UIModalPresentationCustom 和 UIModalPresentationFullScreen 的时候才可以自定义转场动画，同时 ViewController 指定的 modalTransitionStyle 转场动画将会被忽略。 UIModalPresentationCustom 和 UIModalPresentationFullScreen 之间也是有差别的，这点需要特别的注意，不然很有可能在后面的自定义转场动画中踩坑。 UIModalPresentationFullScreen 模式：presentation 后，presentingView 被主动移出视图结构，在 dismissal 中 presentingView 是 toView 的角色，其将会重新加入 containerView 中。 UIModalPresentationCustom 模式：转场时 containerView 并不担任 presentingView 的父视图，后者由 UIKit 另行管理。在 presentation 后，fromView(presentingView) 未被移出视图结构，在 dismissal 中，注意不要像其他转场中那样将 toView(presentingView) 加入 containerView 中，否则本来可见的 presentingView 将会被移除出自身所处的视图结构消失不见。这点在 Custom 模式下要特别注意。 在 iOS8 之后 Modal 转场代理中新增了上面的第4个方法，可以提供一个 UIPresentationController ，这个类为模态视图的转场提供了更好的解决方案，可以更加深入的自定义 PresentedViewController ，比如 PresentedView 的尺寸大小，背景等，这个其实也可以在不需要转场动画的情况下单独使用。其中还有最重要的一个功能，那就是对屏幕布局的管理，这里就不展开学习了，后面单独去学习关于这个的使用。 现在我要自定义一个像 iOS 10 中 Music App中，播放界面弹出的效果（其实 Demo 中的效果并不是很像，只能说差不多吧😅）。如图： 首先还是先提供一个 Modal 转场的动画控制器吧，关于动画控制器上面也详细说过了，就是一个遵守 &lt;UIViewControllerAnimatedTransitioning&gt; 协议的对象，这里就直接贴上代码了： 12345678910111213141516// PresentAnimation.h#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;typedef NS_ENUM(NSInteger,AnimationType) &#123; AnimationTypeOfPresent = 0, AnimationTypeOfPop&#125;;@interface PresentAnimation : NSObject &lt;UIViewControllerAnimatedTransitioning&gt;+ (instancetype)animationUseAnimationType:(AnimationType)type;- (instancetype)initWithAnimationType:(AnimationType)type;@end 在这个控制器里，我直接把两个动画写到了一起，type 的不同去获取 present 或者 dismiss 对应的动画。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// PresentAnimation.m#import &quot;PresentAnimation.h&quot;#import &quot;PresentedViewController.h&quot;@interface PresentAnimation ()@property (nonatomic,assign) AnimationType type;@end@implementation PresentAnimation+ (instancetype)animationUseAnimationType:(AnimationType)type &#123; return [[self alloc]initWithAnimationType:type];&#125;- (instancetype)initWithAnimationType:(AnimationType)type &#123; self = [super init]; if (self) &#123; _type = type; &#125; return self;&#125;- (NSTimeInterval)transitionDuration:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123; return 0.5;&#125;- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123; switch (self.type) &#123; case AnimationTypeOfPresent: [self doPresentAnimation:transitionContext]; break; case AnimationTypeOfPop: [self doDisMissAnimation:transitionContext]; break; default: break; &#125;&#125;- (void)doPresentAnimation:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123; UIViewController *toVC = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey]; toVC.view.transform = CGAffineTransformScale(CGAffineTransformIdentity, 0.01, 0.01); UIView *containerView = [transitionContext containerView]; [containerView addSubview:toVC.view]; [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^&#123; toVC.view.transform = CGAffineTransformIdentity; &#125; completion:^(BOOL finished) &#123; [transitionContext completeTransition:YES]; &#125;];&#125;- (void)doDisMissAnimation:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123; UIViewController *fromVC = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey]; UIView *toView = [transitionContext viewForKey:UITransitionContextToViewKey]; UIView *containerView = [transitionContext containerView]; [containerView insertSubview:toView belowSubview:fromVC.view]; [containerView addSubview:fromVC.view]; [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^&#123; fromVC.view.transform = CGAffineTransformScale(CGAffineTransformIdentity, 0.01, 0.01); &#125; completion:^(BOOL finished) &#123; [transitionContext completeTransition:![transitionContext transitionWasCancelled]]; &#125;];&#125;@end 动画控制器完成后这里回到 presentingViewController ，在这个 presentingViewController 中遵守转场协议，提供转场需要的动画控制器。在 Demo 中还是在 RootTableViewController 这个控制器中进行的模态转场的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// RootTableViewController.m#import &quot;RootTableViewController.h&quot;@interface RootTableViewController () &lt;UIViewControllerTransitioningDelegate&gt;......@end@implementation RootTableViewController- (void)viewDidLoad &#123; [super viewDidLoad]; ... ... self.pushAnimation = [PushAnimation new]; self.navigationController.delegate = self;&#125;#pragma mark - Table view data source......#pragma mark - Table view data delegate...//这里我时在一个 TableViewController 中演示各种转场动画的，所以在这里进行 present 操作- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123; [tableView deselectRowAtIndexPath:indexPath animated:YES]; //通过 MainStoryboard 初始化控制器 UIStoryboard *board = [UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:nil]; HalfPresentedViewController *presentVC = [board instantiateViewControllerWithIdentifier:@&quot;customOfPresentattionVC&quot;]; //将 presented 的模态转场设置为自定义 presentVC.modalPresentationStyle = UIModalPresentationCustom; //添加 UIViewControllerTransitioningDelegate 协议的代理 presentVC.transitioningDelegate = self; [self presentViewController:presentVC animated:YES completion:nil];&#125;...#pragma mark - UIViewControllerTransitioningDelegate//返回 Present 时的动画控制器- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source &#123; return [PresentAnimation animationUseAnimationType:AnimationTypeOfPresent];&#125;//返回 Dismiss 时的动画控制器- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed &#123; return [PresentAnimation animationUseAnimationType:AnimationTypeOfPop];&#125; 完成这步后 run 一下 Demo ，嗯没问题。这其实就是自定义了 Model的转场动画了。但是这时候 presented 还是一个全屏的方式呈现出来的。不过下面就开始自定义 preseted 这个视图了，自定义 preseted 就需要遵守上面提到的 &lt;UIViewControllerTransitioningDelegate&gt; 代理中的最后一个方法，为其提供一个 PresentationController 。 接下来开始自定义 PresentationController 。 1234567// CustomPresentationController.h#import &lt;UIKit/UIKit.h&gt;@interface CustomPresentationController : UIPresentationController@end 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// CustomPresentationController.m// Test//// Created by Aaron Zhang on 12/04/2017.// Copyright © 2017 张近坪. All rights reserved.//#import &quot;CustomPresentationController.h&quot;@interface CustomPresentationController ()//该视图时作为上面图中那个黑色半透明的背景的@property (nonatomic,strong) UIView *backView;@end@implementation CustomPresentationController- (void)presentationTransitionWillBegin &#123; self.backView = [[UIView alloc]init]; self.backView.frame = self.containerView.bounds; self.backView.backgroundColor = [UIColor blackColor]; self.backView.alpha = 0.0; //获取当前转场的容器视图并添加要转场视图到容器 [self.containerView insertSubview:self.backView atIndex:0]; [self.containerView addSubview:self.presentedView]; //在转场中做动画这里就用到了上面提到的 转场协调器，如果不通过转场协调器来做动画，可能转场的时候动画不同步 id &lt;UIViewControllerTransitionCoordinator&gt; transitionCoordinator = self.presentingViewController.transitionCoordinator; [transitionCoordinator animateAlongsideTransition:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; _Nonnull context) &#123; _backView.alpha = 0.5; self.presentingViewController.view.transform = CGAffineTransformScale(self.presentingViewController.view.transform, 0.98, 0.98); &#125; completion:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; _Nonnull context) &#123; &#125;]; &#125;//在 present 失败的时候移除背景半透明视图- (void)presentationTransitionDidEnd:(BOOL)completed &#123; if (!completed) &#123; [_backView removeFromSuperview]; &#125;&#125;- (void)dismissalTransitionWillBegin &#123; id &lt;UIViewControllerTransitionCoordinator&gt; transitionCoordinator = self.presentingViewController.transitionCoordinator; [transitionCoordinator animateAlongsideTransition:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; _Nonnull context) &#123; _backView.alpha = 0.0; self.presentingViewController.view.transform = CGAffineTransformIdentity; &#125; completion:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; _Nonnull context) &#123; &#125;];&#125;////在 present 结束的时候移除背景半透明视图- (void)dismissalTransitionDidEnd:(BOOL)completed &#123; if (completed) &#123; [_backView removeFromSuperview]; &#125;&#125;//该方法返回 PresentedView 在容器中的frame ，就是在这里修改 presentedView 视图大小的。- (CGRect)frameOfPresentedViewInContainerView &#123; return CGRectMake(10, self.containerView.bounds.size.height / 2, self.containerView.bounds.size.width - 20, self.containerView.bounds.size.height / 2 - 10);&#125;//容器视图重新布局子视图，在我的这个Demo中必须做这一步的操作，否则上面方法返回的 presentedView 的 frame 不会生效，目前我也不是特别清楚原因。- (void)containerViewWillLayoutSubviews &#123; self.backView.frame = self.containerView.bounds; self.presentedView.frame = [self frameOfPresentedViewInContainerView];&#125;//返回 presentedView 视图。- (UIView *)presentedView &#123; UIView *presentedView = self.presentedViewController.view; presentedView.layer.cornerRadius = 8; return presentedView;&#125;@end PresentationController 就完成了，在这中主要重写了在 PresentationController 不同状态下的方法，来自定义 PresentationController 的呈现。接下来只需要回到刚刚的 presentedViewController 中，在这个类 RootTableViewController 中通过 &lt;UIViewControllerTransitioningDelegate&gt; 返回自定义的 PresentationViewController 就好了，如下： 123456789101112131415161718192021222324252627282930313233343536// RootTableViewController.m#import &quot;RootTableViewController.h&quot;@interface RootTableViewController () &lt;UIViewControllerTransitioningDelegate&gt;......@end@implementation RootTableViewController- (void)viewDidLoad &#123; [super viewDidLoad]; ... ... self.pushAnimation = [PushAnimation new]; self.navigationController.delegate = self;&#125;#pragma mark - Table view data source......#pragma mark - Table view data delegate......#pragma mark - UIViewControllerTransitioningDelegate......//提供自定义的 UIPresentationController- (UIPresentationController *)presentationControllerForPresentedViewController:(UIViewController *)presented presentingViewController:(UIViewController *)presenting sourceViewController:(UIViewController *)source &#123; CustomPresentationController *myPresentationController = [[CustomPresentationController alloc]initWithPresentedViewController:presented presentingViewController:presenting]; return myPresentationController;&#125; 完成后最终的效果如下： Demo 参考资料： View Controller Programming Guide for iOS Presentation Controllers, Adaptivity, and Custom Animator Objects","categories":[],"tags":[{"name":"转场动画","slug":"转场动画","permalink":"Aaronzjp.cn/tags/转场动画/"}]},{"title":"Swift-构造过程","slug":"Swift-Initializer","date":"2017-03-27T14:06:28.000Z","updated":"2017-07-31T19:35:42.000Z","comments":true,"path":"2017/03/27/Swift-Initializer/","link":"","permalink":"Aaronzjp.cn/2017/03/27/Swift-Initializer/","excerpt":"Swift 构造过程是在使用类、结构体或者枚举类型的实例之前所做的准备工作。在使用类型实例之前为了确保类型实例能够正确的实例化，需要在实例化过程中对存储属性等设置初始值，和一些必须执行和初始化的工作。","text":"Swift 构造过程是在使用类、结构体或者枚举类型的实例之前所做的准备工作。在使用类型实例之前为了确保类型实例能够正确的实例化，需要在实例化过程中对存储属性等设置初始值，和一些必须执行和初始化的工作。 构造器构造器是在创建一个类型的实例等时候被调用的方法，构造器的声明是以 init 关键字声明的。如下就是创建了 Person 类的构造器。 123456class Person &#123; var name: String init(name: String) &#123; self.name = name &#125;&#125; 在构造器方法中，将参数 name 的值设置为 name 属性的值，作为初始值。 默认属性值要知道在 Swift 中类和结构体在创建实例的时候，所有的存储属性都必须要有合适的初始值，存储属性的值不能是出于一个未赋值的未知状态，这样才能正确的使用类型的实例。除了像上面那样在构造器中位存储属性设置初始值外，可以在属性声明时为其设置默认值。如下，为 Person 类设置一个默认值。 123456class Person &#123; var name: String = \"Aaron\"&#125;let person = Person()print(person.name)//输出 Aaron 当然属性默认值也可以设置为可选类型。 自定义构造过程当然也可以自定义构造器的构造过程来确保类型在创建类型实例的时候可以被正确的初始化。 构造参数自定义构造器构造过程的时候可以在定义中提供构造参数，指定参数的名称，类型等。自定义构造器的语法和函数和方法类似。其实在上面的 Person 类中就使用了自定义的构造过程。如下: 123456class Person &#123; var name: String init(name: String) &#123; self.name = name &#125;&#125; 该构造器有一个 name 参数，该参数是 String 类型，在构造器内部，将构造器的参数 name 赋值给了 Person 类的 name 属性。 外部参数名称和内部参数名称构造器和方法、函数一样，参数也有外部参数名称和内部参数名称。但是和方法和函数不一样的是，如果在定义构造器的时候没有为其定义参数外部名称，那么构造器将会自动的为构造器生成跟内部参数名称一样的外部参数名称。 123456789class Person &#123; var name: String init(name: String) &#123; self.name = name &#125; init(nickName name: String) &#123; self.name = name &#125;&#125; 这里展示了两种构造器，第一个是没有明确添加外部参数名的构造器，第二个则是添加了 nickName 作为 name 参数的外部名称的构造器。这两种构造器方法都可以创建一个 Person 实例。 当然也可以不使用外部名称，使用下划线(_)来显示的说明忽略掉外部参数名称。 123456789101112class Person &#123; var name: String init(name: String) &#123; self.name = name &#125; init(_ name: String) &#123; self.name = name &#125;&#125;let person = Person(name: \"Aaron\")let person2 = Person(\"Aaron\") 可选属性如果一个类型在初始化实例的时候某个属性并不需要初始值怎么办呢？上面也说了属性不能处于未知状态。那么可以定义一个可选类型的属性，可选类型的属性如果在构造器中未赋值的时候将会自动初始化为 nil 。这样就可以表示这个属性初始化后是没有值的。 1234567class Person &#123; var name: String var age: Int? init(name: String) &#123; self.name = name &#125;&#125; 上面这段代码在创建一个 Person 实例后，Person 的 age 属性就是 nil 构造过程中常量属性的修改在构造过程中同样也可以对常量的属性进行赋值，但是一旦类型的实例被创建后该实例的常量属性就无法被修改。在类中常量属性只能在定义该类的构造器中修改常量属性，在子类的构造器中是无法对常量属性进行修改的。 默认构造器在 Swift 中如果结构体和类中所有的属性都有默认值，同时没有自定义的构造器的时候 Swift 则会提供一个默认的构造器，通过该构造器会创建一个所有属性都是默认值的实例。 123456class Person &#123; var name: String? var age: Int?&#125;let person = Person() 通过该构造器创建出来的 Person 类的实例其所有的属性都将是 nil 结构体的逐一成员构造器除了默认的构造器以外，在结构体中如果没有提供自定义的构造器，那么将会有一个自动根据结构体中的属性生成的一个构造器，该构造器的参数将是结构体中所有属性，参数名则是所有属性名。如下： 123456struct Point &#123; var x: Float var y: Float&#125;let point = Point(x: 100, y: 100) 值类型的构造器代理构造器可以通过调用其他构造器来完成实例的部分构造过程，这样的过程就是构造器代理，构造器代理可以减少多个构造器之间的重复。值类型和类类型的构造器代理规则是有区别的，值类型是不支持继承的，所以值类型的构造器代理职能使用自己的其他构造器，而类则是可以继承自其他类的。 在值类型中可以使用 self.init 在自定义的构造器中使用本类型中其他的的构造器，且只能够在构造器内部调用 self.init 。当为值类型自定义了构造器时，将无法使用默认构造器、逐一成员构造器。如果需要自定义构造器，默认构造器和逐一成员构造器都可以访问，则需要将自定义构造器写到扩展中。 123456789101112131415161718192021struct Size &#123; var width = 0.0, height = 0.0&#125;struct Point &#123; var x = 0.0, y = 0.0&#125;struct Rect &#123; var origin = Point() var size = Size() init() &#123;&#125; init(origin: Point, size: Size) &#123; self.origin = origin self.size = size &#125; init(center: Point, size: Size) &#123; let originX = center.x - (size.width / 2) let originY = center.y - (size.height / 2) self.init(origin: Point(x: originX, y: originY), size: size) &#125;&#125; 在该例子中 Rect 定义了三个构造器，其中第一个构造器是一个空函数，这和没有自定义构造器的时自动获得的默认构造器是一样的。第二个构造器有两个参数，构造器内部在构造过程中将这两个参数分别赋值给了 origin 和 size 属性。第三个构造器也是有两个参数，不同的是在构造器内部的构造过程中，将获取到的参数经过计算后，再调用第二个构造器将计算得到的 origin 和 size 赋值到对应的属性。像第三个构造器这样在构造器内部的构造过程中调用其他的构造器就是构造器代理。 类的继承和构造过程类是可以继承的，在类中所有的存储属性包括继承自父类的属性都必须在构造过程中设置初始值。在类类型中 Swift 为其提供了两种构造器，分别是指定构造器和便利构造器。 指定构造器和便利构造器指定构造器是类中最主要的构造器，一个指定的构造器初始化类中所有的属性，并根据父类链往上调用父类的构造器来实现父类的初始化。每一个类都必须有至少一个的指定构造器。便利构造器则是类中的辅助型的构造器，可以通过便利构造器调用类中的指定构造器，并为其参数提供默认值，也可以在便利构造器中创建一些特殊用途的实例。 指定构造器其实和构造器语法是一样的，使用 init 作为关键字可以加入参数。便利构造器需要在构造器 init 前加上 convenience 关键字。 类的构造器代理规则Swift 中有三条规则来限制构造器之间的代理调用： 指定构造器必须调用其直接父类的的指定构造器。 便利构造器必须调用同类中定义的其它构造器。 便利构造器必须最终导致一个指定构造器被调用。 指定构造器是向上代理，便利构造器是横向代理。 构造器的继承和重写Swift 中默认情况下子类是不会继承父类的构造器的。但是如果满足以下任意一个条件子类是可以继承父类的构造器的。 1.子类没有定义任何的指定构造器，这时候子类会自动的继承父类所有的指定构造器 2.如果子类提供了所有的父类指定的构造器的实现，不管是继承还是自己提供实现。子类都会自动继承父类所有的便利构造器。 可失败构造器在很多时候在构造器传入的参数可能并不能如预期的完成初始化，这样构造过程就会失败，在 swift 中可以使用可失败构造器来处理这样的情况。可失败构造器可以在类，结构体，或者是枚举中添加一个或多个可失败构造器。可失败构造器的语法为在 init 后添加一个问号：（init?） 如下： 123456789101112class Person &#123; var name: String? init?(name: String) &#123; if name.isEmpty &#123; return nil &#125; self.name = name &#125; var apartment: Apartment?&#125;let aaron = Person(name: \"Aaron\") 在上面这段代码中构造一个 Person 实例，当传入的参数为空字符串的时候则会返回 nil。 需要注意的是。可失败构造器的参数名和参数类型，不能与其它非可失败构造器的参数名，及其参数类型相同。 枚举类型的可失败构造器同样的在枚举中也可以使用可失败构造器，当实例化一个对象的时候，参数无法匹配任何的枚举值的时候则构造失败，返回 nil 1234567891011121314151617enum Food &#123; case Beef,Noodles,Fish init?(name: String) &#123; switch name &#123; case \"Beef\": self = .Beef case \"Noodles\": self = .Noodles case \"Fish\": self = .Fish default: return nil &#125; &#125;&#125;let myFavriteFood = Food(name: \"Fish\") 同样的如同上面情况的构造器一样，如果在枚举构造器中找不到与之匹配的参数则会返回nil。同时，枚举的可失败构造器也可以通过带有原始值的方式来完成，这样写更加的简短。 123enum Food &#123; case Beef = “Beef”,Noodles = “Noodles”,Fish = \"Fish\"&#125; 构造失败的传递和普通构造器一样可失败构造器也可以横向代理到同类型的其他构造器中，同时子类的可失败构造器也可以向上代理到父类的可失败构造器，同时可失败构造器也可以代理到其他非可失败构造器中。无论是向上代理还是横向代理，如果你代理到的其他可失败构造器触发构造失败，整个构造过程将立即终止，接下来的任何构造代码不会再被执行。 可失败构造器的重写和其他普通构造器一样，可失败构造器是可以在子类中重写父类的可失败构造器的，也可以用子类的非可失败构造器重写父类的可失败构造器，但是不能反过来用可失败构造器重写非可失败构造器。 可失败构造器init!通常来说我们通过在init关键字后添加问号的方式（init?）来定义一个可失败构造器，但你也可以通过在init后面添加惊叹号的方式来定义一个可失败构造器（init!），该可失败构造器将会构建一个对应类型的隐式解包可选类型的对象。 你可以在init?中代理到init!，反之亦然。你也可以用init?重写init!，反之亦然。你还可以用init代理到init!，不过，一旦init!构造失败，则会触发一个断言。 必要构造器必要构造器是通过在构造器前添加 requred 关键字表示所有该类的子类都应该必须实现该构造器。 12345class SomeClass &#123; required init() &#123; // 构造器的实现代码 &#125;&#125; 在子类重写父类的必要构造器时，必须在子类的构造器前也添加required修饰符，表明该构造器要求也应用于继承链后面的子类。在重写父类中必要的指定构造器时，不需要添加override修饰符： 12345class SomeSubclass: SomeClass &#123; required init() &#123; // 构造器的实现代码 &#125;&#125; 注意如果子类继承的构造器能满足必要构造器的要求，则无须在子类中显式提供必要构造器的实现。","categories":[],"tags":[{"name":"Swift","slug":"Swift","permalink":"Aaronzjp.cn/tags/Swift/"}]},{"title":"Swift-方法","slug":"Swift-Method","date":"2017-03-22T04:57:57.000Z","updated":"2017-07-27T02:53:02.000Z","comments":true,"path":"2017/03/22/Swift-Method/","link":"","permalink":"Aaronzjp.cn/2017/03/22/Swift-Method/","excerpt":"在 Swift 中方法分为两种，实例方法、类型方法。其中类型方法和 Obj-c 中的类方法相似的，类型方法是作用于类型本身的，实例方法则是作用于类型对应的实例。和 Obj-c 不同的是，在 Swift 中不仅可以给类定义方法，同时还可以给结构体和枚举定义方法。","text":"在 Swift 中方法分为两种，实例方法、类型方法。其中类型方法和 Obj-c 中的类方法相似的，类型方法是作用于类型本身的，实例方法则是作用于类型对应的实例。和 Obj-c 不同的是，在 Swift 中不仅可以给类定义方法，同时还可以给结构体和枚举定义方法。 实例方法实例方法是属于类、结构体或者枚举类型实例的方法。实例方法的语法和函数是一致的（其实就是函数吧，只是是和某个特定类型相关联的函数），实例方法是提供修改和访问实例属性的方法，实现和实例目的相关的功能。 123456789101112class Dog &#123; var name: String? func giveDog(name: String) &#123; self.name = name &#125; func changeDog(name: String) &#123; self.name = name &#125; func deleteDogName() &#123; self.name = nil &#125;&#125; Dog 类定义了三个实例方法，方法的调用和属性是一样的使用点语法: 1234567let dog = Dog()dog.giveDog(name: \"DouDou\")//dog 的名字是 DouDoudog.changeDog(name: \"SB\")//dog 的名字是 SBdog.deleteDogName()//dog 的名字是一个 nil 的可选值 方法和函数一样也可以指定参数外部名称和内部名称。 实例方法中修改值类型属性swift 中枚举和结构体属于值类型，默认情况下值类型的属性是不能在实例方法中就行修改的，如果需要在值类型中修改属性就需要使用可变方法。可变方法使用关键字 mutating 修饰，放在方法声明的最前面，在可变方法中还可以对 self 进行赋值，方法结束后被赋值的 self 的实例会被新的值所取代。在常量值类型实例中是不可以调用可变方法的，因为值类型的实例一旦声明成为常量那么他的属性也全部变为常量。 123456struct Point &#123; var x = 0.0, y = 0.0 mutating func moveTo(x:Double, y:Double) &#123; self = Point(x: x, y: y) &#125;&#125; 同样的也可以应用在枚举中 12345678910111213enum TriStateSwitch &#123; case Off, Low, High mutating func next() &#123; switch self &#123; case Off: self = Low case Low: self = High case High: self = Off &#125; &#125;&#125; 类型方法实例方法是被类型的特定实例调用，那么类型方法就是被类型调用的。在类中声明类型方法使用 class 关键字，放在 func 的前面，在结构体和枚举中声明类型方法使用 static 关键字，也是放在 func 前面。 1234567891011class Person &#123; var name: String? class func newPerson(name: String) -&gt; Person &#123; return Person(name: name) &#125; init(name: String) &#123; self.name = name &#125;&#125;let person = Person.newPerson(name: \"Aaron\") 在 Person 中声明了一个类方法，调用该类方法会返回一个 person 实例。在类型方法中可以直接访问类型属性或者调用类型方法，而不需要加上类型名称。","categories":[],"tags":[{"name":"Swift","slug":"Swift","permalink":"Aaronzjp.cn/tags/Swift/"}]},{"title":"iOS动画","slug":"Animation","date":"2017-03-07T06:44:31.000Z","updated":"2017-07-26T05:46:24.000Z","comments":true,"path":"2017/03/07/Animation/","link":"","permalink":"Aaronzjp.cn/2017/03/07/Animation/","excerpt":"​ 在iOS／MacOS中，基本上所有的动画都是由 Core Animation 这个框架来完成的。这个框架的主要功能就是渲染图形，以及动画的实现，使用 Core Animation 来实现图形渲染以及动画只需要配置一些简单的参数，告诉它动画应该什么时候开始，什么时候结束，以及状态等。 Core Animation 通过硬件加速自动的完成图形的绘制，渲染以及动画。","text":"​ 在iOS／MacOS中，基本上所有的动画都是由 Core Animation 这个框架来完成的。这个框架的主要功能就是渲染图形，以及动画的实现，使用 Core Animation 来实现图形渲染以及动画只需要配置一些简单的参数，告诉它动画应该什么时候开始，什么时候结束，以及状态等。 Core Animation 通过硬件加速自动的完成图形的绘制，渲染以及动画。 ​ 首先看一下 Core Animation 中主要的几个类的继承机构，如下图： 隐式动画之所以叫隐式动画我觉得应该是我们在处理隐式动画的时候不需要去处理动画相关的东西，不需要去设置动画的时间，动画的轨迹，而只需要改变一个属性就可以做出一个动画，这些动画其实都是由 Core Animation 来完成的。Core Animation 包含了一系列的属性动画的集合机制。隐式动画只作用于 RootLayer 以外的 Layer 。 事务隐式动画其实是通过事务来管理的，事务实际上是 Core Animation 用来包含管理属性动画的集合机制，任何通过事务去改变的动画属性都不会立刻的发生变化，而是当事务提交的时候才开始从原来的值过渡到一个新的值。事务是通过 CATransaction 类来管理的，该类和其他普通的类不一样，没有属性和实例方法，也没有 + alloc; ， - init; 等方法。而是通过 + begin; ， + commit; 来入栈和出栈。所有可以做动画的属性都可以添加到栈顶顶事务，然后提交事务。隐式动画中动画默认的时间为0.25秒，但是我们也可以通过 - setAnimationDuration; 来设置时间，或者通过 + animationDuration; 来获取当前的时间。图层作出的所有的改变都是事务的一部分，都是经由事务把图层的改变更新到图层的。事务又可以分为隐式事务和显式事务。 隐式事务当修改图层没有在显示的获取事务进行更改的时候都会自动的创建隐式事务，当线程中的 run-loop 执行下一次迭代的时候就会自动的收集事务并提交事务。 1layer.position = CGPointMake(0.0,1.0); 上面的这段代码会被事务收集并提交，生成动画效果。 显式事务显示事务就需要在修改 layer 前开始一个新的事务，然后在修改 layer 后提交事务。 1234567891011121314151617//开始一个新事务，如果不开启新的事务，直接在当前事务中做修改可能会造成一些副作用[CATransaction begin];// [CATransaction setDisableActions:YES];//设置事务时间[CATransaction setAnimationDuration:3.0];//设置完成事务[CATransaction setCompletionBlock:^&#123; CGAffineTransform transform = self.layer.affineTransform; transform = CGAffineTransformRotate(transform, M_PI_4); self.layer.affineTransform = transform;&#125;];CGFloat red = arc4random() / (CGFloat)INT_MAX;CGFloat green = arc4random() / (CGFloat)INT_MAX;CGFloat blue = arc4random() / (CGFloat)INT_MAX;self.layer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;//提交事务[CATransaction commit]; 这种设置动画的方式是不是觉得好像在那见过？对，在 UIView 中也有这样类似的动画的实现方式。在 UIView中设置一个动画如下： 12345678CGPoint piont = [[touches anyObject]locationInView:self.view];[UIView beginAnimations:nil context:nil];[UIView setAnimationDuration:2.0];self.layerView.backgroundColor = [UIColor orangeColor];self.layerView.center = piont;[UIView commitAnimations]; 实际上通过 UIView 这种方式实现的动画都是通过设置 CATransaction 来完成的，但是 UIView 相对于 CATransaction 来说要更加丰富一些，可以设置 delay、repeatCount等等。 在 iOS 4.0 点时苹果为 UIView 添加了基于 Block 添加点动画点方式： + (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion； 在 Block 动画方式中可以设置 completion 以在动画完成的时候做一些其他操作，这种方式在 CATransaction 中也有对应的方法 ：+ (void)setCompletionBlock:(nullable void (^)(void))block; 在 CATransaction 中使用动画完成块： 1234567891011121314151617//开始一个新事务[CATransaction begin];// [CATransaction setDisableActions:YES];//设置事务时间[CATransaction setAnimationDuration:3.0];//设置完成事务[CATransaction setCompletionBlock:^&#123; CGAffineTransform transform = self.layer.affineTransform; transform = CGAffineTransformRotate(transform, M_PI_4); self.layer.affineTransform = transform;&#125;];CGFloat red = arc4random() / (CGFloat)INT_MAX;CGFloat green = arc4random() / (CGFloat)INT_MAX;CGFloat blue = arc4random() / (CGFloat)INT_MAX;self.layer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;//提交事务[CATransaction commit]; 以上代码会在动画完成的时候旋转90度，在图层旋转的时候要比颜色渐变快很多，这是因为旋转是在事务提交后才被执行的，是使用默认的事务做的旋转，所以时间就变成了默认的0.25秒。 隐式动画的实现在最上面就讲到了隐式动画只作用于非 RootLayer 的图层，这是因为在 UIView 中苹果禁用了 RootLayer 的这个特性。为了搞清楚 UIView 是如何禁用 CALayer 的隐式动画的就需要了解隐式动画的实现。 隐式动画实现方式可以分为如下的几步： 当 CALayer 的属性改变的时候，就会调用 - actionForKey(NSSrting *):event; 方法传递属性的名称。 如果图层否有委托，并且是否实现 CALayerDelegate 协议指定的 - actionForLayer:forKey 方法。如果有，直接调用并返回结果。 如果没有委托，或者委托没有实现 -actionForLayer:forKey 方法，图层接着检查包含属性名称对应行为映射的 actions 字典。 如果 actions 字典没有包含对应的属性，那么图层接着在它的 style 字典接着搜索属性名。 最后，如果在 style 里面也找不到对应的行为，那么图层将会直接调用定义了每个属性的标准行为的 - defaultActionForKey: 方法。 所以当一轮搜索过后，要么 - actionForLayer:forkey; 返回 nil ，要么就是 CAAction 协议对应的对象，最后 CALayer 就会获取这个结果对之前和现在的值做动画。 那么 UIView 是如何禁用隐式动画的呢？ 每个 UIView 对其关联的 RootLayer 都是一个委托，并且实现了 - actionForLayer:forKey; 方法，当不再一个动画块的实现的时候，UIView 对所有的图层的动画行为都返回 nil ，但是在动画范围内的就返回一个非空的值。当然还有一种方式可以直接禁用隐式动画，就是在入栈的时候调用 - setDisableActions; 方法。 123[CATransaction begin];[CATransaction setDisableActions:YES];[CATrasnaction commit]; 呈现与模型前面也提到了，当更改一个图层的属性的时候，事务被提交，图层在屏幕上就会从之前的值过渡到更改的新值，而不是立即就会生效的。当图层的属性值更新后，并不会马上的在屏幕上显示出来，而是从之前的值慢慢过渡过来的，我们更改的图层属性的值其实是在过渡完成后将要显示在屏幕上的值。 在iOS中，屏幕每秒钟重绘60次。如果动画时长比60分之一秒要长，Core Animation就需要在设置一次新值和新值生效之间，对屏幕上的图层进行重新组织。这意味着 CALayer 除了“真实”值（就是你设置的值）之外，必须要知道当前显示在屏幕上的属性值的记录。每个图层属性的显示值都被存储在一个叫呈现图层的独立图层中，该图层可以通过 presentationLayer; 方法获取，这个呈现图层其实是模型图层的复制，呈现图层的值就是当前屏幕正在显示的值。除了呈现层，模型层以外其实还有一个渲染层，但是渲染层是私有的所以这里不做了解。 什么时候会用到呈现层？ 当我们需要实现一个基于定时器的动画的时候，需要知道在某个时间图层显示的位置时，或者在动画正在进行的时候也允许动画与用户交互的时候，这个时候呈现层就起了很大的作用，我们通过呈现层可以知道目前图层在屏幕上处于什么位置，以及当前屏幕上图层的状态。 如下Demo： 1234567891011121314151617181920- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; CGPoint point = [[touches anyObject] locationInView:self.view]; if ([self.layer.presentationLayer hitTest:point]) &#123; CGFloat red = arc4random() / (CGFloat)INT_MAX; CGFloat green = arc4random() / (CGFloat)INT_MAX; CGFloat blue = arc4random() / (CGFloat)INT_MAX; [CATransaction begin]; [CATransaction setAnimationDuration:1]; self.layer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1].CGColor; [CATransaction commit]; &#125;else&#123; [CATransaction begin]; [CATransaction setAnimationDuration:4]; self.layer.position = point; [CATransaction commit]; &#125;&#125; 显式动画​ 显示动画就是需要显示去设置动画时间动画轨迹，以及一些其他动画的特性。它能够对一些属性做指定的自定义动画，或者创建非线性动画，比如沿着任意一条曲线移动。 CAAnimation​ CAAnimation 作为动画的根类，是不可以直接使用的，应该使用他的子类。但是 CAAnimation中还是有一些经常使用到的一些属性，和方法，这里列举一下。 属性： delgate:为 CAAnimation 设置代理，默认的为ni，该代理下有两个代理回调方法。 removedOnCompletion:动画完成后是否移除动画效果，默认为 YES ，当动画结束的时候则会立即恢复到动画前的状态。如果想让动画在完成后保持动画执行完的状态，需要设置该属性为 NO ，同时还要设置 fillMode 为kCAFillModeForwards。 timingFuncation:速度控制，控制动画的节奏。该属性是一个 NSString 类型，可以接受如下几种常量： 12345678910//匀速kCAMediaTimingFunctionLinear//慢进快出kCAMediaTimingFunctionEaseIn//快进慢出kCAMediaTimingFunctionEaseOut//慢进慢出中间加速kCAMediaTimingFunctionEaseInEaseOut//默认形式kCAMediaTimingFunctionDefault 方法： + animation; 返回一个 CAAnimation 实例对象。 + defualtValueForKey:(NSString *)key; 根据属性 Key 返回相对应的值，用于当使用的键没有被设置值的时候，返回一个默认值。 - (BOOL)shouldArchiveValueForKey:(NSString *)key; 设置对应的键的属性是否可以被归档，默认为 YES 。 代理方法： - (void)animationDidStart:(CAAnimation *)theAnimation; 动画开始的回调。 - (void)animationDidStop:(CAAnimation *)theAnimation finished:(BOOL)flag; 动画停止时候回调，flag动画是否结束。 CAMediaTiming​ CAMediaTiming 作为一个协议类，CAAnimation 和 CALayer 都实现了该协议。该协议主要控制动画的时间，以及一些重复属性。该协议包含了一系列的属性，如下： beginTime：指动画开始前延迟的时间，这个开始时间是相对当前图层时间来说的，这个时间是从动画被添加那一刻开始的，默认为0。 timeOffset: 时间偏移量，这个属性有点不太好理解，首先把一个动画看成是一个循环，如果设置动画的时间为5s，timeOffset 默认为0的情况下没有任何的变化。如果把 timeOffset 设置为3，那么动画就会从第4秒的地方开始，执行到第3秒。 duration: 动画执行的时间，该属性还和 speed 属性有关系，如果一个 speed 为2， duration 为3的动画，那么这个动画的实际执行时间为 duration / speed ，speed 是可以叠加的，如果一个 layer 的 speed 为2，sublayer 的 speed 也为2， duration为3，那么这个 sublayer 的动画时间则为 3 / (2 * 2) 秒。 speed: 动画执行速度，和 duration 有一定的关系，具体的参见上一条 duration。 repeatCount: 动画重复次数 repeatDuration: 重复时间，这个重复时间是指让动画持续重复执行的时长 autoreverses: 动画翻转回放，默认为 NO ，如果设置为 YES ，那么动画结束时会以动画的方式回到初始状态。 fillMode: 填充模式，该属性时一个 NSString 的类型，可以接受如下四种常量： 12345678//动画结束后回到准备状态kCAFillModeForwards//动画结束后保持最后状态kCAFillModeBackwards//动画结束后回到准备状态,并保持最后状态kCAFillModeBoth//执行完成移除动画kCAFillModeRemoved 要注意的是如果 CA Animation 的 removedOnCompletion 属性设置为 NO 的时候，fillMode 是无效的。 属性动画(CAPropertyAnimation)​ 属性动画作用于图层的某个单一属性，并指定了它的一个目标值，或者一连串将要做动画的值。属性动画分为两种：基础和关键帧。 基础动画(CABasicAnimation)​ 在上面的显示动画中也提到了，动画其实就是图层/视图在一段时间内发生的改变，从一个值到另一个值之间的过渡，这也是 CABasicAnimation 最主要的功能。 CABasicAnimation 是 CAPropertyAnimation 的子类。 CAPropertyAnimation 通过指定一个图层的 keyPath 作用于这个属性，实际上这个 keyPath 并不是指单一的图层的属性，而是包含了它子成员的属性，或者是一些虚拟属性。 CABasicAnimation 继承于 CAPropertyAnimation，并且添加了如下三个属性： 123id fromValueid toValueid byValue 分别设置这三个属性说表达的效果： 同时设置 fromValue 和 toValue，会在这两个值之间做动画 同时设置 formValue 和 byValue，则会在 fromValue 和 fromValue + byValue 之间做动画 同时设置 byValue 和 toValue，会在 toValue - byValue 和 toValue 之间做动画 只设置 fromValue 则会在 fromValue 和当前图层的呈现层的目标值之间做动画 只设置 toValue 则会在当前图层呈现层的目标值和 toValue 之间做动画 只设置 byValue 则会在当前图层呈现层的目标值和 当前图层呈现层的目标值 + byValue 之间做动画 这三个属性都被指定成了 id 类型，之所以是 id 类型的是因为属性动画不是单一的作用在一个固定类型的属性，而是很多不同类型的属性上，包括数字类型，矢量，变换矩阵，甚至是颜色或者图片。还有一些非 NSObject 派生对象的属性，那么如果用这些属性来做动画就需要将数据转换包装一下。 但是需要注意的是不能同事设置这三个属性，因为可能会发生冲突。 如下通过 CABasicAnimation 显示动画来修改 CALayer 的背景色： 123456789CGFloat red = arc4random() / (CGFloat)INT_MAX;CGFloat green = arc4random() / (CGFloat)INT_MAX;CGFloat blue = arc4random() / (CGFloat)INT_MAX;UIColor *color = [UIColor colorWithRed:red green:green blue:blue alpha:1.0];CABasicAnimation *animation = [CABasicAnimation animation];animation.duration = 3.0;animation.keyPath = @&quot;backgroundColor&quot;;animation.toValue = (__bridge id) color.CGColor;[_layer addAnimation:animation forKey:@&quot;backgroundColor&quot;]; 当运行这段代码的时候会发现 layer 的背景色过渡到一个新的颜色后当动画结束的那一瞬间， layer 的背景色又立刻变回了最初始的值。这所以这样是因为 CABasicAnimation 动画并不会改变图层的模型层，而是改变的呈现层。一旦动画结束就会从图层上移除，图层恢复到初始的状态。因为我们也从来没有改变 backgroudColor 这个属性。利用这一点， CABasicAnimation 很合适用来做连续循环的动画。如下展示了一个心跳的简单动画。 123456789101112131415161718192021_layer = [CALayer layer];UIImage *image = [UIImage imageNamed:@&quot;heart.jpg&quot;];_layer.contents = (__bridge id )image.CGImage;self.layer.bounds = CGRectMake(0, 0, image.size.width / 10, image.size.height / 10);_layer.position = self.view.layer.position;[self.view.layer addSublayer:_layer];CABasicAnimation *animation = [CABasicAnimation animation];animation.keyPath = @&quot;bounds&quot;;animation.fromValue = [NSValue valueWithCGRect:_layer.bounds];animation.toValue = [NSValue valueWithCGRect:CGRectMake(0, 0, image.size.width / 2, image.size.height / 2)];//重复次数，HUGE 一个宏定义等同于MAXFLOATanimation.repeatCount = HUGE;//动画时长animation.duration = 1.0;//以动画的形式回到初始状态animation.autoreverses = YES;//计时方式animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];//添加动画到 layer[_layer addAnimation:animation forKey:@&quot;heartJump&quot;]; 关键帧动画(CAKeyframeAnimation)​ CAKeyframeAnimation 同样的也是 CAPropertyAnimation 的子类，同样的也是作用于一个单一的属性。但是和 CABasicAnimation 不同的是它不限制于在 fromValue 、 byValue 和 toValue 之间的值做动画，而是可以根据一连串随意的值来做动画。 ​ CAKeyframeAnimation 有一些关键的属性如下： values: 关键帧值数组，动画会根据该数组的内容数值作出动画变换。 path: 关键帧路径，动画根据该路径作出变化，优先权大于 values ，当同时设置 values 和 path 时，优先作用于 path 。 keyTimes: 每一帧所对应的时间，时间可以控制动画的速度，值从 0.0-1.0 ，默认为每一帧时间相等。 timingFunctions: 时间控制数组，即每一帧的动画速度控制，具体效果在 CAAnimation 中有描述。 calculationMode: 动画计算模式，该属性时一个 NSString 类型的，可接受如下几种常量： 1234567891011121314//关键帧为座标点的时候,关键帧之间直接直线相连进行插值计算kCAAnimationLinear//离散的,也就是没有补间动画kCAAnimationDiscrete//平均，keyTimes跟timeFunctions失效kCAAnimationPaced//对关键帧为座标点的关键帧进行圆滑曲线相连后插值计算,对于曲线的形状还可以通过tensionValues,continuityValues,biasValues来进行调整自定义,keyTimes跟timeFunctions失效kCAAnimationCubic//在kCAAnimationCubic的基础上使得动画运行变得均匀,就是系统时间内运动的距离相同,keyTimes跟timeFunctions失效kCAAnimationCubicPaced tensionValues: NSNumber 数组，定义曲线密度。 continuityValues: NSNumber 数组，定义曲线拐角的锐度 biasValues: 动画的偏斜率 rotationMode: 动画沿 path 移动时旋转的方式，默认为 nil 就是不做任何旋转。NSString 类型的属性，接受如下两种常量： 1234//根据path的切面自动旋转方向kCAAnimationRotateAuto//根据path的切面自动翻转kCAAnimationRotateAutoReverse 如下使用做一个动画让其根据设定的点移动。 123456789101112131415161718192021222324252627//首先添加一个 layer 到视图_maliaoLayer = [CALayer layer];_maliaoLayer.frame = CGRectMake(0, 0, 65, 75);_maliaoLayer.position = CGPointMake(33, CGRectGetHeight(self.view.bounds) - 38);_maliaoLayer.contents = (__bridge id) [UIImage imageNamed:@&quot;maliao.png&quot;].CGImage;[self.view.layer addSublayer:_maliaoLayer];//添加动画- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; //创建关键帧动画 CAKeyframeAnimation *animation = [CAKeyframeAnimation animation]; //针对position值做动画 animation.keyPath = @&quot;position&quot;; //动画时间 animation.duration = 3.0; animation.values = @[[NSValue valueWithCGPoint:CGPointMake(0, 667)], [NSValue valueWithCGPoint:CGPointMake(10, 550)], [NSValue valueWithCGPoint:CGPointMake(40, 400)], [NSValue valueWithCGPoint:CGPointMake(100, 300)], [NSValue valueWithCGPoint:CGPointMake(200, 600)], [NSValue valueWithCGPoint:CGPointMake(300, 250)], [NSValue valueWithCGPoint:CGPointMake(350, 0)]]; //动画方式 animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; //添加动画到图层 [_maliaoLayer addAnimation:animation forKey:nil];&#125; 效果如下： 当然上面的例子时通过 values 来做动画的，但是同样的效果也可以通过 path 来实现，只需要把 values 更改成 path，如下: 1234567_path = [[UIBezierPath alloc]init];[_path moveToPoint:CGPointMake(33, CGRectGetHeight(self.view.bounds))];[_path addCurveToPoint:CGPointMake(100, 10) controlPoint1:CGPointMake(100, 20) controlPoint2:CGPointMake(100, 50)];[_path addCurveToPoint:CGPointMake(200,20) controlPoint1:CGPointMake(100, 50) controlPoint2:CGPointMake(200, 50)];animation.path = _path.CGPath;[_maliaoLayer addAnimation:animation forKey:nil]; 弹性动画(CASpringAnimation)​ 弹性动画是在 iOS9 之后新加入的，主要可以通过这个类来做一些带有弹性的动画，该类继承自 CABasicAnimation ，除了 CABasicAnimation 的属性外，新增了如下属性： mass: 质量，影响图层运动时的弹簧惯性，质量越大，弹簧拉伸和压缩的幅度越大。 stiffness: 刚度系数，刚度系数越大，形变产生的力就越大，运动越快 damping: 阻尼系数，阻止弹簧伸缩的系数，阻尼系数越大，动画停止越快 initialVelocity: 初始速率，动画视图的初始速度大小速率为正数时，速度方向与运动方向一致，速率为负数时，速度方向与运动方向相反 settlingDuration: 结束时间，这是一个只读属性，返回动画结束的时间，该时间是根据当前动画的各个参数计算的。 下面通过一个 Demo 来感受下这个弹性动画😄 12345678910CASpringAnimation *animation = [CASpringAnimation animation];animation.keyPath = @&quot;position.x&quot;;animation.fromValue = (id)@(_imageView.layer.position.x);animation.toValue = (id)@(_imageView.layer.position.x + 100);animation.mass = 1;animation.stiffness = 100;animation.damping = 1;animation.initialVelocity = 0;animation.duration = animation.settlingDuration;[_imageView.layer addAnimation:animation forKey:nil]; 动画组(CAAnimationGroup)​ 动画组，顾名思义就是一组动画同时进行。CAAnimationGroup 继承于 CAAnimation ，有一个 Animations 的属性，就是把多个 Animation 或者其子类装入数组中添加到动画组中一起执行。用法如下： 1234567891011121314151617181920CASpringAnimation *animation = [CASpringAnimation animation];animation.keyPath = @&quot;position.x&quot;;animation.fromValue = (id)@(_imageView.layer.position.x);animation.toValue = (id)@(_imageView.layer.position.x + 100);animation.mass = 1;animation.stiffness = 100;animation.damping = 1;animation.initialVelocity = 0;animation.duration = animation.settlingDuration;CABasicAnimation *scalAnimation = [CABasicAnimation animation];scalAnimation.keyPath = @&quot;bounds.size&quot;;scalAnimation.fromValue = [NSValue valueWithCGSize:_imageView.layer.bounds.size];scalAnimation.toValue = [NSValue valueWithCGSize:CGSizeMake(_imageView.layer.bounds.size.width * 3, _imageView.layer.bounds.size.height *3)];scalAnimation.duration = 3;CAAnimationGroup *animationGroup = [CAAnimationGroup animation];animationGroup.animations = @[animation,scalAnimation];animationGroup.duration = 6;[_imageView.layer addAnimation:animationGroup forKey:nil]; 转场过渡动画(CATrsantion)​ CATrasition 继承自 CAAnimation ，CATrasntion 通过 type 属性提供了 4 种过渡动画，是一个 NSString 类型的属性，可以接受下面四种常量： 12345678//淡入淡出kCATransitionFade//移进kCATransitionMoveIn //推动进去kCATransitionPush //揭开kCATransitionReveal 其实除了上面这 4 种过渡动画还有一些私有的。这四种出了第一种是固定的以为，后面三种都是有一个方向的，方向的更改可以通过 subtype 属性来更改方向，该属性也是一个 NSString 类型的，有如下四种常量： 1234kCATransitionFromRight kCATransitionFromLeft kCATransitionFromTop kCATransitionFromBottom 平常基本上需要用到的动画都在这里了，基本上都可以通过这里讲到的动画方式来组合出来的。","categories":[],"tags":[{"name":"动画","slug":"动画","permalink":"Aaronzjp.cn/tags/动画/"},{"name":"Animation","slug":"Animation","permalink":"Aaronzjp.cn/tags/Animation/"}]},{"title":"Swift-集合类型","slug":"Swift-CollectionTypes","date":"2017-03-05T07:10:35.000Z","updated":"2017-08-01T07:55:09.000Z","comments":true,"path":"2017/03/05/Swift-CollectionTypes/","link":"","permalink":"Aaronzjp.cn/2017/03/05/Swift-CollectionTypes/","excerpt":"集合类型在 Swift 中集合类型主要有 Array、Sets、Dictionaries。和 O-bjc 中不同的是 Swift 中集合的可变类型和不可变类型并不是子类和父类的关系，而是同一个类。可变和不可变是通过变量类型来区分的，如果使用 var 来声明成变量那么就是可变的，如果使用 let 来声明成常量那么就是不可变的。","text":"集合类型在 Swift 中集合类型主要有 Array、Sets、Dictionaries。和 O-bjc 中不同的是 Swift 中集合的可变类型和不可变类型并不是子类和父类的关系，而是同一个类。可变和不可变是通过变量类型来区分的，如果使用 var 来声明成变量那么就是可变的，如果使用 let 来声明成常量那么就是不可变的。 数组的简单使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//创建一个空的数组//可变var someInts = [Int]()//不可变let someDoubels = [Double]()//字面量创建数组let ints = [1,2,3,4,5]var shoppingList: [String] = [\"Eggs\",\"Milk\",\"Tomato\"]//创建带有默认值的数组var defualtArray = Array(repeating: 6, count: 3)//数组也可以使用 + 运算符来拼接let sumArray = ints + defualtArray//获取数组元素个数let arrayCount = sumArray.count//判断数组是否为空//通过 isEmpty 属性判断if sumArray.isEmpty &#123; print(\"sumArray is empty array\");&#125; else &#123; print(\"sumArray is not empty array\");&#125;//通过检查数组元素个数是否为0来判断数组是否为空if sumArray.count == 0 &#123; print(\"sumArray is empty array\");&#125; else &#123; print(\"sumArray is not empty array\");&#125;/* 数组拼接添／加数据*/shoppingList.append(\"Water\")shoppingList += [\"Cheese\",\"Butter\"]//数组元素的获取let water = shoppingList[3]//使用数组下标修改数组中的元素shoppingList[3] = \"Bananas\"//使用下标区间一次修改多个值shoppingList[0...3] = [\"iPhone\",\"iMac\",\"iPod\"]//在数组的制定下标索引位置插入元素shoppingList.insert(\"Apple\", at: 0)//在数组的指定下标索引位置插入一个数组shoppingList.insert(contentsOf: [\"MicroSoft\",\"Google\"], at: 0)//在数组中移除某个指定下标位置的数组元素shoppingList.remove(at: 0)shoppingList.removeLast()shoppingList.removeSubrange(0...1)//替换数组中指定范围的元素shoppingList.replaceSubrange(0...1, with: [\"MacBook Pro\",\"MacBook Air\"])//数组的遍历for item in shoppingList &#123; print(item)&#125;/* 使用 enumerated() 方法同时遍历数组索引，和数组元素*/for (index, value) in shoppingList.enumerated() &#123; print(\"第\\(index + 1)个元素是\\(value)\")&#125; 集合的简单使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//初始化一个空的集合，必须显示的声明集合的类型var letters = Set&lt;Int&gt;()//确定集合的类型后可以使用数组字面量赋值letters = []//使用数组字面量创建集合var set:Set&lt;Int&gt; = [1,2,3,3,4]var set2:Set = [2,23,5,6,89,]//判断集合是否为空var foods:Set = [\"Apple\",\"Milk\",\"Beef\"]if foods.isEmpty &#123; print(\"this sets is empty\")&#125; else &#123; print(\"this sets is not empty\")&#125;//也可以像数组一样使用元素个数来检查是否为空if foods.count == 0 &#123; print(\"this sets is empty\")&#125; else &#123; print(\"this sets is not empty\")&#125;//获取集合的元素个数foods.count//像集合添加新的元素foods.insert(\"Peach\")foods.insert(\"Tomato\")foods.insert(\"Bread\")//移除集合元素foods.remove(at: foods.index(of: \"Apple\")!)foods.remove(\"Peach\")foods.removeFirst()//是否包含某个元素的检查if foods.contains(\"Milk\") &#123; print(\"foods hava Milk\")&#125;//遍历集合for food in foods &#123; print(food)&#125;//使用 sorted() 方法有序的遍历集合for food in foods.sorted() &#123; print(food)&#125;//既然是集合就有交集，相交等let numbers: Set = [1,2,3,4,5,6,7,8,9]let newNumbers: Set = [2,3,4,5,10,11,12,13]//相交等集合元素，创建一个新的集合let interNumbers = numbers.intersection(newNumbers)//不相交的集合元素，创建一个新的集合let symmerricNumbers = numbers.symmetricDifference(newNumbers)//将两个集合融合在一起，创建一个新的集合let unionNumbers = numbers.union(newNumbers)//不包含另一个集合的元素，创建一个新的集合let notSubNumbers = numbers.subtracting(newNumbers)//集合关系的判断//判断集合是否相等if numbers == newNumbers &#123; print(\"numbers == newNumbers\")&#125; else &#123; print(\"numbers != newNumbers\")&#125;//判断集合a是是集合b的子集let a: Set = [2,3,4]let b: Set = [2,3,4,5,1]if a.isSubset(of: b) &#123; print(\"a is subSet of b\")&#125;//判断一个集合b是否包含集合a的所有元素if b.isSuperset(of: a) &#123; print(\"b is superSet of a\")&#125;//判断两个集合是否不含有相同的值if b.isDisjoint(with: a) &#123; print(\"YES\")&#125; else &#123; print(\"NO\")&#125; 字典的简单使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//创建一个空字典var emptyDictionary = [Int: String]()emptyDictionary[16] = \"Aaron\"//使用字面量创建字典//常量，不可变字典let newDictionary = [1:\"Aaron\",2:\"Jay\",3:\"Edison\",4:\"Jack\"]//变量，可变字典var muatableDictionary: [String: String] = [\"艾伦\":\"Aaron\",\"爱迪生\":\"Edison\",\"杰\":\"Jay\",\"杰克\":\"Jack\"]//访问和修改字典//通过键值获取let name = muatableDictionary[\"艾伦\"]//通过键值修改muatableDictionary[\"艾伦\"] = \"Alan\"//修改和添加元素muatableDictionary.updateValue(\"艾伦\", forKey: \"艾伦\")print(muatableDictionary)muatableDictionary.updateValue(\"Alan\", forKey: \"艾伦\")print(muatableDictionary)//删除元素//通过key删除元素muatableDictionary.removeValue(forKey: \"艾伦\")//通过索引删除muatableDictionary.remove(at: muatableDictionary.index(forKey: \"杰克\")!)//通过置nil删除元素muatableDictionary[\"爱迪生\"] = nilprint(muatableDictionary)//字典的遍历//通过元组遍历字典for (numberOfName, englishName) in newDictionary &#123; print(\"第\\(numberOfName)个名字是\\(englishName)\")&#125;//这样遍历出来的应该也是元组for keysAndValues in newDictionary &#123; print(keysAndValues)&#125;//遍历字典所有的keyfor numberOfName in newDictionary.keys &#123; print(numberOfName)&#125;//遍历字典所有的值for name in newDictionary.values &#123; print(name)&#125;","categories":[],"tags":[{"name":"Swift","slug":"Swift","permalink":"Aaronzjp.cn/tags/Swift/"}]},{"title":"swift-函数","slug":"Swift 3.0-Function","date":"2016-12-01T06:11:37.000Z","updated":"2017-08-01T07:52:36.000Z","comments":true,"path":"2016/12/01/Swift 3.0-Function/","link":"","permalink":"Aaronzjp.cn/2016/12/01/Swift 3.0-Function/","excerpt":"","text":"函数的声明和调用在swift中函数是一个非常灵活的东西，可以定义任何的类型来作为函数的参数和返回值，一个比较完整的函数声明包括很多部分，下面就是一个简单的函数声明： 1234567func sum(numbers: [Int]) -&gt; Int &#123; var sum = 0 for number in numbers &#123; sum += number &#125; return sum&#125; 该函数的函数名为sum(numbers:)，有一个叫numbers的Int类型的数组参数，并返回一个Int类型的值。这应该就是一个比较完整的函数的声明。在swift中声明一个函数的时候尽量做到函数名简洁清楚，以达到该函数使用者在看到这个函数的时候就能大致理解函数的用意。调用下上面的函数看下结果会是什么样： 123let numbers = [1,2,3,4,5,6,7,8,9]let sumNumber = sum(numbers: numbers)//输出结果：45 上面这个函数传入的是一个Int类型的数组来计算数组中元素的和，通过调用函数证明该函数正确的输出了数组中元素的和。 可变函数参数也可以将上面的函数改成如下函数来求各个数的和，该函数看起来可能和上面的函数看起来基本上没有差别，但是仔细看可以看到函数参数变了，该函数接收Int类型的参数且参数个数是可变的，在函数体内部可变函数的参数被转换为参数同类型的数组，函数体内部其实和上面的那个函数没有差别，都是对数组进行处理求和。如果愿意这里可以传入大量的参数。 12345678910func sum(numbers: Int...) -&gt; Int &#123; var sum = 0 for number in numbers &#123; sum += number &#125; return sum&#125;let sumNumber = sum(numbers: 1,2,3,4,5,6,7,8,9)//输出结果：45 需要注意的是一个函数最多只能有一个可变参。 多参数函数函数也可以接受多个参数的输入，多个参数用逗号隔开即可。下面这个函数输出一个字符串，告诉你谁和谁是好朋友： 123456func whoIsFriend(person1: String, person2: String) -&gt; String &#123; return person1+\"和\"+person2+\"是好朋友！\"&#125;let friend = whoIsFriend(person1: \"Aaron\", person2: \"Edison\")//输出结果：Aaron和Edison是好朋友！ 无参数和无返回值函数函数可以是没有参数的，比如下面的这个参数在调用的时候它会返回一个固定的值： 123456func printHello() -&gt; String &#123; return \"Hello!\"&#125;let hello = printHello()//输出结果：Hello！ 函数可以没有参数也可以没有返回值，下面的函数就是一个没有返回值的函数，当函数调用的时候会直接执行函数体中的代码，不会返回任何值： 123456func printHello() &#123; print(\"Hello!\")&#125;printHello()//输出结果：Hello！ 多返回值函数当函数需要返回多个值的时候可以使用元组来包裹需要返回的值以达到返回多个值的目的，下面的这个函数通过元组返回数组中的最大值和最小值： 123456789101112131415161718func minMax(array: [Int]) -&gt; (min: Int, max: Int) &#123; var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count] &#123; if value &lt; currentMin &#123; currentMin = value &#125; else if value &gt; currentMax &#123; currentMax = value &#125; &#125; return (currentMin, currentMax)&#125;let numbers = [2,5,3,6,7,10]let bounds = minMax(array: numbers)print(bounds.min,bounds.max)//输出结果：2 10 该函数返回一个包含了两个Int元素的元组，元素被标记为min和max，我们可以通过元组中的元素名用点语法来取出元组中的值。 可选多返回值函数函数可以通过元组返回多个值，这些值也可以是可选类型的。但是要注意的是元组可以区分为元素可选元组(Int,String?)和元组可选元组(Int,String)?。上面的这个函数，其实并不是很安全，如果给该函数传入一个空数组就会导致程序崩溃，为了安全起见我们可以改成下面这样，当传入的数组为空时我们返回nil： 1234567891011121314151617181920func minMax(array: [Int]) -&gt; (min: Int, max: Int)? &#123; if array.isEmpty &#123;return nil&#125; var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count] &#123; if value &lt; currentMin &#123; currentMin = value &#125; else if value &gt; currentMax &#123; currentMax = value &#125; &#125; return (currentMin, currentMax)&#125;let numbers = [Int]()//用可选绑定来检查返回值if let bounds = minMax(array: numbers) &#123; print(bounds.min,bounds.max)&#125;//此处没有任何输出结果，因为返回值为nil 函数参数标签和参数名称在swift的函数中每个函数的参数都有一个参数标签和参数名称。参数标签在调用参数的时候使用，参数名称则在函数的实现中使用，在默认情况下参数标签就是参数名称。但是在某些时候可能需要更好的为函数调用者说明参数的用意，可能会另外的为参数取一个易懂的参数标签，以便函数调用的时候使用。如下为函数参数指定标签： 123456789let sumNumber = sum(numbers: 1,2,3,4,5,6,7,8,9)func whoIsFriend(person: String, with person1: String) -&gt; String &#123; return person+\"和\"+person1+\"是好朋友！\"&#125;let friend = whoIsFriend(person: \"Aaron\", with: \"Edison\")print(friend)//输出结果：Aaron和Edison是好朋友！ 上面的这个函数为函数的第二个参数加入了一个with的参数标签，这样函数在调用的时候就显得可读性更高，比之前没有函数标签时可读性更高，更规范。函数中参数名称必须是不一样的，但是参数标签是可以相通的。 忽略参数标签当然参数标签也是可以忽略的，忽略参数标签使用_来占位代替参数标签： 1234567func whoIsFriend(_ person: String, _ person1: String) -&gt; String &#123; return person+\"和\"+person1+\"是好朋友！\"&#125;let friend = whoIsFriend(\"Aaron\", \"Edison\")print(friend)//输出结果：Aaron和Edison是好朋友！ 函数默认参数值函数中还可以为参数赋予默认值，当默认值被设置后在调用函数的时候可以忽略这个参数： 123456789func sumNumber(number1: Int, number2: Int = 10) -&gt; Int &#123; return number1 + number2&#125;let sum = sumNumber(number1: 1)let sum2 = sumNumber(number1: 1, number2: 15)print(\"sum = \\(sum),sum2 = \\(sum2)\")//输出结果：sum = 11,sum2 = 16 很明显sum在调用函数的时候忽略了第二个默认为 10 的参数，所以使用默认的值来计算返回 11，sum2在调用函数的时候传入了第二个参数为 15 来替代了默认值 10 所以返回为16。 输入输出参数输入输出参数是指给函数传入的参数是可以在函数内部被修改的，设置输入输出参数要在函数参数的类型前加上inout关键字，这样被标记的函数参数才是可以被修改的。调用函数的时候传入输入输出参数的值必须是变量，不能是常量或是字面量，因为只有变量可以被修改，可变参数不能设定为输入输出参数。且输入输出参数不能设置默认值。 12345678910111213func swapNumber( a: inout Int, b: inout Int) &#123; let temp = a a = b b = temp&#125;var a = 10,b = 20print(\"交换前 a = \\(a),b = \\(b) \")swap(&amp;a, &amp;b)print(\"交换后 a = \\(a),b = \\(b)\")//输出结果：交换前 a = 10,b = 20 交换后 a = 20,b = 10 该函数是交换两个Int类型的值，要注意的是在调用有输入输出参数的函数时需要在输入输出参数前加上&amp;符号。 函数类型在swift中函数是具有函数类型的，函数的类型是由函数参数和函数返回值组成的。如下函数： 123func sumNumber(number1: Int, number2: Int = 10) -&gt; Int &#123; return number1 + number2&#125; 该函数的函数类型是(Int,Int) -&gt; Int，可以理解为该函数有两个Int型的参数并返回Int型的值。那如果函数没有参数和返回值，函数会是什么类型？如下： 123func printHelloWorld() &#123; print(\"hello, world\")&#125; 该函数没有参数也没有返回值，该函数的类型是() -&gt; Void，可以理解为该函数没有参数并返回Void类型的函数。在OC中如果一个方法没有返回值，那么会用void关键字来标示。在swift中没有返回值的函数函数类型也用Void表示，其实swift中没有返回值的函数会返回一个特殊的Void值，其本质是一个空的元组，没有任何的元素。 函数类型的使用函数类型赋值 在swift中函数类型就像是普通的类型一样，可以声明一个变量或者是常量的函数类型，并且可以给同类型的函数相互赋值，且函数的类型也是可以通过推断得出来的。如下，声明一个函数，并将它赋值给另一个函数并调用该函数： 1234567891011121314func sum(number1: Int, number2: Int = 10) -&gt; Int &#123; return number1 + number2&#125;let sumNumber = sum(number1: 10, number2: 100);print(sumNumber)let numberSum = sumlet sumNumber2 = numberSum(10, 100)print(sumNumber2)//输出结果：110110 上面声明了一个(Int,Int) -&gt; Int类型的函数sum，并将该函数赋值给常量类型的函数numberSum，分别调用sum和numberSum函数，其结果是一样的。 函数类型作为参数类型 当然函数既然可以相互赋值那么函数也可以作为其他函数的参数和返回值，将函数类型作为参数类型这样就可以给函数调用者更大的空间来实现这一部分的函数。 1234567891011func sum(sumFunc: (Int, Int) -&gt; Int ,numberA: Int, numberB: Int = 10) -&gt; Int &#123; return sumFunc(numberA, numberB)&#125;func sumNumber(a: Int, b: Int) -&gt; Int &#123; return a + b&#125;let result = sum(sumFunc: sumNumber, numberA: 10, numberB: 20)//输出结果：result = 30 该函数有三个参数，其中一个sumFunc的参数是一个函数类型，接受两个Int类型的参数，并返回一个Int类型的值，numberA和numberB则是两个Int类型的参数。该函数返回一个Int类型的值，该值是由第一个函数类型的参数来决定的。函数类型也可以作为函数的返回值来使用，我想这里的用处应该是返回一个内部函数（嵌套函数）吧。 总结swift的函数总的来说比起在OC语言中的函数要灵活得多，函数的创建有两种方式，一种是通过func关键字来创建，另一种方式是使用{}来创建，其中通过{}创建的函数被称作闭包表达式。在swift中函数的类型其实总的来说可以像我们平常使用变量或者常量一样，可以在相通类型的函数之间相互赋值，也可以作为函数的参数，或者将函数类型作为函数的返回值来使用。","categories":[],"tags":[{"name":"Swift","slug":"Swift","permalink":"Aaronzjp.cn/tags/Swift/"}]},{"title":"初识CALayer","slug":"iOS-CALayer","date":"2016-12-01T06:11:37.000Z","updated":"2017-07-27T02:57:07.000Z","comments":true,"path":"2016/12/01/iOS-CALayer/","link":"","permalink":"Aaronzjp.cn/2016/12/01/iOS-CALayer/","excerpt":"CALayer 和 UIView 类似，也是一些被层级关系树管理的块。 CALayer 和 UIView 一样的可以可以在其中展示图片，文本，通过方法或属性做动画和图形变换等等的界面上的显示相关的东西，可以说 UIView 能做到的 CALayer 基本上也能做到，但是 CALayer 和 UIView 最大的不同是 CALayer 不处理和用户的交互。因为 CALayer 不能很好的处理具体的响应链，无法响应事件的处理，即使在 CALayer 的方法中提供了触摸事件的检测方法。","text":"CALayer 和 UIView 类似，也是一些被层级关系树管理的块。 CALayer 和 UIView 一样的可以可以在其中展示图片，文本，通过方法或属性做动画和图形变换等等的界面上的显示相关的东西，可以说 UIView 能做到的 CALayer 基本上也能做到，但是 CALayer 和 UIView 最大的不同是 CALayer 不处理和用户的交互。因为 CALayer 不能很好的处理具体的响应链，无法响应事件的处理，即使在 CALayer 的方法中提供了触摸事件的检测方法。 CALayer和UIView的关系很早以前我一直弄不清楚 CALayer 和 UIView 之间到底是个怎么样的关系，我只是知道每一个 UIView 中都至少包含了一个 CALayer 。其实在每一个 UIView 中都有一个 CALayer 的实例图层属性，当视图被创建的时候就会有对应的一个图层，图层和视图一样也可以添加子图层。 UIView 其实是对 CALayer 的一层封装，之前也说了 CALayer 不能响应事件以及和用户交互， UIView 在这里就充当了一个来代替 CALayer 响应事件的处理和管理 CALayer 的一个角色， UIView 也只是负责这些东西的处理，在屏幕上显示和动画的处理其实都是在 CALayer 上进行的。 图层结构和对应的视图层级的关系如下图： CALayer常用属性 属性 属性相关描述 backgroundColor 为图层添加背景色，该属性为CGColorRef类型 contents 图层内容，寄宿图。id 类型，iOS中一般使用CGImage赋值，MacOS中则可以使用NSImage 或 CGImage contentsGravity 寄宿图内容展示方式，和UIImageView的contensMode对应。该属性是NSString类型 contentsScale 寄宿图显示比例设置， maskToBounds 是否显示超出边界的内容，该属性是一个BOOL值类型，默认为NO，即显示超出边界的内容 contentsRect CGRect类型，允许图层显示寄宿图的某个固定区域。使用单位坐标，即0到1之间 contentsCenter 图层可拉伸区域的设置，也是使用单位坐标 frame 代表图层外部的坐标以及大小，即相对于父图层的位置 bounds 图层的内部坐标大小，bounds的X，Y轴在 iOS 中一般位于图层的左上角 position position 是相对于 anchorPiont 的位置在 superLayer 的位置。 anchorPiont 图层的锚点，固定图层的点。（当对图层做旋转形变的时候，图层将围绕该点旋转），使用单位坐标即{0,0,1,1}; geometryFlipped 图层翻转，该属性是一个 BOOL 属性，在 iOS 中将该属性设置为 YES 的时候，图层将会相对于父图层做垂直翻转，即该图层的位置将会相对于父图层从左下角开始。 conrnerRadius 该属性控制着图层角的曲率。它是一个浮点数，默认为0（为0的时候就是直角），但是你可以把它设置成任意值。 masksToBounds 该属性是一个BOOL类型的，当设置为YES的时候他将会截取图层中超出边界的部分 borderWidth 图层边框宽度，以点为单位，默认为0 borderColor 图层边框颜色，是一个 CGColorRef 类型的属性 CALayer的使用 CALayer 也可以像 UIView 一样的添加背景色，寄宿图，同时还可以通过 CALayer 做一些 UIView 不能做到的视觉效果。 为CALayer添加背景色123456789101112131415161718192021222324#import &quot;CALayerBGColorViewController.h&quot;@interface CALayerBGColorViewController ()@property (nonatomic,strong) UIView *whiteView;@end@implementation CALayerBGColorViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.whiteView = [[UIView alloc]init]; _whiteView.backgroundColor = [UIColor whiteColor]; _whiteView.bounds = CGRectMake(0, 0, 150, 150); _whiteView.center = self.view.center; [self.view addSubview:_whiteView]; CALayer *orangeLayer = [CALayer layer]; orangeLayer.frame = CGRectMake(25, 25, 100, 100); orangeLayer.backgroundColor = [UIColor orangeColor].CGColor; [_whiteView.layer addSublayer:orangeLayer];&#125;@end 这里为控制器添加了一个白色的视图 图 whiteView ，然后向 whiteView 中的 layer 添加了一个子图层（ orangeLayer ），并给 orangeLayer 添加了橘色的背景色。 CALayer 和 UIView 相比，缺少了一个 center 属性。当向 CALayer 添加背景色的时候并不是赋值的 UIColor 类，而是一个 CGColorRef 这是因为该库是由 C 语言所编写的。 CALayer 中设置寄宿图同样也是赋值一个 CGImage 。 CALayer的contents的使用1234567891011121314151617181920212223#import &quot;CALayerBackImageViewController.h&quot;@interface CALayerBackImageViewController ()@property (nonatomic,strong) UIView *layerView;@end@implementation CALayerBackImageViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.layerView = [[UIView alloc]init]; _layerView.bounds = CGRectMake(0, 0, 150, 100); _layerView.center = self.view.center; [self.view addSubview:_layerView]; UIImage *EdisonImage = [UIImage imageNamed:@&quot;Edison.jpg&quot;]; _layerView.layer.contents = (__bridge id)(EdisonImage.CGImage); _layerView.layer.backgroundColor = [UIColor orangeColor].CGColor; _layerView.layer.contentsGravity = kCAGravityResizeAspect; &#125;@end 代码中我们为视图的 layer 添加了一个图片作为 layer 的寄宿图，但是这里要注意⚠️的是，这和我们使用 UIImageView 添加图片是有区别的。我们给 layer 赋值的图片是一个 CGImage 的类型，原因上面也提到了因为该库是由 C 语言编写的，所以 CGImage 其实是一个 CGImageRef 的 Core Foundation 类型。 Core Foundation 类型和 Cocoa 对象并不是兼容的对象，所以这里在赋值的时候还需要进行类型转换，在 ARC 环境下需要使用桥接来转换类型，以便编译器在内存管理的时候不会出错。 1_layerView.layer.contents = (__bridge id)(EdisonImage.CGImage); layer 在被赋值寄宿图的时候被赋值的属性并不是平常使用 UIImageView 时赋值的 Image 属性，该属性是一个叫 Contents 的 id 类型的属性。 id 类型就意味着可以赋值任何的对象给这个 Contents 属性，可以尝试下赋值其他的对象给 Contents 属性，当被赋值其他对象的时候 layer 几乎不会发生任何的改变，就是一个空白的图层， 编译也能通过，甚至还可能产生错误，这样的错误❌如果出现在实际的项目中的话应该是很难被发现的。其实在 iOS 中只能为 layer 的 Contents 属性赋值 CGImageRef 类型，这个属性被苹果设置成 id 的原因是因为 iOS 系统是由 MacOS 的系统演变出来的，在 MacOS 中该属性可以接受 CGImage 和 NSImage 类型。 CALayer 可以添加寄宿图，所以 CALayer 还有一个和 UIImageView 的 contentMode 属性相对应的属性用来处理寄宿图的显示方式。这个与之相对应的属性叫 contentsGravity ，但是这个属性是一个 NSString 的类型，而 UIKit 中的 contentMode 属性是一个枚举类型。具体的使用和 contentMode 所对应的枚举值一一对应，区别是一个是作用于 UIImageView 上的，一个是作用于 CALayer 。 寄宿图显示比例（contentsScale）还有一个值得注意的是，在 CALayer 赋值寄宿图的时候是赋值的一个由 UIImage 转换成 CGImage 的类型的图片， UIImage 在获取图片的时候是按照 Retina 屏幕的分辨率比例来获取图片的，获取的是高质量的 Retina 版本的图片，但是在转换成 CGImage 后这个比例的缩放拉伸就被忽略了，所以同样的一张图片 UIImage 展示出来的看起来比 CGImage 展示出来的要小，但是更清晰。但是在 CALayer 中还是可以让赋值的 CGImage 正常的显示在 Retina 屏幕上的，这里设置 CALayer 的 contentScale 属性，该属性其实就是为了支持高分辨率屏幕的显示而存在的吧。一般如下设置该属性： 1layer.contentsScale = [UIScreen mainScreen].scale; 该方法设置 layer 的 contentsScale 属性比起直接设置改属性的比例更好，改方法会让该属性跟随屏幕的比例而改变。 截取超出图层边界的显示内容（masksToBounds）在图层上显示寄宿图有时候图片可能会超出图层的边界，这样的情况在 UIView 下也有同样的问题。在 UIView 中用一个叫做 clipsToBounds 属性来决定是否显示超出边界的内容。 CALayer 中同样的也有一个属性可以决定是否显示其超出边界的内容 masksToBounds 。示例🌰如下： 1_layerView.layer.masksToBounds = YES; CALayer中使用图片拼合技术（contentsRect） CALayer 中 contentsRect 可以图层显示自己的一部分内容。这个属性是一个 CGRect 类型的，但是这里和平常使用的 bounds 、 frame 属性不同。 contentsRect 使用的是单位坐标，单位坐标是指在0到1之间的一个相对的坐标系，这里就是相对于寄宿图的。 contentsRect 默认情况下是{0，0，1，1}，也就是说在默认情况下是显示一个完整的图片的，当把该属性缩小后图片就会被裁剪，只显示出设置的相对的坐标中的内容。如下演示了如何将一个图片切割成4块，来拼接显示出来： 1234567891011121314151617181920212223242526272829303132333435#import &quot;CALayerImageSpritesViewController.h&quot;@interface CALayerImageSpritesViewController ()@property (weak, nonatomic) IBOutlet UIView *firstView;@property (weak, nonatomic) IBOutlet UIView *secondView;@property (weak, nonatomic) IBOutlet UIView *thirdView;@property (weak, nonatomic) IBOutlet UIView *forthView;@end@implementation CALayerImageSpritesViewController- (instancetype)init &#123; self = [super init]; if (self) &#123; UIStoryboard *storyboard = [UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:nil]; self = [storyboard instantiateViewControllerWithIdentifier:@&quot;spriteImageVC&quot;]; &#125; return self;&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; UIImage *spriteImage = [UIImage imageNamed:@&quot;Edison.jpg&quot;]; [self addImage:spriteImage WithContentsRect:CGRectMake(0, 0, 0.5, 0.5) toLayer:self.firstView.layer]; [self addImage:spriteImage WithContentsRect:CGRectMake(0.5, 0, 0.5, 0.5) toLayer:self.secondView.layer]; [self addImage:spriteImage WithContentsRect:CGRectMake(0, 0.5, 0.5, 0.5) toLayer:self.thirdView.layer]; [self addImage:spriteImage WithContentsRect:CGRectMake(0.5, 0.5, 0.5, 0.5) toLayer:self.forthView.layer];&#125;- (void)addImage:(UIImage *)image WithContentsRect:(CGRect)rect toLayer:(CALayer *)layer &#123; layer.contents = (__bridge id)image.CGImage; layer.contentsGravity = kCAGravityResizeAspect; layer.contentsRect = rect;&#125;@end 设置图层的可拉伸区域（contentsCenter）该属性是一个 CGRect 类型，和 contentsRect 一样使用的是单位坐标，默认情况下是{0，0，1，1}。它定义了一个固定的边框和一个在图层上可拉伸的区域，在普通情况下修改该属性，图层的显示并不会发生任何的变化，但是当图层被拉伸的时候就会有所变化，因为这就是设置拉伸区域的一个属性。 例如🌰：将 contentsCenter 设置为：{0.25，0.25，0.5，0.5}。其效果如下所示： 其实我看到这个图我也还是搞不太懂这个是怎么拉伸的，但是再看下下面这个例子🌰： 被拉伸前的原图： 在代码中如下设置 contentsCenter 属性： 12345678910111213141516171819202122#import &quot;CALayerContentsCenterViewController.h&quot;@interface CALayerContentsCenterViewController ()@property (nonatomic,strong) UIView *layerView;@end@implementation CALayerContentsCenterViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.layerView = [[UIView alloc]init]; _layerView.bounds = CGRectMake(0, 0, 300, 300); _layerView.center = self.view.center; [self.view addSubview:_layerView]; UIImage *image = [UIImage imageNamed:@&quot;Test.png&quot;]; _layerView.layer.contents = (__bridge id) image.CGImage; _layerView.layer.contentsGravity = kCAGravityResizeAspect; _layerView.layer.contentsCenter = CGRectMake(0.25, 0.25, 0.5, 0.5); &#125;@end 拉伸后的效果如下图： 该效果可以作用于在寄宿图层上，同时也可以作用于在 Core Graphics 运行时绘制的图形上。 图层布局管理图层和 UIView 一样也有自己的布局管理的相关的属性， UIView 有 frame， bounds ， center ， CALayer 也有与之相对应的属性， frame， bounds ， position 。 CALayer 的 position 其实和 UIView 的 center 代表的都是同一个值。 frame 这个属性其实并不是一个初始的属性，该属性是通过 bounds 和 position 和 transform 计算得到的，所有改变这3个中的任意一个的值都会影响到 frame ，同样改变 frame 也会影响这三个属性的值的改变。最后注意一点的是当图层做出旋转后，图层的 frame 可能就和 bounds 不一致了， frame 实际上代表了覆盖在图层旋转之后的整个轴对齐的矩形区域。 锚点（anchorPoint）这个属性很可能会把人搞糊涂，看似是很好理解的，但是很多人经常因为这个属性被搞糊涂。 anchorPoint 一般位于图层的中心，但是这个属性是可以被改变的，虽然在 UIView 中该属性没有被暴露出来，但是在 CALayer 中是可以进行修改的。当修改 anchorPoint 属性时可能会造成图层的偏移， 也就是说这个时候图层的中心点（ position ）以及 UIView 的 center 相对于父视图是不会改变的，但是 anchorPoint 发生了改变， anchorPoint 被修改后 anchorPoint 会自动的向图层的 position 对齐，这个时候 center 或者 position 这个属性可能并不是图层真正的中心点。当改变了 anchorPoint ， position 属性保持固定的值并没有发生改变，但是 frame 却移动了。当对图层做变换，旋转的时候，图层都会以 anchorPoint 为中心点来旋转。 图层翻转（geometryFlipped）通常来说，在 iOS 上，一个图层的位置是相对于父图层从左上角开始的，但是在 MacOS 中则是从左下角开始的。图层翻转，该属性是一个 BOOL 属性，在 iOS 中将该属性设置为 YES 的时候，图层将会相对于父图层做垂直翻转，即该图层的位置将会相对于父图层从左下角开始。 坐标系转换图层和 UIView 一样，图层树中各个图层间相对于的坐标位置是可以相互转换的，苹果提供了如下的方法，让我们可以在各个图层间获得其相对于其他图层的坐标位置，而不仅限于相对于父图层的位置： 1234- (CGPoint)convertPoint:(CGPoint)point fromLayer:(CALayer *)layer; - (CGPoint)convertPoint:(CGPoint)point toLayer:(CALayer *)layer; - (CGRect)convertRect:(CGRect)rect fromLayer:(CALayer *)layer;- (CGRect)convertRect:(CGRect)rect toLayer:(CALayer *)layer; 图层的自动布局在Mac OS平台下， CALayer 有一个叫做 layoutManager 的属性可以通过 CALayoutManager 协议和 CAConstraintLayoutManager 类来实现自动排版的机制。但是因为 iOS 和 MacOS 还是有一定的区别，所有在 iOS 上并不适用。在使用视图 UIView 时我们一般使用 UIViewAutoresizingMask 和 NSLayoutConstraint 来完成自动布局，但是在 CALayer 下就不能使用这样的方式来处理了。在 CALayer 中布局需要遵守 CALayerDelegate 中的方法： 1- (void)layoutSublayersOfLayer:(CALayer *)layer; 在此方法中来布局图层。当图层的 bounds 发生改变，或者图层的-setNeedsLayout方法被调用时就会执行此代理方法。我们可以在此代理方法中来布局或重新调整子图层的大小以及位置，但是不能像 UIView 的 autoresizingMask 和 constraints 属性做到自适应屏幕旋转。 图层效果圆角圆角矩形， CALayer 有一个叫 conrnerRadius 的属性，他控制图层的圆角率，默认是0.0，但是我们可以设置为任意的值，该值会影响背景色，但是背景图片和里面的子图层不会受到影响，所以如果有背景图片或者有子视图在图层内时，设置改属性后可能不会根据设置的圆角率来显示图层。不过这个问题只需要设置另一个属性即可解决， masksToBounds ，该属性是一个 BOOL 类型,他可以决定是否显示超出图层外的图层部分。默认是 NO ，当设置为 YES 的时候图层就会截取超出图层的部分。圆形图层也可以通过设置 conrnerRadius 来设置，前提是当前图层是一个正方形，当 conrnerRadius 的值等于正方形边长的一半的时候就是圆形。 图层边框 CALayer 有两个属性可以为图层绘制边框，即 borderWidth 和 borderColor ，通过这两个属性我们可以定制图层绘制的边框，这条线(又被称作stroke)会沿着图层的 bounds 边缘来绘制，同时也包含了图层的角。边框是绘制在图层边界里面的，且在所有的子图层或子内容前面。 borderWidth 确定了图层所绘制的边框的宽度， borderColor 则确定了图层边框的颜色。 图层阴影在很多情况下我们需要为图层绘制阴影，绘制图层阴影之需要给图层的 shadowOpacity 复制即可，该属性是一个0(不可见)-1(完全不透明)之间的浮点数。另外还可以通过其他一些图层的属性来更改阴影的一些其他效果， shadowColor ， shadowOffset 和shwdowRadius。 shadowColor 看名字我们就知道这是控制阴影颜色的属性，该属性是一个 CGColorRef 类型的属性，该属性默认的阴影颜色是黑色。 shadowOffset 属性控制着阴影的方向和距离，它是一个 CGSize 的值。 shadowRadius 是控制图层阴影边界模糊度的属性，当该属性为0的时候，图层边界和阴影之间就显得非常明显，不是很自然，当数值越大图层和阴影的边界就越自然，显得没有那么明显。 要注意的是图层的阴影是根据图层内容计算绘制出来的，并不是简单的在图层边框外绘制出阴影的。比如说如果图层中除了图层中图片显示部分有内容，其他部分是透明的，那么这个阴影将会沿着图层的显示内容来绘制，而不是沿着图层的边界绘制的。还有一点阴影在图层中是可以被 masksToBounds 属性裁剪掉的，所以在有使用 masksToBounds 属性的图层中绘制阴影的时候最好单独在创建一个图层放在图层之下来专门绘制图层的阴影，这样阴影就不会被裁剪掉。 使用 shadowPath 自定义图层阴影事实上图层的阴影是很消耗性能的，因为从上面得知图层阴影并不是固定的沿着图层的边缘绘制的，而是根据图层内容的形状计算来的。我们可以事先为图层指定阴影样式，通过对图层的 shadowPath 属性指定图层样式来提高性能。 shadowPath 是一个 CGPathRef 类型（一个指向 CGPath 的指针）。 CGPath 是一个 Core Graphics 对象，用来指定任意的一个矢量图形。可以通过这个属性单独于图层形状之外指定阴影的形状。 123456789101112131415161718192021222324252627@interface ViewController ()@property (nonatomic, weak) IBOutlet UIView *layerView1;@property (nonatomic, weak) IBOutlet UIView *layerView2;@end@implementation ViewController- (void)viewDidLoad&#123; [super viewDidLoad]; //enable layer shadows self.layerView1.layer.shadowOpacity = 0.5f; self.layerView2.layer.shadowOpacity = 0.5f; //create a square shadow CGMutablePathRef squarePath = CGPathCreateMutable(); CGPathAddRect(squarePath, NULL, self.layerView1.bounds); self.layerView1.layer.shadowPath = squarePath; CGPathRelease(squarePath); ￼//create a circular shadow CGMutablePathRef circlePath = CGPathCreateMutable(); CGPathAddEllipseInRect(circlePath, NULL, self.layerView2.bounds); self.layerView2.layer.shadowPath = circlePath; CGPathRelease(circlePath);&#125;@end 如果图层阴影的图形相当的复杂也可以使用 UIBezierPath 来为图层绘制阴影。 图层蒙版 CALayer 中有一个叫 mask 的属性，这个属性本身就是一个 CALayer 的类型。该图层就像是图层的子图层一样，我的理解应该是覆盖在父图层(该属性的拥有者)之上的图层，上面一部分代码中的 conrnerRadius 和 masksToBounds 属性就是通过对 mask 图层进行操作达到修改图层圆角率以及裁剪图层的。有很重要的一点我之前一直有错误的理解，我一直以为 mask 属性中 mask 图层透明的部分才是被保留的而实心的部分会被裁剪，然而这点和我的理解刚刚相反。 mask 图层中实心的部分会被保留显示出来，透明的部分则会被隐藏掉。 如下代码，将会把一个图层，显示成 mask 内容的形状： 1234567891011121314151617181920212223242526272829#import \"CALayerMaskViewController.h\"@interface CALayerMaskViewController ()@property (weak, nonatomic) IBOutlet UIImageView *imageView;@end@implementation CALayerMaskViewController- (instancetype)init &#123; self = [super init]; if (self) &#123; UIStoryboard *storyboard = [UIStoryboard storyboardWithName:@\"Main\" bundle:nil]; self = [storyboard instantiateViewControllerWithIdentifier:@\"MaskLayerVC\"]; &#125; return self;&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor]; self.imageView.image = [UIImage imageNamed:@\"Edison.jpg\"]; CALayer *maskLayer = [[CALayer alloc]init]; maskLayer.frame = _imageView.bounds; maskLayer.contents = (__bridge id)[UIImage imageNamed:@\"Heart\"].CGImage; _imageView.layer.mask = maskLayer; &#125; CALayer 的 mask 属性因为是 CALayer 类型，所以图层蒙版不一定局限于静态的图片的样式。任何由图层构成的都可以作为 mask 属性，这样蒙板可以通过代码甚至是动画实时生成。 组透明在 UIView 中有一个 alpha 的属性用来设置视图的透明度，同样的在 CALayer 中也有与之对应设置透明度的属性，那就是opacity。这两个属性都会对子视图或者子图层有所影响。当一个视图包含子视图的时候，去设置视图的透明度就会有所问题，比如把一个视图的透明度（alpha）设置为0.5的时候该视图的子视图透明度却不是0.5。这是因为图层的重叠透明度造成的，如果希望子视图也同样和视图透明，那么有两种方式去解决。第一种就是通过在项目的Info.plist文件中设置 UIViewGroupOpacity 属性为 YES 即可达到效果，但是这种方式会影响到整个的项目，很明显的在某些时候这个解决方式并不是最好的。第二种方式就是设置视图中图层的 shouldRasterize 属性为 YES ，设置该属性的时候一定要设置 rasterizationScale 属性以去匹配屏幕，防止视图在Retina屏幕下像素化的问题。还有一点，如果 shouldRasterize 和 UIViewGroupOpacity 同时使用会有一定的性能问题。 绘制CALayer的寄宿图CALayer 的 Contents 属性也不一定非要赋值一个寄宿图，可能有的时候我们需呀自己定义一些简单的视图，这个时候我们可以通过 Core Grapcis 直接来绘制寄宿图。通过继承 UIView 并实现 - drawRect：方法来实现自定义绘制。 在默认的情况下 - drawRect：方法是没有实现的，因为对于UIView来说寄宿图不是必须的，而且调用这个方法后系统就会为视图分配一个寄宿图，这个寄宿图的像素尺寸就是视图的尺寸大小乘以 contentsSacle 的值。该方法的调用会消耗一定的 CPU 资源，对性能造成一定的损耗，所以在没有实现自定义绘制的时候就不要去调用该方法。 在实现了- drawRect：方法后系统就会自动绘制寄宿图显示到屏幕上。但是有的时候我们需要重新绘制一个寄宿图，当然重绘也是在- drawRect：方法中来完成的，但是当添加了绘制代码后运行起来发现没有任何的效果。其实这里我们需要去手动的调用另一个方法- setNeedDisplay：，调用该方法后系统会自动调用- drawRect：方法进行重绘，为什么会这样呢？这是因为- drawRect：方法默认只会调用一次，我们重绘的时候就不回再次调用了，这个时候我们就需要调用- setNeedDisplay：来让系统自动调用- drawRect：方法来进行重绘。当然这是在 UIView 中绘制寄宿图，其实也是使用 CALayer 来完成的绘制工作，和保存绘制好的寄宿图。 我们也可以在 CALayer 中直接绘制寄宿图。CALayer 有一个可选的 delegate 属性，实现了 CALayerDelegate的协议，该协议是一个非正式协议，只需要在需要绘制的时候调用相对应的方法后 CALayer 就会自动去完成剩下的工作。当 CALayer 被绘制的时候首先会调用下面的这个代理方法，来请求获取一个寄宿图来显示： 1- (void)displayLayer:(CALayerCALayer *)layer; 在这个代理方法中我们可以给它一个已经绘制好的寄宿图。如果没有实现该方法那么 CALayer 就会继续调用下面这个方法： 1- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx; 在这个方法调用后这个方法里会生成一个空的寄宿图 layer 和一个 Core Graphics 的绘制寄宿图的上下文环境 ctx。在这个方法中我们就可以做一些绘制的工作。但是这里我们还需要显示的去调用- display方法我们绘制的寄宿图才会显示在屏幕上，这里和 UIView 的不同是当图层显示在屏幕上的时候 CALayer 不回自动重绘该内容，重绘内容是需要开发者自己去调用的。在 CALayer 中绘制寄宿的的时候超出边界的图是不回被绘制出来的。 其实在平时自定义绘制控件的时候我们一般都是不会使用 CALayer 的 delegate 去绘制控件的，一般都是在 UIView 中调用 - drawRect：方法进行绘制，UIView 会自动的把图层的代理设置为 self ，并且提供- displayLayer ：的实现，完成所有的绘制，并且在需要重绘的时候调用- display方法。 如下演示一下如何使用 CALayer 来绘制寄宿图： 1234567891011121314151617181920212223242526272829303132333435363738#import &quot;ViewController.h&quot;@interface ViewController () &lt;CALayerDelegate&gt;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; CALayer *layer = [CALayer layer]; layer.frame = CGRectMake(50, 50, 100, 100); layer.backgroundColor = [UIColor orangeColor].CGColor; layer.delegate = self; layer.contentsScale = [UIScreen mainScreen].scale; [self.view.layer addSublayer:layer]; [layer display];&#125;- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx &#123; CGContextSetLineWidth(ctx, 10.0); CGContextSetFillColorWithColor(ctx, [UIColor redColor].CGColor); CGMutablePathRef path = CGPathCreateMutable(); CGPathMoveToPoint(path, &amp;CGAffineTransformIdentity, 0, 0); CGPathAddLineToPoint(path, &amp;CGAffineTransformIdentity, 100, 100); CGPathAddLineToPoint(path, &amp;CGAffineTransformIdentity, 20, 80); CGPathCloseSubpath(path); CGContextAddPath(ctx, path); CGContextFillPath(ctx); &#125;@end 效果如下：","categories":[],"tags":[{"name":"图层","slug":"图层","permalink":"Aaronzjp.cn/tags/图层/"},{"name":"CALayer","slug":"CALayer","permalink":"Aaronzjp.cn/tags/CALayer/"},{"name":"Core Animation","slug":"Core-Animation","permalink":"Aaronzjp.cn/tags/Core-Animation/"}]},{"title":"方法调配技术（method swizzling）","slug":"Method-Swizzling","date":"2016-09-19T09:33:52.000Z","updated":"2017-07-27T02:55:04.000Z","comments":true,"path":"2016/09/19/Method-Swizzling/","link":"","permalink":"Aaronzjp.cn/2016/09/19/Method-Swizzling/","excerpt":"​ 在前面的关于runtime中已经说过OC运行时语言，在其编译的时候就会把OC中的消息转换成一个类似于如下： id objc_msgSend ( id self, SEL cmd, ... );结构的C语言函数，在程序运行的时候程序就会根据id所对应的类，以及传入的SEL选择子在该类的方法列表中去查找相对应的方法，并执行。利用这一特点，我们可以在运行期去改变选择子名称相对应的方法，这样我们既不需要查看到源代码，又没有必要去重写子类来覆写方法就能改变类本身的功能。这样一来新功能就会在类的所有实例中表现出来，而不仅限于那些重写子类的实例。这种方案就叫做“方法调配”（method swizzling）。","text":"​ 在前面的关于runtime中已经说过OC运行时语言，在其编译的时候就会把OC中的消息转换成一个类似于如下： id objc_msgSend ( id self, SEL cmd, ... );结构的C语言函数，在程序运行的时候程序就会根据id所对应的类，以及传入的SEL选择子在该类的方法列表中去查找相对应的方法，并执行。利用这一特点，我们可以在运行期去改变选择子名称相对应的方法，这样我们既不需要查看到源代码，又没有必要去重写子类来覆写方法就能改变类本身的功能。这样一来新功能就会在类的所有实例中表现出来，而不仅限于那些重写子类的实例。这种方案就叫做“方法调配”（method swizzling）。 ​ 类方法列表会把选择子的名称映射到相关的方法列表上，使得动态消息派发系统能够通过查找方法列表找到相对应的方法并调用。这些方法均以指针的形式表示，并存储在类的方法列表（objc_method_list）中，该指针就是IMP。 IMP的原型如下： id (*IMP)(id, SEL,...); 实现方法交换的实现方法如下： void method_exchangeImplementations(Method m1,Method m2) 这个函数有两个参数，其中这两个参数就是待交换的两个方法。 而方法的实现则可以通过以下这个方法来获得： Method class_getInstanceMethod(Class class,SEL aSelector) 此函数会根据给定的参数的类，和选择子去到方法列表中取出相应的方法。 下面用一个例子🌰来验证下： NSSrting中有两个方法，分别是lowercaseString和uppercaseString其作用时将英文字符串分别转换成小写和大写。现在用上面介绍的方法来让这两个方法交换。 12345Method originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString));Method swappedMethod = class_getInstanceMethod([NSString class], @selector(uppercaseString));method_exchangeImplementions(originalMethod, swappedMethod); ​ 实际上这样直接交换两个方法的意义基本不大，因为他们都已经被实现得很好了，这样交换后反而引起混淆。一般会编写一个新的方法，在新的方法中实现一些附加的功能，再调用原有的实现。如下： 1234567891011- (NSString *)zjp_myLowercaseString &#123; NSString *lowercase = [self zjp_myLowercaseString] NSLog(@&quot;%@ =&gt; %@&quot;,self, lowercase); return lowercase;&#125;Method originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString));Method swappedMethod = class_getInstanceMethod([NSString class], @selector(zjp_myLowercaseString));method_exchangeImplementions(originalMethod, swappedMethod); 这样交换方法后，我们在调用这个lowercaseString时就回附加的完成我们向里面添加的方法了。会打印出被转换前和转换后的字符串。通过这样的方法我们就可以为我们不知道具体实现的方法增加日志输出的功能以便我们的程序调试。不过除了这样用以为其实还有一些好用的功能，你懂的。。。。这样后面有机会再说。","categories":[],"tags":[{"name":"runtime","slug":"runtime","permalink":"Aaronzjp.cn/tags/runtime/"}]},{"title":"runtime-消息转发机制（message forwarding）","slug":"Message-Forwarding","date":"2016-09-13T03:48:39.000Z","updated":"2017-07-27T02:55:08.000Z","comments":true,"path":"2016/09/13/Message-Forwarding/","link":"","permalink":"Aaronzjp.cn/2016/09/13/Message-Forwarding/","excerpt":"​ 上次在发送消息objc_msgSend中提到了，如果在当前的类的方法列表中如果找不到对应的选择子的方法就会执行消息转发（message forwarding），在消息的转发过程中我们就可以在程序中告诉程序应该怎样去处理这样未知的消息，可以在消息的转发过程中设置挂钩，用来执行预定的逻辑处理方式，来做到当程序中的某个类找不到对应的方法时不至于导致程序的崩溃。 ​ 其中消息转发机制详细的来划分一共分为3个部分： 动态方法解析 备援接收者 完整的消息转发","text":"​ 上次在发送消息objc_msgSend中提到了，如果在当前的类的方法列表中如果找不到对应的选择子的方法就会执行消息转发（message forwarding），在消息的转发过程中我们就可以在程序中告诉程序应该怎样去处理这样未知的消息，可以在消息的转发过程中设置挂钩，用来执行预定的逻辑处理方式，来做到当程序中的某个类找不到对应的方法时不至于导致程序的崩溃。 ​ 其中消息转发机制详细的来划分一共分为3个部分： 动态方法解析 备援接收者 完整的消息转发 动态方法解析​ 对象在收到这条无法做出响应的消息后，首先会调用所属类的如下的方法： + (BOOL)resolveInstanceMethod:(SEL)sel 当然如果这个未实现的方法不是一个实例方法，而是类方法，那么会有一个与之相对应的方法来处理： + (BOOL)resolveClassMethod:(SEL)sel 该方法的这个参数SEL就是那个未知的选择子，返回值是一个Boolean类型，如果返回YES则表示这个类为其新增了一个实例方法来处理此选择子，如果返回NO则反之。使用此方法的前提是，相关处理函数的实现代码已经实现了，只是在运行的时候动态的将该实现方法动态的插入到类就好了。（所插入添加的方法是要用C函数实现的）。 具体使用例子🌰如下： 123456789101112+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; //首先判断这个未实现的方法是不是已经实现了等待被动态插入到类的方法，这里用test作为例子 //也可以同过把选择子字符串化通过判断字符串的匹配来做处理 //NSString *selectorString = NSStringFromSelector(sel) //if ([selectorString hasPrefix:@&quot;set&quot;]) &#123;&#125;.... if (aSEL == @selector(test)) &#123; class_addMethod([self class], sel, (IMP)(已经实现的那个函数), &quot;v@:&quot;); // 动态添加方法 return YES; // 返回YES，则不会转发&#125; return [super resolveInstanceMethod:aSEL]; // 不是需要动态添加的方法，按照父类处理&#125; 这里用到了class_addMethod函数，该函数可以向类中动态地添加方法，用以处理给定的选择子。其中第一个参数是被插入方法的类，第二个参数是选择子，第三个参数是函数指针，只想待插入添加到类的方法，而最后一个参数则表示待添加方法的”类型编码”（type encoding）。 备援接收者​ 如果在动态方法解析的那一步没有对此做相关的处理，那么接下来还是可以对此作出相应的处理的。在这步中主要做的就是能不能把这个未能解读到到方法转交给其他的消息接受者来处理。该步中会在如下的方法中进行这个步骤的处理： - (id)forwardingTargetForSelector:(SEL)aSelector 具体使用例子🌰如下： 1234567- (id)forwardingTargetForSelector:(SEL)aSelector&#123; if(aSelector == @selector(test))&#123; return testObject;//返回被转交的其它的消息接受者 &#125; return [super forwardingTargetForSelector:aSelector];// 不是需要动态添加的方法，按照父类处理&#125; 只要这个方法中最后返回的不适nil和self那么整个消息发送的过程就会被重启，当然接收消息的对象就回变成这里返回的这个类。如果这里还是没有及时的处理那么就回进入到消息转发的最后一步了，进行完整的消息转发。 完整的消息转发​ 到了这一步的时候就是最后挽救未解读消息的时候，在这步首先要创建NSInvocation对象，然后把未处理的消息的所有的细节都添加到此，此对象中包含了选择子，目标，以及参数。在这里我们同样的可以改变调用目标，使消息在新目标上调用，这个就和第二步中的操作其实是等效的了。我们还可以在消息触发前对消息进行其它的修改，比如改变消息内容，增加消息的参数，更改消息的目标。如果此消息不应该由本类来处理，也可以调用超类的同名方法来处理。如果最终还是未被处理，则还是会调用doseNotRecognizeSelector，以抛出异常，表示这条消息最终未能得到处理，导致程序崩溃。 整个消息转发流程图如下：","categories":[],"tags":[{"name":"runtime​","slug":"runtime​","permalink":"Aaronzjp.cn/tags/runtime​/"}]},{"title":"iOS发送消息","slug":"objc-msgSend","date":"2016-09-08T14:23:28.000Z","updated":"2017-07-27T02:53:39.000Z","comments":true,"path":"2016/09/08/objc-msgSend/","link":"","permalink":"Aaronzjp.cn/2016/09/08/objc-msgSend/","excerpt":"​ OC 语言中，对象调用方法我们称之为发送消息，或者叫做“传递消息”（pass a message）。消息具有“名称”（name）或“选择子”（selector），实际上就是方法名称，可以接受参数，也可以有返回值。在 OC 中我们是这样发送消息的，结构如下： id retrunValue = [someObject messageName:parameter];","text":"​ OC 语言中，对象调用方法我们称之为发送消息，或者叫做“传递消息”（pass a message）。消息具有“名称”（name）或“选择子”（selector），实际上就是方法名称，可以接受参数，也可以有返回值。在 OC 中我们是这样发送消息的，结构如下： id retrunValue = [someObject messageName:parameter]; OC中的消息传递就如同上面分解出来的结构一样。其中returnValue是返回值；someObject是接受者，即调用这个方法的对象；messageName:是选择子，即方法名称；parameter是参数，即调用方法的时候传入的参数。选择子（selector）与参数（parameter）合起来就是我们称为的“消息”。在程序编译期的时候，所有类似这样的消息最终都会被转换成一条标准的C语言函数内供程序调用，其结构如下： id objc_msgSend ( id self, SEL cmd, ... ); 这是一个参数个数可变的函数，能够接收多个的参数，其中第一个参数代表接收者，第二个参数代码选择子（SEL是选择子的类型），后面其他的消息就是发送消息中所传入的参数。 讲上面的那个OC的例子转换后的原型如下： id returnValue = objc_msgSend(someObject, @selector(messageName:),parameter); 在程序运行的时候objc_msgSend函数会根据接受者和选择子在相对应的类中查找方法，在对应类中有一个“方法列表”如果能找到对应的方法就执行此方法，若不能就沿着继承体向上父类继续查找，如果最终还是找不到相对应的方法就会执行“消息转发（message forwarding）”。 ​ 在调用方法的时候执行的步骤很多，但是objc_msgSend会将匹配到的方法列表中的方法缓存起来，其缓存在一个叫“快速映射表”里面。每一个类都有这样的一块缓存，在该类下次再执行相同的消息的时候就会优先从“快速映射表”中查找，而选择子就是查找方法时所用到的键。 objc_object, objc_class 以及 Ojbc_method在OC中，类，对象和方法其实都是一个C的结构体，这点我忙在objc/objc.h和runtime.h的文件中就能找到他们的定义。 1234567891011121314151617181920212223242526272829#if !OBJC_TYPES_DEFINED/// An opaque type that represents an Objective-C class.typedef struct objc_class *Class;/// Represents an instance of a class.struct objc_object &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;;/// A pointer to an instance of a class.typedef struct objc_object *id;#endifstruct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endiftypedef struct objc_method *Method; objc_object实际上是一个指向 Class 结构体类型的指针，指向对象的类，而 Class 中也有一个 isa 指针，指向了元类，元类中则存储了该类的方法列表objc_method_list。 objc_method_list 本质是一个有 objc_method 元素的可变长度的数组。一个 objc_method 结构体中有函数名，也就是SEL，有表示函数类型的字符串，以及函数的实现IMP。 objc_class就是前面说到的被objc_object中那个 isa 指针所指向的 Class 的类了。这个objc_class其实是一个结构体，其中在这个结构体中就包含了很多这个类的信息。其中就包括了上文中提到的储存这个类中当前方法的链表objc_method_list和储存这个类中被执行过的方法的缓存objc_cache等相关的信息。 总结那么总结来说当在代码中写下一个 OC 语言发送的消息后，那么这条 OC 语言的消息首先经过编译器，就会被编译器转换成这样类似结构的一条 C 语言函数： id objc_msgSend ( id self, SEL cmd, ... ); 举个例子🌰： objc_msgSend(dog,@selector(eat:),) 1.首先这个函数就会根据传入的dog这个类的 isa 指针找到他的 class即objc_class 2.在 class 中找到这个类的所有的相关信息 3.然后会首先的从 class 中的objc_cache去查找eat 方法 4.如果在objc_cache中没有找到 eat 这个方法，则说明 eat 方法没有被执行过，在缓存中没有 5.然后进一步到这个类中的objc_method_list中找和选择器中对应的方法eat 6.如果在 class 中没有找到相关的方法，则会继续向上查找，在父类（super_class）中去找相对应的方法 7.一旦找到这个方法，就去执行它的实现 IMP。 但是如果最终一直都没有找到 eat 这个相对应的方法呢？通常程序就会crash并抛出异常，但是在抛出异常前首先会执行消息转发，关于消息转发的相关学习和笔记我将会在下一篇的博客中整理出来。","categories":[],"tags":[{"name":"runtime","slug":"runtime","permalink":"Aaronzjp.cn/tags/runtime/"}]},{"title":"iOS-对象关联","slug":"Associated Object","date":"2016-08-18T10:35:51.000Z","updated":"2017-07-27T02:57:42.000Z","comments":true,"path":"2016/08/18/Associated Object/","link":"","permalink":"Aaronzjp.cn/2016/08/18/Associated Object/","excerpt":"关联对象就是给某个对象关联一些其他的对象，这些被关联的对象通过键（key）来区分管理。比如： 有一个Person类，Aaron是这个Person类的实例也就是对象。现在又增加了一个Car类，且有一个Audi的实例，我们需要给Aaron实例增加关联一辆Audi车。显然常规的做法是把Car类作为属性添加到Aaron中，但是在有的某些特殊的情况下我们无法对Aaron这个实例直接进行操作，也无法通过继承去操作，那么这个时候就可以用关联对象来解决这个问题了。","text":"关联对象就是给某个对象关联一些其他的对象，这些被关联的对象通过键（key）来区分管理。比如： 有一个Person类，Aaron是这个Person类的实例也就是对象。现在又增加了一个Car类，且有一个Audi的实例，我们需要给Aaron实例增加关联一辆Audi车。显然常规的做法是把Car类作为属性添加到Aaron中，但是在有的某些特殊的情况下我们无法对Aaron这个实例直接进行操作，也无法通过继承去操作，那么这个时候就可以用关联对象来解决这个问题了。 怎么关联对象如何关联对象？苹果早就为我们提供了关联对象的方法： //通过设置键（key）和关联对象以及被管理对象和内存关联类型来关联对象 void objc_setAssociatedObject(id object, void *key, id value, objc_AssociationPolicy policy) //从对应的键（key）获取相对应的关联对象 id objc_getAssociatedObject(id object, void *key) //移除指定对象的全部关联对象。一般不这样做，因为会移除所有的关联对象，如不需要的时候只要关联对象为nil即可 void objc_removeAssociatedObjects(id object) 参数说明： id object ：被关联的对象 const void *key ：被关联对象的键（key）此键是一个不透明的指针，即该指针指向的数据不局限于某种特定的类型 id value ： 关联的对象 objc_AssociationPolicy policy : 内存管理策略 objc_AssociationPolicy policy是一个枚举值，其中每一个枚举值对应了关联对象的存储策略，其中如果与其@property对应的策略如下： 关联类型 与之等效的@property属性 OBJC_ASSOCIATION_ASSIGN assign OBJC_ASSOCIATION_RETAIN_NONATOMIC nonatomic,retain OBJC_ASSOCIATION_COPY_NONATOMIC nonatomic,copy OBJC_ASSOCIATION_RETAIN retain OBJC_ASSOCIATION_COPY copy 关联对象的使用如在当前控制器需要弹出一个AlertView，但是在有很多这样的信息要处理的时候，代码就会显得很乱。但是我们在创建alertView的时候就把每个按钮点击后的事件写好就看起来简洁多了。 123456789101112131415161718192021222324252627282930313233343536373839404142#import &quot;ViewController.h&quot;#import &lt;objc/runtime.h&gt;static void *AlertViewTest = &quot;AlertViewTest&quot;;@interface ViewController () &lt;UIAlertViewDelegate&gt;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib.&#125;- (IBAction)alertViewClicked:(UIButton *)sender &#123; UIAlertView *alertView = [[UIAlertView alloc]initWithTitle:@&quot;AlertView弹出&quot; message:@&quot;对象关联的练习&quot; delegate:self cancelButtonTitle:@&quot;取消&quot; otherButtonTitles:@&quot;确定&quot;, nil]; //block,点击后处理的block void (^alertViewClicked) (NSInteger) = ^(NSInteger buttonIndex) &#123; NSLog(@&quot;你点击了第 %ld 个按钮&quot;,buttonIndex); &#125;; //把block关联到alertView中 objc_setAssociatedObject(alertView, AlertViewTest, alertViewClicked, OBJC_ASSOCIATION_COPY); [alertView show]; &#125;- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex &#123; //从alertView中获取被关联的block void (^alertViewClicked) (NSInteger) = objc_getAssociatedObject(alertView, AlertViewTest); //调用block，以来处理alertView按钮被点击后的响应 alertViewClicked(buttonIndex);&#125;@end 关联对象的介绍和用法大致就是这样，虽然使用起来很方便，好用。但是在项目中我觉得还是尽量避免使用这样的方法，因为对象关联频繁大量的使用会对项目后期的调试和维护造成困难，一旦这里出现问题就会很难再bug查找调试中找到问题所在。","categories":[],"tags":[{"name":"runtime","slug":"runtime","permalink":"Aaronzjp.cn/tags/runtime/"}]},{"title":"iOS网络编程NSURLConnection／NSURLSession","slug":"iOS-NetWork-Programming-NSURLConnectionAndNSURLSession","date":"2016-08-11T04:16:49.000Z","updated":"2017-07-27T02:56:59.000Z","comments":true,"path":"2016/08/11/iOS-NetWork-Programming-NSURLConnectionAndNSURLSession/","link":"","permalink":"Aaronzjp.cn/2016/08/11/iOS-NetWork-Programming-NSURLConnectionAndNSURLSession/","excerpt":"iOS网络编程是最基础常用的知识，可以说是从开始学习iOS的时候就应该要必备的基础知识。但是平常在项目中都使用比较成熟的第三方网络请求的框架（比如：AFNetworking）来替代了苹果官方所提供的网络请求API，对苹果提供的API相关的东西就逐渐的忽略了。为了理解其相关知识和原理，所以对这块知识复习一下，顺便整理成博客。","text":"iOS网络编程是最基础常用的知识，可以说是从开始学习iOS的时候就应该要必备的基础知识。但是平常在项目中都使用比较成熟的第三方网络请求的框架（比如：AFNetworking）来替代了苹果官方所提供的网络请求API，对苹果提供的API相关的东西就逐渐的忽略了。为了理解其相关知识和原理，所以对这块知识复习一下，顺便整理成博客。 目前在iOS的Foundation框架中提供的原生的网络访问类主要由两个，NSURLConnection 和 NSURLSession ，其中 NSURLConnection 是在2003年从 iOS 2.0+ 随着Safari的发布就发布了，NSURLSession 是从 iOS 7.0+ 出现的，其目的就是作为NSURLConnection 的替换，但是目前来说 NSURLConnection 还是不能完全的被替换的，NSURLSession 总的来说作为 NSURLConnection 的替换来说，对比 NSURLConnection 还是有很多优化的。NSURLSession 针对下载／上传，断点续传，后台下载等提供了专门的解决方案。 网络请求方法（GET／POST）网络请求这里就要说到 HTTP／HTTPS 网络协议，该协议规定了网络通信的一些标准，用于客户端和服务器之间的通信。后者 HTTPS 是基于 HTTP 协议进行一层加密后的网络协议，所传输的数据都是经过加密，相对于 HTTP 来说要安全。 使用 HTTP／HTTPS 协议客户端和服务器进行数据传输，首先客户端会向服务器发送请求，在服务器收到客户端的请求后再将客户端请求的数据返回给客户端。请求的方法有如下几种： 方法 描述 GET 从指定的资源请求数据。 POST 向指定的资源提交要被处理的数据。 HEAD 与 GET 相同，但只返回 HTTP 报头，不返回文档主体。 PUT 上传指定的 URI 表示。 DELETE 删除指定资源。 OPTIONS 返回服务器支持的 HTTP 方法。 CONNECT 把请求连接转换到透明的 TCP/IP 通道。 其中常用的就是 GET 和 POST 方法。 GET 请求是将数据拼接在 URL 之后发起的明文数据请求，也就是说该请求可以很明显的在 URL 中看到请求时发送给服务器的数据，而且 GET 请求时提交的数据是有长度限制的。所以 GET 请求一般用来单纯的从服务器取回数据，或者提交一些无关紧要的数据给服务器。其实当浏览网站的时候，我们在网址栏输入的网址就是一种 GET 请求，通过该请求从服务器取回网页数据，然后通过浏览器解析渲染然后显示在浏览器窗口。 POST 请求是将数据放在请求体中发出的请求，相对于 GET 请求来说更加安全，且 PSOT 请求提交的数据是没有长度限制的。POST 相对于 GET 请求更加适合用来向服务器提交数据。 NSURLConnection 使用步骤NSURLConnection 的一般使用步骤如下： 1.NSURL，网络请求地址，即待请求的网络资源的路径。（URL相关的可查看网络协议） 2.设置请求，NSURLRequest／NSMutableURLRequest。主要是用 NSMutableURLRequest ，因为 NSURLRequest 一旦初始化完成后就无法修改了。 3.连接到网络，发起网络请求。在苹果提供的 API 中已经对网络请求做了同步请求和异步请求的支持，同步请求会阻塞当前线程，而异步则不会，异步请求中请求的回调方式分为 Block 和 Delegate 两种方式。 4.接收请求到的数据 5.对请求到的数据进行解析处理等 NSURLConnection 的使用POST 同步请求：1234567891011121314151617181920//URL网络资源请求位置NSString *webLocation = @&quot;http://v.juhe.cn/todayOnhistory/queryEvent.php&quot;;NSString *parametersString = [NSString stringWithFormat:@&quot;date=%@&amp;key=%@&quot;,date,appKey];NSURL *url = [NSURL URLWithString:webLocation];//设置请求，请求地址、缓存方式、请求超时时间NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:60];//设置请求方法,默认为GET[request setHTTPMethod:@&quot;POST&quot;];//POST请求参数，设置在请求体中[request setHTTPBody:[parametersString dataUsingEncoding:NSUTF8StringEncoding]];//用于接收服务器的响应和请求错误。NSHTTPURLResponse *response;NSError * error = nil;//发送同步网络请求NSData *data = [NSURLConnection sendSynchronousRequest:request returningResponse:&amp;response error:&amp;error];//解析JSON数据，转换成Dictionary// NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil];NSString *string = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];[self showAlertWith:string]; 上面也提到了，网络请求API，NSURLConnection、NSURLSession等已经针对网络请求做了线程的处理。上面这段代码发起的是一个同步请求，也就是说该请求会阻塞住线程直到网络请求完成才会进一步的做其他的处理，所以同步请求是无法取消的。 GET 同步请求：GET 和 POST 请求其实在使用上步骤基本是一样的，在没有对 NSURLRequest／NSMutableURLRequest 请求方法做显示的设置的时候默认发起的网络请求是 GET 请求。 123456789101112131415//URL网络请求地址，以及请求提交的数据NSString *webLocation = [NSString stringWithFormat:@&quot;http://v.juhe.cn/todayOnhistory/queryEvent.php?date=%@&amp;key=%@&quot;,date,appKey];NSURL *url = [NSURL URLWithString:webLocation];//设置请求，请求地址、缓存方式、请求超时时间NSMutableURLRequest *request = [[NSMutableURLRequest alloc]initWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:60];//设置请求方式。默认就时GET请求，可以不要下面这段代码// [request setHTTPMethod:@&quot;GET&quot;];//用于接收服务器的响应和请求错误。NSHTTPURLResponse *response;NSError * error = nil;//发起请求NSData *data = [NSURLConnection sendSynchronousRequest:request returningResponse:&amp;response error:&amp;error];NSString *str = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];[self showAlertWith:str]; GET 异步请求 （Block回调方式）在上面的使用步骤中提到异步请求可以分为两种回调方式，Block 和 Delegate。这两种方式在 GET 和 POST 请求中使用基本都是一样的，所以就不分别在 GET 和 POST 中一一举例了，主要在回调方式上作出两个例子。 12345678910111213NSString *webLocation = [NSString stringWithFormat:@&quot;http://v.juhe.cn/todayOnhistory/queryEvent.php?date=%@&amp;key=%@&quot;,date,appKey]; NSURL *url = [NSURL URLWithString:webLocation];NSMutableURLRequest *request = [[NSMutableURLRequest alloc]initWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:60];// [request setHTTPMethod:@&quot;GET&quot;];// 发起网络请求，并通过block回调接收请求到的数据，并展示出来[NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) &#123; NSString *string = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]; __weak NetworkRequestViewController *weakSelf = self; [weakSelf showAlertWith:string];&#125;]; POST 异步请求（Delegate回调方式）Delegate 方式可以监控请求进度以及数据接收详情，所以 Delegate 方式也常常用来下载比较大的数据。数据较大的时候也可以通过一些方式支持断点续传等。这就是 Delegate 回调方式的好处吧。下面的例子将简单的实现下载一个短视频的功能，并可以暂停下载的功能。首先添加如下属性： 12345678@property (nonatomic,strong) NSMutableData *returnDataInfo;@property (nonatomic,strong) NSURLConnection *connection;@property (nonatomic,assign) NSUInteger totalSize;@property (nonatomic,copy) NSString *filmName;@property (nonatomic,assign) NSUInteger currentSize;@property (nonatomic,strong) NSFileHandle *handle;@property (weak, nonatomic) IBOutlet UIProgressView *progressView;@property (weak, nonatomic) IBOutlet UIButton *downloadButton; 在使用代理回调的时候首先要遵守两个协议，NSURLConnectionDelegate,NSURLConnectionDataDelegate。 123456789101112131415NSString *mp4WebLocation = @&quot;http://120.25.226.186:32812/resources/videos/minion_01.mp4&quot;;NSURL *url = [NSURL URLWithString:mp4WebLocation];//初始化一个请求NSMutableURLRequest *request = [[NSMutableURLRequest alloc]initWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:60]; //谁请求头参数，即下载文件开始结束的位置/*bytes=0-100下载文件数据的范围，-前面的数字是开始的位置，-后面的数字是结束的位置、不指定即为下载到完成*/NSString *range = [NSString stringWithFormat:@&quot;bytes=%zd-&quot;,self.currentSize];[request setValue:range forHTTPHeaderField:@&quot;Range&quot;]; //发送请求，并设置请求代理self.connection = [NSURLConnection connectionWithRequest:request delegate:self]; 在发送请求后主要在如下的三个代理方法中管理下载进度以及接收数据，存储数据的处理： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#pragma mark - Connection Delegate- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response &#123; if (connection == self.connection) &#123; //一定要做此判断，否则在暂停下载后再此下载时会出错，创建新的文件句柄，文件会损坏。 if (self.currentSize &gt; 0) &#123; return; &#125; else &#123; //获取将要下载的文件的总大小 self.totalSize = response.expectedContentLength; //获取要下载文件的文件名 self.filmName = response.suggestedFilename; //设置文件存储地址 NSString *path = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)lastObject]; NSString *fullPath = [path stringByAppendingPathComponent:_filmName]; NSLog(@&quot;%@&quot;,fullPath); //创建一个空文件在改地址，第一个参数是文件的地址，第二个参数是文件内容，第三个参数是文件属性 [[NSFileManager defaultManager]createFileAtPath:fullPath contents:nil attributes:nil]; //创建一个文件句柄 self.handle = [NSFileHandle fileHandleForWritingAtPath:fullPath]; &#125; &#125; else &#123; self.returnDataInfo = [[NSMutableData alloc]init]; NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)response; NSLog(@&quot;%ld&quot;,(long)httpResponse.statusCode); NSLog(@&quot;%@&quot;,httpResponse.allHeaderFields); &#125; &#125;- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data &#123; if (connection == self.connection) &#123; //移动文件句柄到文件末尾 [self.handle seekToEndOfFile]; //通过文件句柄写入文件 [self.handle writeData:data]; //计算当前下载到数据长度 self.currentSize += data.length; //当前下载文件的百分比 self.progressView.progress = (double) self.currentSize / self.totalSize; &#125; else &#123; [_returnDataInfo appendData:data]; &#125;&#125;- (void)connectionDidFinishLoading:(NSURLConnection *)connection &#123; //数据请求完毕 if (connection == self.connection) &#123; //关闭文件句柄 [self.handle closeFile]; //句柄设置为nil self.handle = nil; [self.downloadButton setSelected:NO]; [self.downloadButton setTitle:@&quot;下载完成&quot; forState:UIControlStateNormal]; &#125; else &#123; NSString *string = [[NSString alloc]initWithData:_returnDataInfo encoding:NSUTF8StringEncoding]; [self showAlertWith:string]; _returnDataInfo = nil; &#125;&#125;#pragma mark - Connection DataDelegate- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error &#123; NSLog(@&quot;数据请求失败!&quot;);&#125; NSURLSession 介绍前面也提到了 NSURLSession 是用来替换 NSURLConnection 的，那么 URLSession 肯定比 NSURLConnection 更加方便，强大，以及灵活。NSURLSession 对于 NSURLConnection 最大的改变就是可以灵活的单独配置给个 Session 的缓存，协议，cookie，以及证书策略。NSURL 主要可以分为三大块，NSURLSession、NSURLSessionConfiguration、NSURLSessionTask。 NSURLSeesionTask该类下有四个子类，分别是 NSURLSessionDataTask、NSURLSessionDownloadTask、NSURLSessionUploadTask、NSURLSessionStreamTask，通过名字我想也能大概知道这四个子类主要的区别和使用场景。 NSURLSessionDataTask，从服务器请求数据，并返回 NSData 类型的数据。主要用于GET、POST的网络请求 NSURLSessionDownloadTask，从服务器请求数据，并临时存储在内存中，当下载结束会返回一个临时的文件路径。主要用于从服务器下载文件，或者针对数据比较大的下载请求。 NSURLSessionUploadTask，上传数据到服务器，但是也会返回相应的数据，所以该类是继承于 NSURLSessionDataTask 的。主要用来上传文件到服务器，或者上传大量的数据到服务器端。 NSURLSessionStreamTask，建立一个TCP / IP连接的主机名和端口或一个网络服务对象。 NSURLSession 的使用NSURLSessionDataTask：首先通过 NSURLSession 创建一个 GET 请求： 12345678910111213141516171819202122232425262728//网络地址NSString *webLocation = [NSString stringWithFormat:@&quot;http://v.juhe.cn/todayOnhistory/queryEvent.php?date=%@&amp;key=%@&quot;,date,appKey];//创建网络地址URLNSURL *url = [NSURL URLWithString:webLocation];//创建请求NSURLRequest *request = [NSURLRequest requestWithURL:url];//获得 iOS 提供的共享 Session 单例NSURLSession *session = [NSURLSession sharedSession];//通过 request 创建任务NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; NSString *str = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]; [self showAlertWith:str]; &#125;);&#125;];//开始任务[task resume]; /* 也可以直接通过 URL 创建任务.....通过 URL 直接创建的请求，就相当于一个默认的 GET 请求，这只是一种快捷的方式*／// NSURLSessionDataTask *task2 = [session dataTaskWithURL:url completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;// dispatch_async(dispatch_get_main_queue(), ^&#123;// NSString *str = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];// [self showAlertWith:str];// &#125;);// &#125;];// [task2 resume]; 上面使用 NSURLSessionDataTask 创建了一个 GET 请求，POST 请求就和上面 NSURLConnection 中创建 POST 请求的方法一样，使用 request.HTTPMethod = @&quot;POST&quot;; 或者使用相应的 Set 方法也可以，设置请求体也是类似 [request setHTTPBody:[parametersString dataUsingEncoding:NSUTF8StringEncoding]];。NSURLSession 和 NSURLConnection 区别就是 NSURLSession 是没有同步请求的，NSURLSession 的请求都是异步执行的，当数据请求完毕回调更新 UI 的时候需要回到主线程进行进一步的操作。 NSURLSessionDownloadTask：NSURLSessionDownloadTask 和 NSURLConnection 一样，下载文件有两种回调方式，一种是 Block 一种是 Delegate 方式。这两种方式差别也和 NSURLConnection 的差别是差不多的，这里的 Block 方式无法监控下载进度，当下载完成的时候会直接返回一个下载完成的临时文件的路径。具体使用如下： 12345678910111213NSString *mp4WebLocation = @&quot;http://120.25.226.186:32812/resources/videos/minion_01.mp4&quot;;NSURL *url = [NSURL URLWithString:mp4WebLocation];NSURLRequest *request = [NSURLRequest requestWithURL:url];NSURLSession *session = [NSURLSession sharedSession];NSURLSessionDownloadTask *task = [session downloadTaskWithRequest:request completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; NSLog(@&quot;下载完成，地址为：%@&quot;,location); NSString *path = @&quot;/Users/aaron/Desktop&quot;; NSString *fileName = response.suggestedFilename; NSString *fullPath = [path stringByAppendingPathComponent:fileName]; NSFileManager *fileManager = [NSFileManager defaultManager]; [fileManager copyItemAtURL:location toURL:[NSURL fileURLWithPath:fullPath] error:nil];&#125;];[task resume]; Delegate 方式的回调则可以监控下载进度等，也可以进行断点续传。在 NSURLSession 使用断点续传就要比在 NSURLConnection 中要简单一点，只需要在暂停的时候保存暂停时返回的数据，在继续下载的时候传入暂停时已经下载的数据即可。 首先添加如下几个属性和全局变量并遵守NSURLSessionDelegate代理： 1234567891011@interface NetworkRequestViewController ()&lt;NSURLSessionDelegate&gt;@property (weak, nonatomic) IBOutlet UIProgressView *progressView2;@property (weak, nonatomic) IBOutlet UIButton *downloadButton2;@end@implementation NetworkRequestViewController &#123; NSURLSession *_seesion2; NSURLSessionDownloadTask *_task2; NSData *_data2; NSURLRequest *_request2;&#125; 发起数据下载，或者暂停下载以及继续下载： 12345678910111213141516171819if (sender.isSelected) &#123; [_task2 cancelByProducingResumeData:^(NSData * _Nullable resumeData) &#123; _data2 = resumeData; &#125;]; sender.selected = !sender.selected;&#125; else &#123; if (!_data2) &#123; NSString *mp4WebLocation = @&quot;http://120.25.226.186:32812/resources/videos/minion_01.mp4&quot;; NSURL *url = [NSURL URLWithString:mp4WebLocation]; _request2 = [NSURLRequest requestWithURL:url]; NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration]; _seesion2 = [NSURLSession sessionWithConfiguration:config delegate:self delegateQueue:[NSOperationQueue mainQueue]]; _task2 = [_seesion2 downloadTaskWithRequest:_request2]; &#125; else &#123; _task2 = [_seesion2 downloadTaskWithResumeData:_data2]; &#125; [_task2 resume]; sender.selected = !sender.selected;&#125; 在代理方法种监控下载进度，以及UI的更新 123456789101112- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location &#123; NSLog(@&quot;下载完成，地址为：%@&quot;,location); NSString *path = @&quot;/Users/aaron/Desktop&quot;; NSString *fileName = @&quot;小黄人.mp4&quot;; NSString *fullPath = [path stringByAppendingPathComponent:fileName]; NSFileManager *fileManager = [NSFileManager defaultManager]; [fileManager copyItemAtURL:location toURL:[NSURL fileURLWithPath:fullPath] error:nil];&#125;- (void)URLSession:(NSURLSession *)session downloadTask:(nonnull NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite &#123; self.progressView2.progress = (double)totalBytesWritten/totalBytesExpectedToWrite;&#125; NSURLSessionUploadTask：NSURLSessionUploadTask 的使用方法目前先记录下大概的使用方式，因为具体的我这里现在也没有可以用的 API 来使用以及测试。使用方式如下： 12345678910111213NSURL *URL = [NSURL URLWithString:@&quot;http://example.com/upload&quot;];NSURLRequest *request = [NSURLRequest requestWithURL:URL];NSData *data = ...;NSURLSession *session = [NSURLSession sharedSession];NSURLSessionUploadTask *uploadTask = [session uploadTaskWithRequest:request fromData:data completionHandler: ^(NSData *data, NSURLResponse *response, NSError *error) &#123; // ... &#125;];[uploadTask resume]; NSURLSessionConfigurationNSURLSessionConfiguration 对象是用来对 NSURLSession 进行初始化配置的，NSURLSessionConfiguration 是对以前 NSMutableURLRequest 所提供的网络请求的设置进行扩充，可以指定可用网络，cookie，安全性，缓存策略，甚至是使用自定义协议。 使用 NSURLSessionConfiguration 来初始化 NSURLSession 的时候，NSURLSession 的对象会把用来初始化的 NSURLSessionConfiguration 对象进行 copy 并保存到自己的一个只读属性中去，所以一旦 Session 初始化完成后，他的 Configuration 就是不能被修改的。 创建NSURLSessionConfiguration在常规的使用情况下，我们可以使用如下的三个类方法来创建一个 NSURLSessionConfiguration 对象，从这三个类方法中也可以看出基本上是满足平常的需求的。 + defualtSessionConfiguration; 返回一个常规的 configuration 对象。 + ephemeralSessionConfiguration; 返回一个预设的配置，该配置不会对缓存，Cookies，和证书进行缓存。 + backgroundSessionConfiguration:(NSString *)identifier; 返回一个后台配置，后台配置和其他不同的是，在后台配置下的 Session 可以在应用程序挂起，退出或者崩溃的情况下运行上传和下载任务。初始化时指定的标识符可以用来恢复对这个 Session 的操作。 基本配置NSURLSessionConfiguration 的配置属性太多了，下面会说一些常用的基本的配置，其他的属性详情可以查看苹果官方文档的描述 HTTPAdditionalHeaders 可以设置设置请求的数据头，如请求的内容类型，语言，用户代理和身份认证等。 allowsCellularAccess 是否允许使用蜂窝网进行数据传输，其默认的是 YES timeoutIntervalForRequest 和 timeoutIntervalForResource 分别用于指定请求超时的时间和资源超时的时间 HTTPMaximumConnectionsPerHost 用于指定链接到指定主机的最大数量，在MacOS中默认为6，iOS中默认为4 connectionProxyDictionary 指定 Session 连接中的代理服务器 sharedContainerIdentifier 指定一个共享容器标识符，该属性主要用于App Extension（如Weight）开发中 Session 共享的处理。 Cookie 策略 HTTPCookieStorage 存储了 session 所使用的 cookie。默认情况下会使用 NSHTTPCookieShorage 的 +sharedHTTPCookieStorage; 这个单例对象 HTTPCookieAcceptPolicy 决定了什么情况下 session 应该采用服务器的 cookie HTTPShouldSetCookies BOOL属性，用于指定什么时候请求应该使用 Session 存储的 cookie，即 HTTPCookieSorage 属性的值 安全策略 TLSMaximumSupportedProtocol 和 TLSMinimumSupportedProtocol 确定 session 是否支持 SSL 协议，设置 SSL 协议支持的版本 URLCredentialStorage 存储了 session 所使用的证书。默认情况下会使用 NSURLCredentialStorage 的 +sharedCredentialStorage; 这个单例对象 缓存策略 URLCache 设置 session 使用缓存。默认情况下会使用 NSURLCache 的 +sharedURLCache 这个单例对象，在 ephemeralSession 中默认是 nil ，在 backgroundSession 中默认是私密存储在内存中的，当 Session 失效的时候就会被销毁 requestCachePolicy 指定了一个请求的缓存响应应该在什么时候返回 自定义协议 protocolClasses 用来配置特定某个 session 所使用的自定义协议（该协议是 NSURLProtocol 的子类）的数组。 总结本篇文章就主要回顾一下这块内容，在常用开发中使用的一些关于网络请求的知识，当然这块肯定也是没有太详细的讲解，一些其他不常用的基本没有说到，如果想了解得更加的全面，还是去翻阅苹果官方文档。上面讲到的这些东西其实在苹果的官方文档中都有全面的讲解。","categories":[],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"Aaronzjp.cn/tags/网络编程/"}]},{"title":"iOS10 权限Crash问题","slug":"iOS10-CrashOfPermission","date":"2016-08-09T03:22:30.000Z","updated":"2017-07-27T02:56:10.000Z","comments":true,"path":"2016/08/09/iOS10-CrashOfPermission/","link":"","permalink":"Aaronzjp.cn/2016/08/09/iOS10-CrashOfPermission/","excerpt":"​ 手机升级iOS10beat版本后，公司项目在真机上测试出现了崩溃的现象。一打开App就Crash了，一开始还不太确定问题，以为是项目本身代码的问题。找了半天，后来居然在控制台的输出中找到了问题（控制台输出的内容太多了不好找啊😂）。 ​ 控制台输出的信息如下：","text":"​ 手机升级iOS10beat版本后，公司项目在真机上测试出现了崩溃的现象。一打开App就Crash了，一开始还不太确定问题，以为是项目本身代码的问题。找了半天，后来居然在控制台的输出中找到了问题（控制台输出的内容太多了不好找啊😂）。 ​ 控制台输出的信息如下： ​ This app has crashed because it attempted to access privacy-sensitive data without a usage description. The app’s Info.plist must contain an NSPhotoLibraryUsageDescription key with a string value explaining to the user how the app uses this data. ​ 大概的意思就是说你需要在项目文件的info.plist中去添加相关权限的请求描述。 ​ 解决方式： ​ 1.在项目文件中找到info.plist文件，用Xcode 打开。 ​ 2.在该文件中添加相对应的权限的key以及请求时的文字描述。 以通讯录权限为例： 12&lt;key&gt;Contacts Usage Description&lt;/key&gt;&lt;string&gt;此 App 需要您的同意才能获取联系人&lt;/string&gt; 需要注意的是key不能写错了，具体Crash的原因什么权限没有添加可以从控制台的输出信息中找到，找到后添加相关权限请求的key和描述就可以了。","categories":[],"tags":[{"name":"疑难杂症","slug":"疑难杂症","permalink":"Aaronzjp.cn/tags/疑难杂症/"}]},{"title":"UINavigationBar","slug":"UINavigationBar","date":"2016-05-31T10:31:30.000Z","updated":"2017-04-19T09:22:57.000Z","comments":true,"path":"2016/05/31/UINavigationBar/","link":"","permalink":"Aaronzjp.cn/2016/05/31/UINavigationBar/","excerpt":"NavigationBar 是在大多数App中很常见的一个控件，它总是显示在 App 窗口的顶部，其作用就是用来显示当前视图的层级。 NavigationBar 主要包含了这样几个部分，left(back) Button 、 CenterTitle 、 RightButton。如下图：","text":"NavigationBar 是在大多数App中很常见的一个控件，它总是显示在 App 窗口的顶部，其作用就是用来显示当前视图的层级。 NavigationBar 主要包含了这样几个部分，left(back) Button 、 CenterTitle 、 RightButton。如下图： 大多数时候 NavigationBar 都是使用在 UINavigationController 中的，由 NavigationController 来管理和显示 NavigationBar 的。当然 NavigationBar 也可以单独的使用。当在 NavigationController 中使用 NavigationBar 的时候，NavigationController 会自动管理 NavigationBar 的状态，这时候 NavigationBar 的 Title 默认为当前控制器的 Title 。也可以自己去手动的修改，在 NavigationController 中修改 NavigationBar 直接通过 NavigationController 上的属性 NavigationBar 就可以修改的。 NavigationBar的使用其实 NavigationBar 是很少单独使用的，但是不排除某些时候需要单独的去创建一个 NavigationBar 然后去自己管理。所以还是在这里写一下，以免到时候需要用到我又得到处去翻资料。 向 UINavigationBar 的栈顶压入新的 UINavigationItem 使用如下方法： 1- (void)pushNavigationItem:(UINavigationItem *)item animated:(BOOL)animated; 向 NavigationBar; 使 UINavigationBar 出栈，使用如下方法，该方法会返回出栈的 Item ： 1- (nullable UINavigationItem *)popNavigationItemAnimated:(BOOL)animated; 除了使用上面的方法添加 Items 以外还可以通过 items 属性以及如下方法添加 UINavigationItem 到 UINavigationBar： 1- (void)setItems:(nullable NSArray&lt;UINavigationItem *&gt; *)items animated:(BOOL)animated; NavigationBar代理： 12345678910111213141516//是否 push 该 Item- (BOOL)navigationBar:(UINavigationBar *)navigationBar shouldPushItem:(UINavigationItem *)item &#123; return YES;&#125;//Item push 后到回调- (void)navigationBar:(UINavigationBar *)navigationBar didPushItem:(UINavigationItem *)item &#123;&#125;//是否 pop 该 Item- (BOOL)navigationBar:(UINavigationBar *)navigationBar shouldPopItem:(UINavigationItem *)item &#123; return YES;&#125;//Item pop后到回调- (void)navigationBar:(UINavigationBar *)navigationBar didPopItem:(UINavigationItem *)item &#123;&#125; 通过 UINavigationBar 的代理可以很方便的管理 UINavigationBar 中 items 的进栈和出栈。 UINavigationBar 中 items 的进栈和出栈示意图： 自定义UINavigationBar的外观了解如下属性后，就可以通过这些属性来设置自己满意的 UINavigationBar 了。 barStyle： UINavigationBar 的样式，可供选择的有两种白色(UIBarStyleDefault)和黑色(UIBarStyleBlack) translucent： UINavigationBar 是否半透明，默认为 YES barTintColor： 通过此属性可以设置 UINavigationBar 的背景色 tintColor： 这里是修改 UINavigationBar 中 UINavigationItem 的颜色，包括 Item 中图片和标题的颜色。(该属性是 iOS 7.0 后新增的一个属性，凡是继承于 UIView 的试图都有该属性)。 titleTextAttributes：该属性可以设置标题的颜色，其实除了颜色意外还可以设置字体阴影、背景色等等和字符相关的。使用如下： 1_bar.titleTextAttributes = @&#123;NSForegroundColorAttributeName:[UIColor redColor]&#125;; 除了可以更改标题的颜色外还可以更改标题垂直位置，使用以下方法即可： 1- (void)setTitleVerticalPositionAdjustment:(CGFloat)adjustment forBarMetrics:(UIBarMetrics)barMetrics; 修改返回按钮图标通过这两个属性可以修改返回按钮的图标： backIndicatorImage 返回按钮图标 backIndicatorTransitionMaskImage 返回按钮图标遮罩 需要注意的是要同时设置这两个属性才能修改返回按钮的图标 NavigationBar颜色和标题如下图所示： 为 NavigationBar 设置背景图片以及阴影图片： 使用该方法可以为 UINavigationBar 设置背景图片，调整图片位置等等 1- (void)setBackgroundImage:(nullable UIImage *)backgroundImage forBarPosition:(UIBarPosition)barPosition barMetrics:(UIBarMetrics)barMetrics; 同样也可以提供一个可调整大小的图片来设置阴影图片，通过 shadowImage 这个属性即可，需要注意的是如果没有设置背景图片，那么阴影图片是不会生效的。之前就遇到一个需求要求隐藏 NavigationBar 下面的黑线，就可以通过设置一个空的图片来达到。 在 UINavigationBar 中层级关系如下图： 参考资料： UINavigationBar UINavigationItem","categories":[],"tags":[{"name":"UIKit","slug":"UIKit","permalink":"Aaronzjp.cn/tags/UIKit/"},{"name":"UINavigationBar","slug":"UINavigationBar","permalink":"Aaronzjp.cn/tags/UINavigationBar/"}]},{"title":"iOS - 多线程","slug":"Multiple-Thread","date":"2016-05-17T01:40:48.000Z","updated":"2017-07-27T02:54:50.000Z","comments":true,"path":"2016/05/17/Multiple-Thread/","link":"","permalink":"Aaronzjp.cn/2016/05/17/Multiple-Thread/","excerpt":"很多时候在我们的软件项目中我们都需要用到多线程，在iOS的项目中也不例外。多线程是编程中重要的一项技术，多线程又分为并发和串行，在此基础上又分为同步线程和异步线程。以下这几点很容易混淆，当然GCD中还有并发队列和串行队列，这个在下面的GCD中有提到。","text":"很多时候在我们的软件项目中我们都需要用到多线程，在iOS的项目中也不例外。多线程是编程中重要的一项技术，多线程又分为并发和串行，在此基础上又分为同步线程和异步线程。以下这几点很容易混淆，当然GCD中还有并发队列和串行队列，这个在下面的GCD中有提到。 同步线程 不回开启新的线程，在当前线程中执行任务，同时会阻塞当前线程，等到当前任务执行完毕后才会继续执行下一个任务。 异步线程 会开启新的线程，在新的线程中执行任务，所以并不会阻塞当前的线程。 NSThreadNSThread相对其他线程方案比较轻量级，能更方便直观的去控制线程对象，对其进行管理，但是缺点是需要自己去管理线程生命周期，线程同步。对系统也会有一定的开销。其实在实际的开发使用中该方案使用的很少，一般就是获取下当前线程和主线程的时候使用起来比较便利。 获取当前线程： 1NSThread *current = [NSThread currentThread]; 获取主线程： 1NSThread *main = [NSThread mainThread]; 创建并开启线程： 123NSThread *thread = [[[NSThreadalloc] initWithTarget:selfselector:@selector(run:)object:@&quot;mj&quot;] autorelease];//开启线程[thread start]; 创建并自动启动线程： 1[NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:@&quot;mj&quot;]; 通过NSObject基类的方法隐式创建线程： 1[self performSelectorInBackground:@selector(run:) withObject:@&quot;mj&quot;]; 通过以上NSbject方式创建线程的方式只能在OC中使用，在swift中苹果因为某些安全问题去掉了performSelector这一系列的方法 暂停当前线程： 1[NSThread sleepForTimeInterval:2]; 12NSDate *date = [NSDate dateWithTimeInterval:2 sinceDate:[NSDate date]];[NSThread sleepUntilDate:date]; 暂停当前线程到某个时间 1+ (void)sleepUntilDate:(NSDate *)date; 在指定线程执行操作直到完成： 12//在thread这个线程中执行self的run方法。YES是指该线程会会造成阻塞，run方法会在thread线程执行完毕后才会执行其他操作。[self performSelector:@selector(run) onThread:thread withObject:nil waitUntilDone:YES]; 在主线程执行操作直到完成： 1[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:YES]; 在当前线程执行操作： 1[self performSelector:@selector(run) withObject:nil]; 其他操作： 1234567891011//取消线程- (void)cancel;//启动线程- (void)start;//判断某个线程的状态的属性@property (readonly, getter=isExecuting) BOOL executing;@property (readonly, getter=isFinished) BOOL finished;@property (readonly, getter=isCancelled) BOOL cancelled;//设置和获取线程名字-(void)setName:(NSString *)n;-(NSString *)name; NSOpreation使用NSOperation和NSOperationQueue进行多线程开发，在线程的管理上就更加的方便，只要将一个NSOperation（实际开中需要使用其子类NSInvocationOperation、NSBlockOperation）放到NSOperationQueue这个队列中线程就会依次启动。 NSOperationQueue负责管理、执行所有的NSOperation，在这个过程中可以更加容易的管理线程总数和控制线程之间的依赖关系。 NSOperation有两个常用子类用于创建线程操作：NSInvocationOperation和NSBlockOperation，两种方式其实没有区别，但是是后者使用Block形式进行代码组织，使用起来会相对于前者更加方便灵活。 NSInvocationOperation：123NSInvocationOperation *invocationOperation =[[NSInvocationOperation alloc]initWithTarget:self selector:@selector(loadImage) object:nil];//开始执行[invocationOperation start]; NSBlockOperation：12345678910111213141516NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^()&#123; NSLog(@&quot;执行第1次操作，线程：%@&quot;, [NSThread currentThread]); &#125;];//添加一个新的线程[operation addExecutionBlock:^() &#123; NSLog(@&quot;又执行了1个新的操作，线程：%@&quot;, [NSThread currentThread]); &#125;];////添加一个新的线程[operation addExecutionBlock:^() &#123; NSLog(@&quot;又执行了1个新的操作，线程：%@&quot;, [NSThread currentThread]); &#125;];//开始执行[operation start];/*这里一共并发执行了三个线程*/ 在做完以上的操作后(不管是通过NSInvocationOperation还是通过NSBlockOperation)该线程启动执行，默认是在当前线程同步执行的，调用start方法后并不会去开启一个新的线程去执行操作。需要如下创建一个操作队列，将NSOperation放入操作队列中。 1234//创建操作队列NSOperationQueue *operationQueue=[[NSOperationQueue alloc]init];//注意添加到操作队后，队列会开启一个线程执行此操作[operationQueue addOperation:operation]; 取消线程操作： 1[operation cancel]; 线程结束后做一些操作： 123456//如果想在一个NSOperation执行完毕后做一些事情，就调用NSOperation的setCompletionBlock方法来设置想做的事情operation.completionBlock = ^() &#123; NSLog(@&quot;执行完毕&quot;); &#125;; 设置线程依赖，该方法可以用来处理在执行一个操作前需要用到上一个线程操作的结果的情景。比如有一个网络请求B，该网络需要等待网络请求A请求到的结果来作为网络请求B的参数，这个时候就可以谁知网络请求B线程依赖网络请求A线程，在A线程请求结束得到结果后再发起网络请求B。 12[operation addDependency:A];//operation线程在线程A执行完成后才会执行 GCD(Grand Central Dispatch)GCD(Grand Central Dispatch)是基于C语言开发的一套多线程开发机制，也是目前苹果官方推荐的多线程开发方法。GCD在三种多线程方式中抽象层次最高，是用起来也最简单，它基于C语言开发，并不像NSOperation是面向对象的开发，而是完全面向过程的。这种机制相比较于前面两种多线程开发方式最显著的优点就是它对于多核运算更加有效。 GCD中也有一个类似于NSOperationQueue的队列，GCD统一管理整个队列中的任务。但是GCD中的队列分为并行队列和串行队列两类： 串行队列：一次只执行一个线程，按照添加到队列的顺序依次执行。 并发队列：一次可以执行多个线程，线程的执行没有先后顺序。根据同步或者异步有不同的执行方式。放到并行队列的任务，GCD也会FIFO的取出来，但不同的是，他取出来一个就会放到别的线程，然后再取出来一个又放到另一个线程去执行，但是因为这个过程相当的短暂，所以可以忽略不计，看起来所有的任务都是一起执行的，但是还是得注意并发线程的数量，数量过大同样会对系统性能造成影响。 在GCD中还有一个特殊队列就是主队列，用来执行主线程上的操作任务。在需要更新UI的时候我们就会用到这个队列，我们用如下的方式来获取该队列。 123dispatch_async(dispatch_get_main_queue(), ^&#123; //主队列中需要运行的代码 &#125;); 并发队列的创建：并发队列同样是使用dispatch_queue_create()方法创建，只是最后一个参数指定为DISPATCH_QUEUE_CONCURRENT进行创建,如下： 1dispatch_queue_t concurrent = dispatch_queue_create(&quot;concurrentThread&quot;, DISPATCH_QUEUE_CONCURRENT); 在实际的使用中其实通常不会去创建一个新的并发队列，一般会用下面的方式去获取系统中的全局并发队列来执行任务。 全局并发队列的创建：在实际开发中通常不会重新创建一个全局并发队列而是使用dispatch_get_global_queue()方法取得一个全局的并发队列（如果有多个并发队列可以使用前者创建），其中在该全局并发队列中有四种优先级选项，一般我们使用默认（DISPATCH_QUEUE_PRIORITY_DEFAULT）的就好，四种优先级如下： 123456789/* * The global concurrent queues may still be identified by their priority, * which map to the following QOS classes: * * - DISPATCH_QUEUE_PRIORITY_HIGH: QOS_CLASS_USER_INITIATED * - DISPATCH_QUEUE_PRIORITY_DEFAULT: QOS_CLASS_DEFAULT * - DISPATCH_QUEUE_PRIORITY_LOW: QOS_CLASS_UTILITY * - DISPATCH_QUEUE_PRIORITY_BACKGROUND: QOS_CLASS_BACKGROUND */ 123456789101112 /*取得全局队列 第一个参数：线程优先级 第二个参数：预留参数，目前没有用，一般传入0 */ dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //创建多个线程用于填充图片 for (int i=0; i&lt;count; ++i) &#123; //异步执行队列任务 dispatch_async(globalQueue, ^&#123;//线程中需要执行的操作 &#125;); &#125; 并发数的控制并发太多的时候我们需要去控制并发数量，因为并发太多会带来很多问题，在实际开发中并发数不是越多越好的。因为并发数量太大对系统的开销，消耗会增大，同时对资源的访问也很难控制，容易导致死锁。我们使用dispatch_apply来控制最大并发数。 123456dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);//线程最大并发数为10size_t maxConcurrentThread = 10;dispatch_apply(maxConcurrentThread, globalQueue, ^(size_t i) &#123; //线程中需要的操作&#125;); 串行队列的创建：12345678910111213/*创建一个串行队列 第一个参数：队列名称 第二个参数：队列类型(也可以传NULL，因为默认的就是DISPATCH_QUEUE_SERIAL) */ dispatch_queue_t serialQueue = dispatch_queue_create(&quot;myThreadQueue1&quot;, DISPATCH_QUEUE_SERIAL);//注意queue对象不是指针类型 //创建多个线程用于填充图片 for (int i=0; i&lt;count; ++i) &#123; //异步执行队列任务 dispatch_async(serialQueue, ^&#123; //线程中需要的操作 &#125;); &#125; 异步与同步：上面创建的这些线程操作都是异步操作 dispatch_async()，如果要使用同步操作则是 dispatch_sync()。 同步执行(阻塞当前线程) 异步执行（不阻塞当前线程） 串行队列 当前线程，一个一个执行（FIFO） 其他线程，一个一个执行（FIFO） 并行队列 当前线程，一个一个执行（FIFO） 多个线程，一起执行 获取公共队列其实这个在上面也有提到，通过这几种方法可以获取到系统预设的公共队列: dispatch_get_current_queue：在iOS 6.0之后已经废弃，用于获取当前正在执行任务的队列，主要用于调试 dispatch_get_main_queue： 最常用的，用于获取应用主线程关联的串行调度队列 dispatch_get_global_queue：最常用的，用于获取应用全局共享的并发队列 后面这两个分别获取主线程的串行队列和获取应用全局共享的并发队列是非常常用的，当我们需要开一个线程并发地异步执行任务时，我们就会放到全局队列中。当我们在异步执行完成时，通常需要回到主线程更新UI显示。 队列的内存管理队列，即Dispatch Queue与其它类型的dispatch对象是引用计数的数据类型。当创建一个串行dispatch queue时,初始引用计数为1,我们可用dispatch_retain和dispatch_release函数来增加和减少引用计数。当引用计数为0时,系统会异步地销毁这个queue。对于系统预设提供的队列此方法无效，系统预设的队列不需要我们来管理，系统会自动管理该队列。 暂停/继续队列12dispatch_suspend(gqueue);dispatch_resume(gqueue); 队列组的使用很多时候我们需要进行多个操作，但是需要这些操作都完成以后才能回到主队列去更新UI，那么就可以用这样的方式使用队列组来完成这样的要求。 123456789101112131415161718192021dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); // 异步执行dispatch_async(queue, ^&#123; // 创建一个组 dispatch_group_t group = dispatch_group_create(); // 分别将任务添加到组中 dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; &#125;); dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; &#125;); // 等待组中的任务执行完毕,回到主线程执行block回调 dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; &#125;);&#125;); 延迟执行 使用NSObject提供的API同步执行，但是该类似方法在swift语言中已经废弃，原因的不安全。 1[self performSelector:@selector(myFunction) withObject:nil afterDelay:5.0]; 通过使用计时器来达到延迟执行的效果 使用dispatch_after方法异步延迟执行 123456CGFloat time = 5.0f;dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(time * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; // time秒后异步执行这里的代码... &#125;); 最后附上GCD中的简单使用的Demo GCDDemo","categories":[],"tags":[{"name":"iOS多线程","slug":"iOS多线程","permalink":"Aaronzjp.cn/tags/iOS多线程/"}]},{"title":"iOS开发-文件管理","slug":"File-Manager","date":"2016-04-28T04:53:47.000Z","updated":"2017-07-27T02:57:17.000Z","comments":true,"path":"2016/04/28/File-Manager/","link":"","permalink":"Aaronzjp.cn/2016/04/28/File-Manager/","excerpt":"​ 在 iOS 开发中，总是有需求我们需要在本地存储数据，但是存储数据的方式有很多，我们怎么样去决定用什么方式去存储数据？目前 iOS 开发中存储数据的方式有属性列表、对象归档、数据库（SQLite，Core Data）等，最终这些数据都会以某些文件等形式存入该App对应的沙盒（SandBox）目录中。","text":"​ 在 iOS 开发中，总是有需求我们需要在本地存储数据，但是存储数据的方式有很多，我们怎么样去决定用什么方式去存储数据？目前 iOS 开发中存储数据的方式有属性列表、对象归档、数据库（SQLite，Core Data）等，最终这些数据都会以某些文件等形式存入该App对应的沙盒（SandBox）目录中。 沙箱目录​ 每个 iOS 程序都有自己独立对应的存储空间（沙盒），沙盒目录是一种出于对数据安全策略的设计。沙盒设计的原理就是只能允许自己对应的应用访问，而不允许其他的应用直接访问沙盒，一般来说程序之间是不可以相互访问沙盒的。 ​ 当我们创建一个程序时，该程序沙盒中默认目录是这样的三个文件夹，分别是 Document、Library、tmp。其中Library下又有两个文件夹，分别是Preferences、Caches，他们的用途，使用场景如下： Document：该目录一般用于存储非常大的文件或者频繁更新的数据，一般数据库，大型持久化的数据都存放在此目录下。可以在此目录下添加子文件夹，能够通过 iTunes 或者 iCloud 备份。 Library：在该文件夹下有两个目录 Preferences：该目录一般用户存放应用程序的设置数据， Caches：这个目录和Document很相似，可以存放应用程序的数据，用来存储缓存文件 tmp：这是临时文件目录，用户可以访问此目录，该目录不能够通过 iTunes 或者 iCloud 备份。 各个文件夹的路径获取方式如下： 1234567891011121314NSString *homeString = NSHomeDirectory(); NSLog(@&quot;程序根目录：%@&quot;,homeString); NSString *DocumentPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]; NSLog(@&quot;Document目录:%@&quot;,DocumentPath); NSString *LibraryPath = [NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES) lastObject]; NSLog(@&quot;Library目录:%@&quot;,LibraryPath); NSString *CachesPath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject]; NSLog(@&quot;Caches目录:%@&quot;,CachesPath); NSString *tempPath = NSTemporaryDirectory(); NSLog(@&quot;temp目录：%@&quot;,tempPath); NSFileManagerNSFileManager这个类听名字也应该知道该类主要负责文件的管理，文件的增删查改，以及文件属性的管理。 使用NSFileManager来管理文件首先初始化一个NSFileManager的对象。 12// NSFileManager是一个单例对象，只实例化一次。NSFileManager *manager = [NSFileManager defaultManager]; 创建文件夹： 1234567891011NSString *docPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES) lastObject];NSString *directoryPath = [docPath StringByAppedingPathComponent:@&quot;Test&quot;];BOOL isSucces = [manager createDirectoryAtPath:directoryPath withIntermediateDirectories:YES attributes:nil error:nil];if (isSuccess) &#123; NSLog(@&quot;创建成功!&quot;);&#125; else &#123; NSLog(@&quot;创建失败！&quot;);&#125; 创建文件： 12345// 创建文件的保存路径NSString *filePath = [directoryPath stringByAppendingPathComponent:@&quot;userInfo.plist&quot;];//使用 NSFileManager 创建文件BOOL isSuccess = [manager createFileAtPath:filePath contents:nil attributes:nil]; 删除文件： 12// 使用NSFileManager 移除指定路径的文件BOOL isSuccess = [manager removeItemAtPath:directoryPath error:nil]; 获取文件属性： 12NSDictionary *fileAttribute = [manager attributesOfItemAtPath:subPathString error:nil];NSLog(@&quot;%@&quot;,fileAttribute); 写入文件： 将数据写入文件的方式主要是看具体的文件是什么，比如NSString、NSArray、NSDictionary、NSData等，都有将数据写入文件的方法，如下，基本是WriteToFile：atomically：格式的方法： 12345 NSMutableDictionary *info = [NSMutableDictionary dictionary];[info setObject:@&quot;2015年10月26日13:05:46&quot; forKey:@&quot;date&quot;];[info setObject:@&quot;TEST&quot; forKey:@&quot;content&quot;];// 写入数据BOOL isSuccess = [info writeToFile:filePath atomically:YES];","categories":[],"tags":[{"name":"数据存储","slug":"数据存储","permalink":"Aaronzjp.cn/tags/数据存储/"},{"name":"本地化","slug":"本地化","permalink":"Aaronzjp.cn/tags/本地化/"},{"name":"文件管理","slug":"文件管理","permalink":"Aaronzjp.cn/tags/文件管理/"}]},{"title":"iOS开发-SQLite数据库","slug":"SQLite-DataBase","date":"2016-04-20T13:00:25.000Z","updated":"2017-07-27T02:53:31.000Z","comments":true,"path":"2016/04/20/SQLite-DataBase/","link":"","permalink":"Aaronzjp.cn/2016/04/20/SQLite-DataBase/","excerpt":"​ 在 iOS 开发中我们经常会对数据进行存储，我们已知有如下几种数据本地化的方式： 属性列表 对象归档 SQLite数据库 Core Data","text":"​ 在 iOS 开发中我们经常会对数据进行存储，我们已知有如下几种数据本地化的方式： 属性列表 对象归档 SQLite数据库 Core Data ​ 其中，前两项属性列表以及归档都只适合轻量化的数据存储，对于比较少量的轻量级的数据我们可以使用属性列表以及对象归档的方式来进行存储。但是在需要存储大量的数据的时候我们就需要利用数据库来对数据进行存储。iOS开发中比较常用的数据库有 SQLite ，Core Data ，当然也有一些其它的第三方的框架实现对数据库的存储和操作，比如FMDB，Realm。 SQLite​ SQLite 是一款开源的数据库，主要采用 C 语言编写，具有可移植性强、可靠性高、小而容易使用的特点。SQLite 在使用的时候它与应用程序之间是共用的相同的进程，而不是单独的两个进程。SQLite 目前的主流版本是 SQLite3 。SQLite 是弱类型的数据库，其实基本上可以忽略数据类型，但是为了编程规范，以及后续方便的维护，建议还是在创建数据库表的时候明确定义各个字段的数据类型。 ​ SQLite支持如下常见的数据类型： 数据类型 和程序对应的数据类型 INTEGER 有符号的整数类型 REAl 浮点类型 TEXT 字符串类型，采用UTF-8UTF-16字符编码 BLOB 二进制大对象类型，能够存放任何二进制数据 除了上面这些数据类型的支持，还有一些兼容的数据类型。其中 SQLite 中是没有 Boolean 类型的，一般我们用 0 和 1 来代替，也没有日期和时间类型，一般这样的类型我们将它存储在 TEXT 、 REAL 和 INTEGER 类型中。 创建数据库要想熟练的使用 SQLite 数据库，首先还是需要熟悉一下 SQLite 数据库简单的增、删、改、查的 SQL语句 的，能简单的使用 SQL 的查询语句。 在 iOS中 我们要使用 SQLite 数据库首先要添加 SQLite 库到工程中，并引入头文件 sqlite3.h 要创建数据库，一般使用以下三个步骤 使用 sqlite3_open 函数打开数据库。 使用 sqlite3_exec 函数来创建数据库表。 使用 sqlite3_close 函数关闭数据库。 在我的 Demo 中，我首先创建了一个叫 SQLiteManager 的类，来专门管理数据库的操作，在- (BOOL)creatDB;方法中开始创建数据库表，并返回是否成功创建数据库表，如下： 123456789101112131415161718192021222324252627282930313233343536373839- (BOOL)creatDB &#123; //获取Documents文件路径 NSString *basePath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]; //拼接获取数据库的地址 dataBasePath = [[NSString alloc]initWithString:[basePath stringByAppendingPathComponent:DATA_BASE_NAME]]; NSLog(@&quot;数据库地址---&gt; %@&quot;,dataBasePath); //返回成功与否 BOOL isSuccess = YES; //打开数据库 //第一个参数是数据库完整的地址 //第二个参数是SQLite数据库对象 //SQLITE_OK 是SQLite中的常量宏定义，表示当前数据库操作的状态 if (sqlite3_open([dataBasePath UTF8String], &amp;db) == SQLITE_OK) &#123; char *erro; //数据库SQL语句，当Person表不存在的时候就创建，否则就不创建 NSString *createSQLite = [NSString stringWithFormat:@&quot;CREATE TABLE IF NOT EXISTS Person (name TEXT PRIMARY KEY, phone TEXT, age TEXT);&quot;]; //数据库建表函数 if (sqlite3_exec(db, [createSQLite UTF8String], NULL, NULL, &amp;erro) != SQLITE_OK) &#123; //关闭数据库，释放资源 sqlite3_close(db); NSAssert(NO, @&quot;数据库建表失败！&quot;); return isSuccess = NO; &#125; else &#123; sqlite3_close(db); NSLog(@&quot;数据库建表成功！&quot;); return isSuccess; &#125; &#125; else &#123; //注意只要执行了数据库打开函数的操作，不管数据库是否打开成功或失败，为了安全起见都需要关闭数据库 sqlite3_close(db); NSAssert(NO, @&quot;数据库打开失败!&quot;); return isSuccess = NO; &#125; return isSuccess;&#125; 上面这段代码中的 SQL 语句： 1NSString *createSQLite = [NSString stringWithFormat:@&quot;CREATE TABLE IF NOT EXISTS Person (name TEXT PRIMARY KEY, phone TEXT, age TEXT);&quot;]; 在创建数据库表的时候存入了三种数据，name、phone、age。其中 name 是主键。在 SQL 语句中，还可以加入字段约束，比如： 1NSString *sql = @&quot;create table if not exists stu (ID integer primary key, name text not null, gender text default &apos;男&apos;)&quot;; 以下是 SQLite 中常用的字段约束条件： NOT NULL 非空，确保某列不能有 NULL 值。 UNIQUE 唯一，确保某列中的所有值是不同的。 PRIMARY KEY 主键，唯一标识数据库表中的各行/记录。 CHECK 条件检查，确保一列中的所有值满足一定条件 DEFAULT 默认，当某列没有指定值时，为该列提供默认值 当写完上面代码后，只要运行程序我们就能在相对应的模拟器路径下找到 Person.sqlite 文件了，当然为了调试方便，看程序是否执行成功，最好还是在电脑上安装一个 SQLite 的工具，以便查看数据库。我推荐如下图这个工具吧，具体的使用还是看个人的习惯。（不要问我从哪下。。。我相信你们找得到😀） 存储数据（修改数据）修改数据时，会使用到的 SQL 语句有 insert 、update 、delete 、insert or replace 等。这次 Demo 中存储数据使用的是 insert or replace ，因为这里没有对数据进行很好的规划，没有对如果主键的数据是相同的情况作出处理，如果用 insert 的话，主键相同的时候，就会存储数据失败，修改数据的操作步骤都是一样的，只是 SQL 语句不一样。 修改数据的主要步骤如下： 使用 sqlite3_open 函数打开数据库 使用 sqlite3_prepare_v2 函数与处理 SQL 语句 使用 sqlite3_bind_text 函数来绑定参数 使用 sqlite3_step 函数执行 SQL 语句 查询结束后使用 sqlite3_ finalize 和 sqlite3_close 函数释放资源 Demo 中只是存储了简单的数据类型，因为在写这个 Demo 时我忽略了数据库类型 BLOB 我也不知道，图片，音频，视频，是怎么存储进去的😂。 但是，但是就在我写这个博客日记前，我算是知道怎么存储进去的了。如果要存储图片，音频，视频文件的话，需要先使用 NSData 类将文件转换成二进制，然后用 BLOB 类型存入 SQLite 数据库，这个具体的操作我会在 Demo 中更新。 存储数据的方法在 Demo 中我也用了一个专门的方法（- (BOOL)saveName:(NSString *)name AndPhone:(NSString *)phone WithAge:(NSString *)age ;）来存储数据，并返回一个 BOOL 值来确定是否储存成功。 1234567891011121314151617181920212223242526272829- (BOOL)saveName:(NSString *)name AndPhone:(NSString *)phone WithAge:(NSString *)age &#123; //返回成功与否 BOOL isSuccess = YES; if (sqlite3_open([dataBasePath UTF8String], &amp;db) != SQLITE_OK) &#123; sqlite3_close(db); isSuccess = NO; NSAssert(NO, @&quot;数据库打开失败&quot;); &#125; else &#123; NSString *insertSQLString = [NSString stringWithFormat:@&quot;INSERT OR REPLACE INTO Person (name, phone, age) VALUES (?, ?, ?)&quot;]; //预处理函数 int result = sqlite3_prepare_v2(db, [insertSQLString UTF8String], -1, &amp;statment, NULL); if (result == SQLITE_OK) &#123; //绑定数据 sqlite3_bind_text(statment, 1, [name UTF8String], -1, NULL); sqlite3_bind_text(statment, 2, [phone UTF8String], -1, NULL); sqlite3_bind_text(statment, 3, [age UTF8String], -1, NULL); //插入数据 if (sqlite3_step(statment) != SQLITE_DONE) &#123; isSuccess = NO; NSAssert(NO, @&quot;插入数据失败&quot;); &#125; else &#123; isSuccess = YES; &#125; &#125; &#125; sqlite3_finalize(statment); sqlite3_close(db); return isSuccess;&#125; 查询数据查询数据和修改数据的步骤基本是一样的，只是在第4步后多了一个字段数据提取的步骤。查询所有 Person 的代码如下： 1234567891011121314151617181920212223242526272829303132- (NSArray *)findAllPerson &#123; NSMutableArray *personArray = [NSMutableArray array]; if (sqlite3_open([dataBasePath UTF8String], &amp;db) != SQLITE_OK) &#123; sqlite3_close(db); NSAssert(NO, @&quot;数据库打开失败&quot;); &#125; else &#123; NSString *findAllPersonSQLString = @&quot;SELECT name,phone,age FROM Person&quot;; int result = sqlite3_prepare_v2(db, [findAllPersonSQLString UTF8String], -1, &amp;statment, NULL); if (result == SQLITE_OK) &#123; while (sqlite3_step(statment) == SQLITE_ROW) &#123; // 获取记录中的字段值 // 第一个参数是语句对象，第二个参数是字段的下标，从0开始 NSString *name = [NSString stringWithUTF8String:(const char *) sqlite3_column_text(statment, 0)]; NSString *phone = [NSString stringWithUTF8String:(const char *) sqlite3_column_text(statment, 1)]; NSString *age = [NSString stringWithUTF8String:(const char *) sqlite3_column_text(statment, 2)]; Person *person = [[Person alloc]init]; person.name = name; person.phone = phone; person.age = age; [personArray addObject:person]; &#125; &#125; sqlite3_finalize(statment); sqlite3_close(db); &#125; return [personArray copy];&#125; 这段代码中查询的是数据库表中所有的数据。按条件查询数据的方法和这个基本也是差不多的，区别在于查询所有数据没有查询条件，不需要绑定参数，遍历数据的时候使用的是 while 循环语句，而不是 if 条件判断语句。查找对应 phone 的 Person 如下： 123456789101112131415161718192021222324252627282930313233- (Person *)findPersonWithPhone:(NSString *)phone &#123; NSMutableArray *personArray = [NSMutableArray array]; if (sqlite3_open([dataBasePath UTF8String], &amp;db) != SQLITE_OK) &#123; sqlite3_close(db); NSAssert(NO, @&quot;数据库打开失败&quot;); &#125; else &#123; NSString *findAllPersonSQLString = @&quot;SELECT * FROM Person WHERE phone = ?&quot;; int result = sqlite3_prepare_v2(db, [findAllPersonSQLString UTF8String], -1, &amp;statment, NULL); if (result == SQLITE_OK) &#123; //和查询所有数据的区别就在这里，先绑定数据，再用if去过滤查询结果 //绑定数据 sqlite3_bind_text(statment,1,[phone UTF8String],-1,NULL) if (sqlite3_step(statment) == SQLITE_ROW) &#123; // 获取记录中的字段值 // 第一个参数是语句对象，第二个参数是字段的下标，从0开始 NSString *name = [NSString stringWithUTF8String:(const char *) sqlite3_column_text(statment, 0)]; NSString *phone = [NSString stringWithUTF8String:(const char *) sqlite3_column_text(statment, 1)]; NSString *age = [NSString stringWithUTF8String:(const char *) sqlite3_column_text(statment, 2)]; Person *person = [[Person alloc]init]; person.name = name; person.phone = phone; person.age = age; &#125; &#125; sqlite3_finalize(statment); sqlite3_close(db); &#125; return person;&#125; SQLite 的查询语句当然也是可以添加一些条件的，比如： 计算某字段记录的数量： SELECT COUNT （字段）FROM 表名； 示例🌰： 1NSString *findAllPersonCountSQLString = @&quot;SELECT COUNT (phone) FROM Person &quot;; 查询结果按顺序排列： SELECT * FROM 表名 ORDER BY 字段 ; 示例🌰： 查找Person并按照降序排列（ DESC 降序，ASC 升序） 1NSString *findAllPersonSQLStringByDesc = @&quot;SELECT * FROM Person ORDER BY phone DESC &quot;; 控制查询结果的数量： SELECT * FROM 表名 LIMIT 数值1, 数值2 ; 示例🌰： 跳过第0跳数据取10条数据 1NSString *findAllPersonSQLString = @&quot;SELECT * FROM Person LIMIT 0，10 &quot;; 其实还有更多的SQL查询语句，想要知道更多查询语句的可以在我前面给出的网站中自行学习。 删除数据123456789101112131415161718192021222324- (BOOL)deletePersonWithName:(NSString *)name &#123; BOOL isSucces = YES; if (sqlite3_open([dataBasePath UTF8String], &amp;db) != SQLITE_OK) &#123; sqlite3_close(db); return NO; NSAssert(NO, @&quot;数据库打开失败&quot;); &#125; else &#123; NSString *deletePersonSQLString = @&quot;DELETE FROM Person WHERE name =?&quot;; int result = sqlite3_prepare_v2(db, [deletePersonSQLString UTF8String], -1, &amp;statment, NULL); if (result == SQLITE_OK) &#123; sqlite3_bind_text(statment, 1, [name UTF8String], -1, NULL); if (sqlite3_step(statment) != SQLITE_DONE) &#123; return isSucces = NO; NSAssert(NO, @&quot;数据库删除失败&quot;); &#125; else &#123; NSLog(@&quot;数据删除成功&quot;); return isSucces = YES; &#125; &#125; &#125; sqlite3_finalize(statment); sqlite3_close(db); return isSucces;&#125; 关于SQLite更多的学习 Demo下载地址","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"Aaronzjp.cn/tags/数据库/"},{"name":"SQLite","slug":"SQLite","permalink":"Aaronzjp.cn/tags/SQLite/"}]},{"title":"KVO/KVC的使用","slug":"KVO:KVC","date":"2016-03-31T02:40:37.000Z","updated":"2017-07-27T02:55:23.000Z","comments":true,"path":"2016/03/31/KVO:KVC/","link":"","permalink":"Aaronzjp.cn/2016/03/31/KVO:KVC/","excerpt":"KVO（key-value observing）和KVC（Key-value coding）这两种模式其实是一种观察者模式的设计，可以让我们更加灵活的利用Objective-C语言的动态特性来编写代码。KVO和KVC其实是一套非正式的协议，是在其NSObject类中实现的，所以只有继承了该类就可以使用这一非正式的协议。","text":"KVO（key-value observing）和KVC（Key-value coding）这两种模式其实是一种观察者模式的设计，可以让我们更加灵活的利用Objective-C语言的动态特性来编写代码。KVO和KVC其实是一套非正式的协议，是在其NSObject类中实现的，所以只有继承了该类就可以使用这一非正式的协议。 KVC（Key-value coding）简介KVC（Key-value coding）从全称来看一般被翻译成了键值编码，使用KVC我们可以通过字符串去访问一个对象的实例变量。 KVC的使用使用KVC我们可以通过字符串去访问对象相对应的实例变量，其本质大概就是通过使用对应的字符串向对象发送消息。其中主要的方法如下： 1234- (id)valueForKey:(NSString *)key; - (void)setValue:(id)value forKey:(NSString *)key; - (id)valueForKeyPath:(NSString *)keyPath; - (void)setValue:(id)value forKeyPath:(NSString *)keyPath; 普通情况下我们都是使用对象的设置方法和取值方法去访问其属性，但是在KVC中我们可以通过这样的方式去访问对象的属性，最简单的KVC的使用可以通过这样的方式去访问属性： 12345678//被访问的属性@property (nonatomic,copy) NSString *name;//取值NSString *name = [object valueForKey:@&quot;name&quot;];//设值[object setValue:@&quot;Aaron&quot; forKey:!&quot;name&quot;]; 在KVC中除了可以访问对象的属性外，还可以访问对象的一些数据类型属性（如：int ，CGFloat，CGRect等数据类型和集合）。Foudation框架会对此进行封装和处理。 12345678//被访问的数据类型属性@property (nonatomic) CGFloat number;//取值CGFloat number = [object valueForKey@&quot;number&quot;];//设值[object setValue:@(20) forKey:@&quot;number&quot;] 在上面我们通过KVC可以使用字符串来访问对象的属性，这个字符串我们称之为”键” 键路径（Key Path）上面使用了键去访问对象的属性，同样的KVC也可以通过键路径的关系去访问对象。 假设有一个Person对象，该对象有一个dog属性，dog属性有sleep属性，我们可以通过键路径来访问这个sleep属性： 1[person valueForKeyPath:@&quot;dog.sleep&quot;] 通过建路径也可以用相对应的方法去设值。 KVO（key-value observing）简介KVO（key-value observing），其实是一种观察者模式，KVO是基于KVC的另一种实现的观察者模式，利用该模式可以监听想要观察的属性，当其发生变化时就会调用监视器指定的方法。 KVO的使用在KVO模式中比较重要的几个方法如下： 12345678910111213141516//添加对象的观察者- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context;//观察者需要实现的方法，当被观察者发生改变时，会调用此方法- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context&#123; NSLog(@&quot;old: %@&quot;, [change objectForKey:NSKeyValueChangeOldKey]); NSLog(@&quot;old: %@&quot;, [change objectForKey:NSKeyValueChangeNewKey]); NSLog(@&quot;context: %@&quot;, context);&#125;//移除观察者- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath 键值验证（KVV，Key-Value Validate）KVV也是KVC API中的一部分，这是用来验证属性值的API，保证了数据的一致性，KVC是不会做任何的验证，也不会自动的去调用KVV的方法，我们要想验证数据的一致性，只用通过KVV来实现我们自己的验证方法以便来保证他们的一致性。 我们一般通过调用此方法来验证数据： 1- (BOOL)validateValue:(inout id *)ioValue forKey:(NSString *)inKey error:(out NSError **)outError; 比如当我们需要验证Person类中name字段不为空，可以这样： 123456789NSString *name = @&quot;LiLei&quot;;NSString *key = @&quot;name&quot;;NSError *error = nil;if (Person validateValue:&amp;name forKey:key error:&amp;error) &#123; NSLog(@&quot;name is nil&quot;)&#125; else &#123; NSLog(@&quot;name is not nil&quot;)&#125; 当然我们也可以通过重写此方法，以便通过我们自己的逻辑来验证数据 ： 123456789- (BOOL)validateName:(NSString **)name error:(NSError * __autoreleasing *)outError&#123; if ((*name).length == 0) &#123; (*name) = @&quot;default name&quot;; return NO; &#125; return YES;&#125; 手动通知和自动通知KVO作为观察者，当我们观察的属性发生变化时就会发出通知告诉我们被观察者发生了改变。通过自动属性，建立键值观察，都属于自动键值观察。因为使用这种方法，只要设置键值，就会自动发出通知。而手动键值观察，不能使用自动化属性，需要自己写 setter/getter 方法，手动发送通知。 手动通知的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142//手动通知的实现@interface Person : NSObject&#123; NSString *name;&#125;- (NSString *)name;- (void)setName:(int)theName;@end@implementation Person- (id) init&#123; self = [super init]; if (nil != self) &#123; name = @&quot;Aaron&quot;; &#125; return self;&#125;- (NSString *)name&#123; return name;&#125;- (void)setName:(NSString *)theName&#123; //发送通知：键值即将改变 [self willChangeValueForKey:@&quot;name&quot;]; name = theName; //发送通知：键值已经修改 [self didChangeValueForKey:@&quot;name&quot;];&#125;/** * 当设置键值之后，通过此方法，决定是否发送通知 */+ (BOOL) automaticallyNotifiesObserversForKey:(NSString *)key&#123; //当 key 为 name时，手动发送通知 if ([key isEqualToString:@&quot;age&quot;]) &#123; return NO; &#125; //当为其他key时，自动发送通知 return [super automaticallyNotifiesObserversForKey:key];&#125;@end 属性依赖在某些特殊的情况下，一个类的几个属性之间有相互的关系，但是我们需要观察这些有相互关系的属性，这个时候我们就要使用属性依赖。比如一个Person类中有三个属性fullName，firstName，lastName，如果在不了解属性依赖之前，我们要观察名字的变化就只有添加三个观察者，但是在使用属性依赖的时候，我们只需要对其中一个属性添加观察，同时对观察的这个属性设置属性依赖后择业我们就可以观察名字的变化了。KVC中刚刚好就提供了这样的方法： 1+ (NSSet *)keyPathsForValuesAffectingValueForKey:(NSString *)key 添加属性依赖到被观察者上： 1234567/设置属性依赖：fullName属性依赖于firstName、lastName//如果观察name，当firstName、lastName发生变化时，观察者也会收到name变化通知+ (NSSet *)keyPathsForValuesAffectingFullName&#123; NSSet *set = [NSSet setWithObjects:@&quot;firstName&quot;, @&quot;lastName&quot;, nil]; return set;&#125; 在添加好属性依赖后，我们只需要像平常使用KVO观察一样的，对fullName添加观察者即可。","categories":[],"tags":[{"name":"KVO/KVC","slug":"KVO-KVC","permalink":"Aaronzjp.cn/tags/KVO-KVC/"},{"name":"设计模式","slug":"设计模式","permalink":"Aaronzjp.cn/tags/设计模式/"}]},{"title":"block的使用","slug":"Block","date":"2016-03-29T13:53:52.000Z","updated":"2017-04-20T07:46:36.000Z","comments":true,"path":"2016/03/29/Block/","link":"","permalink":"Aaronzjp.cn/2016/03/29/Block/","excerpt":"​ block（代码块）他的本质其实是和其他的变量类似的，不同的就是block（代码块中存储的是一个函数体，或者一段代码）。在使用block的时候可以像调用方法一样的，传入参数，然后得到返回值。 ^（脱字符）是block的语法标记，下面是block的声明：","text":"​ block（代码块）他的本质其实是和其他的变量类似的，不同的就是block（代码块中存储的是一个函数体，或者一段代码）。在使用block的时候可以像调用方法一样的，传入参数，然后得到返回值。 ^（脱字符）是block的语法标记，下面是block的声明： 下面就来声明一个block变量试试： 12345678//声明一个block变量int multiplier = 7;int (^myBlock)(int) = ^(int num) &#123; return num * multiplier;&#125;;//block变量可以像函数一样使用NSLog(@&quot;%d&quot;,myBlock(8)); block实际使用结合typedef使用​ 上面只是简单的说了block在声明方式，和block变量的声明和使用，block是一个很灵活好用的东西，block的使用也十分的广泛，block可以用做属性，可以用作函数的返回值，也可以作为函数的参数来传递使用。 ​ 其实block也可以结合typedef来使用，用typedef给我们的block起一个别名，这样在使用block的时候回更加方便，易读。 1typedef void (^ReturnTextBlock) (NSString *showText); 使用block回调传值​ 使用情景，有两个控制器（控制器一，控制器二）。在控制器二中输入一段文字，在返回到控制器一时，显示出来。 ​ 首先，新建工程并创建两个控制器类，如图： ​ 在控制器二的头文件中声明一个block属性，并声明一个回调方法： 1234567891011121314//给block定义一个别名typedef void (^ReturnTextBlock) (NSString *showText);@interface SecondViewController : UIViewController@property (nonatomic,copy) NSString *name;//声明一个block属性@property (nonatomic, copy) ReturnTextBlock returnTextBlock;//使用此方法回调，获取本控制器中输入的文字（也可以通过block属性来获取控制器中输入的文字）- (void)returnText:(ReturnTextBlock)block;@end ​ 在控制器二中，点击按钮回返回控制器一的时候我们将这个block属性赋值： 123456- (void)viewWillDisappear:(BOOL)animated &#123; if (self.returnTextBlock != nil) &#123; //给returnTextBlock赋值 self.returnTextBlock(self.inputTF.text); &#125;&#125; ​ 然后在回到控制器一的时候获取block中的值即可到达block传值的目的： 1234567891011121314- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender&#123; SecondViewController *tfVC = segue.destinationViewController; //通过回调方法获取控制器二block中的值 [tfVC returnText:^(NSString *showText) &#123; self.TestLabel.text = showText; &#125;]; //通过属性的方式获取控制器二block中的值// tfVC.returnTextBlock = ^(NSString *showText) &#123;// self.TestLabel.text = showText;// &#125;;&#125; block作为函数返回值​ 有时候，我们会把block作为函数的返回值来处理，用来提供给外部来调用： 12345678910111213141516//定义一个blocktypedef void (^TextBlock) (NSString *str);//把block作为函数的返回值- (TextBlock)returnAStringWithName &#123; TextBlock block = ^(NSString *str) &#123; NSLog(@&quot;他的名字叫%@&quot;,str); &#125;; return block;&#125;//调用返回值为block的方法 TextBlock block = [self returnAStringWithName]; NSString *a = @&quot;王八蛋&quot;; //使用返回的block block(a); ​ block的使用方式还有很多，后续会介绍更多更方便的block的使用方式。 BlockDemo","categories":[],"tags":[{"name":"block","slug":"block","permalink":"Aaronzjp.cn/tags/block/"}]},{"title":"App皮肤，更换皮肤思路","slug":"AppThemes","date":"2016-03-26T06:35:20.000Z","updated":"2017-07-27T02:58:38.000Z","comments":true,"path":"2016/03/26/AppThemes/","link":"","permalink":"Aaronzjp.cn/2016/03/26/AppThemes/","excerpt":"​ 最近遇到了一个需求，就是做App皮肤的换肤的功能，因为之前一直没有涉及到这方面的需求，所以刚刚拿到这个需求的时候我也不知道怎么做，后面通过查看相关的资料终于完成了这个需求。下面就是我对本次这个需求的一点想法和具体完成的方法。","text":"​ 最近遇到了一个需求，就是做App皮肤的换肤的功能，因为之前一直没有涉及到这方面的需求，所以刚刚拿到这个需求的时候我也不知道怎么做，后面通过查看相关的资料终于完成了这个需求。下面就是我对本次这个需求的一点想法和具体完成的方法。 主题管理​ 首先想到主题是什么，就是App的皮肤，皮肤其实划分细一点这里就要考虑到App皮肤是否有布局的改变，有布局的改变的皮肤就需要针对皮肤做出对应的布局的约束，有布局改变的皮肤不在本次的讨论之中，因为现在还没有涉及到有布局变化的需求，这里只说下简单的皮肤的变更。App的皮肤其实就是UI界面的图片，和颜色的改变，那我们用什么来存储这些UI的皮肤图片和颜色呢？这里我们就需要一个皮肤管理器了，这个皮肤管理器的作用其实就是一个皮肤相关的资源管理器，皮肤其实重点在于资源，这是一个只关心皮肤相关资源的管理器，而且这个资源管理器又是只能整个App唯一的一个资源管理器，如果有多个的话那我们设置皮肤的时候使用哪一个呢？这样岂不是乱套了。所有只能有一个。所以这里就用单例来作为皮肤管理器比较好。 1234567891011121314+ (ThemeManager *)sharedeThemeManager&#123; if (!themeManager) &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken,^&#123; themeManager = [[super allocWithZone:NULL]init]; &#125;); &#125; return themeManager;&#125;+ (id)allocWithZone:(struct _NSZone *)zone &#123; return [ThemeManager sharedeThemeManager];&#125; 主题资源管理​ 主题管理器有了，下面就是具体的资源了。资源我直接使用的是本地资源化来管理皮肤资源： 其中颜色和文字描述也放在了对应的主题文件夹类，使用plist文件来进行储存。 每次获取主题的对应的相关资源时就会根据主题的主题名属性来获取主题的相关资源： @property (nonatomic,copy) NSString *themeName; 根据主题的名字来判断主题管理器去获取主题对应的资源的路径： 12345//通过主题名字来设置主题的路径- (NSString *)themePath &#123; NSString *themePath = [[[[NSBundle mainBundle]resourcePath]stringByAppendingPathComponent:THEME_BUNDLE_PATH]stringByAppendingPathComponent:self.themeName ? : DEFAULT_THEME]; return themePath;&#125; 通过这样的方法就可以让主题管理器通过主题的名字来获取对应主题的相关资源。其中图片的资源就可以直接通过上面的这个themePath路径来获取相对于的图片资源了。(下面的这三个方法就需要在.h文件中声明，暴露在外部，其他的UI类就能通过下面的这三个方法获取对应主题的图片文件和颜色了)。 1234//获取的图片的方法的实现- (UIImage *)getImageFromThemeWithName:(NSString *)imageName &#123; return [UIImage imageWithContentsOfFile:[self.themePath stringByAppendingPathComponent:imageName]];&#125; 主题相关的颜色因为是从对应主题文件夹的plist文件去读取，所以这里最好设计一个获取对应主题的plist文件的路径方法并把plist文件通过字典的方式读取出来，返回一个字典： 1234567//主题的颜色文字的配置- (NSDictionary *)themeConfig &#123; if (!_themeConfig) &#123; _themeConfig = [NSDictionary dictionaryWithContentsOfFile:[self.themePath stringByAppendingPathComponent:THEME_CONFIG]]; &#125; return _themeConfig;&#125; 主题文字和颜色在plist文件中是这样存储的： 这里的颜色是按照16进制的方式存储的，在iOS中使用这个存储的方式的颜色的时候就需要把改颜色转换层RGB的颜色，这个这里就不细说了，百度iOS16进制颜色转换就能找到转换方法。 下面就是对应的文件和颜色的读取方式，通过获取这个plist文件的内容返回的字典，从这个字典中去获取对应主题的相关的文字和颜色： 1234567891011//获取颜色的方法的实现- (UIColor *)getColorFromThemeWithColorNmae:(NSString *)colorName &#123; NSString *color = self.themeConfig[@&quot;Color&quot;][colorName]; return [UIColor colorWithHexString:color];&#125;//获取文字的方法的实现- (NSString *)getStringFromThemeWithStringName:(NSString *)stringNmae &#123; NSString *string = self.themeConfig[@&quot;Text&quot;][stringNmae]; return string;&#125; 皮肤变更通知​ 当App的主题皮肤的名字被改变的时候，加载新的页面的时候App的皮肤也就会根据，皮肤管理器的这个themeName的变化切换对应的皮肤。对于没有显示在当前屏幕的页面皮肤就会根据主题名自动变化。但是在已经加载的页面（一般都是切换主题按钮的这个页面），主题对应的变化就需要设置一个监听器，或者通知时间去键盘主题的变化了，这样才能在主题变化的时候，及时的变更已加载页面的主题，让界面重新从主题管理器获取资源再加载。因为这类通知一般属于全局性的所以这里最好使用通知NSNotification ​ 所以这里在主题名字themeName发生变化的时候就要调用[NSNotificaitonCenter defaultCenter]的postNotificationName:object:发出通知，而在各个涉及到主题更换的ViewController中使用addObserver:selector:name:object:监听通知事件，并响应通知做出皮肤变更通知的响应处理方式。 总结​ 其实整个主题管理器就相当于一个资源管理器，这里针对这个资源管理器进行了封装。通过调用外部的获取图片资源和颜色以及文字的接口，就可以返回对应主题的文字，颜色和图片。其实大部分的自定义控件和UI模块都是如此，将内部的实现封装起来，按照这个管理器的规则来使用和调用接口，就可以简单的使用这个管理器来管理皮肤，设计大都是相似的，多一个中间层，就会让程序变得更加灵活易用。 项目Demo地址","categories":[],"tags":[{"name":"思路","slug":"思路","permalink":"Aaronzjp.cn/tags/思路/"}]},{"title":"使用Masonry布局UI","slug":"UseMasonryLayoutUI","date":"2016-03-20T08:29:23.000Z","updated":"2017-07-27T02:52:46.000Z","comments":true,"path":"2016/03/20/UseMasonryLayoutUI/","link":"","permalink":"Aaronzjp.cn/2016/03/20/UseMasonryLayoutUI/","excerpt":"Masonry 是一个针对 AutoLayout 的封装的轻量级的布局框架，拥有自己的语法描述，通过链式语法封装 AutoLayout，大大的提高了代码的可读性和简洁度。","text":"Masonry 是一个针对 AutoLayout 的封装的轻量级的布局框架，拥有自己的语法描述，通过链式语法封装 AutoLayout，大大的提高了代码的可读性和简洁度。 AutoLayout介绍iOS UI布局目前有很多种方式，从最开始的只需要简单的计算下相对位置，到 AutoresizingMask 布局，再到 AutoLayout 布局。从这些 UI 布局到方式就可以看出 iOS 设备屏幕尺寸的改变，为了兼容多个屏幕尺寸苹果推出了上面提到的这些 UI 布局技术，目前使用最多的就是 AutoLayout 布局。在 Storyboard 上使用还是比较直接的，设置约束后就会立即生效，所见即所得。但是 Storyboard 在相对复杂的 UI 布局上就显得不是那么好用了，还是得使用代码进行布局。那么使用代码布局的时候问题就来了，使用过都知道简直就是难以忍受，可以说这样的代码简直是啰嗦。 不信看一下： 12345678910111213141516171819 UIView *redView = [[UIView alloc]init]; redView.backgroundColor = [UIColor redColor]; //给每个视图代码添加NSLayoutConstraint约束的时候要关闭这个属性 redView.translatesAutoresizingMaskIntoConstraints = NO; //在给视图添加约束的时候要先将视图添加到父视图，不然会报错 [self.view addSubview:redView]; //相对于父控件的左边距 NSLayoutConstraint *redViewLeft = [NSLayoutConstraint constraintWithItem:redView attribute:NSLayoutAttributeLeft relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeLeft multiplier:1.0 constant:20.0]; [self.view addConstraint:redViewLeft]; //相对于父控件的下边距 NSLayoutConstraint *redViewBottom = [NSLayoutConstraint constraintWithItem:redView attribute:NSLayoutAttributeBottom relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeBottom multiplier:1.0 constant:-20.0]; [self.view addConstraint:redViewBottom]; //自身宽度约束（这里是直接添加宽度约束） NSLayoutConstraint *redViewWidth = [NSLayoutConstraint constraintWithItem:redView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:kNilOptions multiplier:1.0 constant:50]; [redView addConstraint:redViewWidth]; //自身高度约束（这里是直接添加高度约束） NSLayoutConstraint *redViewHeight = [NSLayoutConstraint constraintWithItem:redView attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:nil attribute:kNilOptions multiplier:1.0 constant:50]; [redView addConstraint:redViewHeight]; 是不是觉得这样来布局 UI 代码很啰嗦，也很难读？这仅仅是对一个 View 的布局，想象一下一个复杂的控制器，里面有多个的视图。。。 再来对比下 Masonry： 12345678910UIView *redView = [[UIView alloc]init];redView.backgroundColor = [UIColor redColor];[self.view addSubview:redView];//添加约束[redView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(self.view).offset(20); make.bottom.equalTo(self.view).offset(-20); make.size.mas_equalTo(CGSizeMake(50, 50)); &#125;]; 没错，上面那么大一堆代码，在 Masonry 上只需要这么几句。 Masonry的使用首先在 Masonry 有三个方法用来修改约束的，通过名字大概也能了解到这三个方法的用处。 123456//用来添加约束的，注意的是AutoLayout不能同时存在两条约束同时针对一个对象，会报错- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block;//用来更新约束，不存在相同约束针对同一个对象，相同的会被更新- (NSArray *)mas_updateConstraints:(void(^)(MASConstraintMaker *))block;//清除之前所有的约束，并更新现在添加的约束- (NSArray *)mas_remakeConstraints:(void(^)(MASConstraintMaker *make))block; equalTo 和 mas_equalTo 的区别： 这里 mas_equalTo 是对其中的参数做了一个BOX操作（装箱操作），看了下源码很长，具体的我也没看太懂，这个后面有时间仔细了解下。目前我在使用中的时候如果是相对于 View 的约束操作是使用 equalTo ，相对于直接的数值和结构体的约束是使用 mas_equalTo。 介绍完一些基本的使用方法后就来做一些实际操作。 例子1首先来居中显示一个红色 View： 12345678910111213UIView *redView = [[UIView alloc]init];redView.backgroundColor = [UIColor redColor];//添加约束前需要先把视图添加到superView上，否则会报错[self.view addSubview:redView];[redView mas_makeConstraints:^(MASConstraintMaker *make) &#123; //中心点等于self.view make.center.equalTo(self.view); //view的宽和高等于300 make.width.and.height.mas_equalTo(300); // 这一句和上面一句是等同的，也是设置view的宽和高的约束等于300 // make.width.and.height.equalTo(@300);&#125;]; 效果如下： 例子2在例子1的基础上创建两个视图，边距相互为10，且高相等，宽相等： 12345678910111213141516171819202122232425262728293031323334353637//首先添加这两个 View 到 redView 上UIView *view1 = [[UIView alloc]init];view1.backgroundColor = [UIColor purpleColor];[redView addSubview:view1];UIView *view2 = [[UIView alloc]init];view2.backgroundColor = [UIColor orangeColor];[redView addSubview:view2];//添加 View1 的约束[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123; //左边和顶部相对 redView 相距10 make.left.and.top.equalTo(redView).offset(10); //右边相对于 View2 的左边相距 10 make.right.equalTo(view2.mas_left).offset(-10); //中心点相对于 redView 中心Y轴对齐 make.centerY.equalTo(redView.mas_centerY); //底部相对于 redView 的底部相距10 make.bottom.equalTo(redView).offset(-10); //宽相对于 View2 的宽相等 make.width.equalTo(view2.mas_width);&#125;];[view2 mas_makeConstraints:^(MASConstraintMaker *make) &#123; //左边相对于 View1 的右边相距10 make.left.equalTo(view1.mas_right).offset(10); //右边相对于 redView 的右边相距10 make.right.equalTo(redView).offset(-10); //中心点相对于 redView 中心Y轴对齐 make.centerY.equalTo(redView.mas_centerY); //顶部相对于 redView 的边距为10 make.top.equalTo(redView).offset(10); //底部相对于 redView 的边距为10 make.bottom.equalTo(redView).offset(-10); //宽相对于 View1 的宽相等 make.width.equalTo(view1.mas_width);&#125;]; 效果如下：","categories":[],"tags":[{"name":"AutoLayout","slug":"AutoLayout","permalink":"Aaronzjp.cn/tags/AutoLayout/"}]},{"title":"代码实现AutoLayout布局","slug":"AutoLayout UI","date":"2016-03-06T15:00:17.000Z","updated":"2017-07-27T02:57:38.000Z","comments":true,"path":"2016/03/06/AutoLayout UI/","link":"","permalink":"Aaronzjp.cn/2016/03/06/AutoLayout UI/","excerpt":"​ 在代码中添加Autolayout约束的方法就如下的整个demo介绍。下面demo中还介绍到了怎么在Autolayout下做动画，以及约束的优先级。 在约束添加中要注意以下几个地方： 两个相同一层级的视图的约束要添加到共同的父视图上 两个不同层级的视图的约束要添加到他们最近的共有的父视图上 子视图与父视图之间的约束添加到父视图上","text":"​ 在代码中添加Autolayout约束的方法就如下的整个demo介绍。下面demo中还介绍到了怎么在Autolayout下做动画，以及约束的优先级。 在约束添加中要注意以下几个地方： 两个相同一层级的视图的约束要添加到共同的父视图上 两个不同层级的视图的约束要添加到他们最近的共有的父视图上 子视图与父视图之间的约束添加到父视图上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#import &quot;ViewController.h&quot;@interface ViewController ()&#123; UIView *blueView;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [self addRedView];&#125;- (void)addRedView&#123; //首先创建这个View UIView *redView = [[UIView alloc]init]; redView.backgroundColor = [UIColor redColor]; //给每个视图代码添加NSLayoutConstraint约束的时候要关闭这个属性 redView.translatesAutoresizingMaskIntoConstraints = NO; //在给视图添加约束的时候要先将视图添加到父视图，不然会报错 [self.view addSubview:redView]; //相对于父控件的左边距 NSLayoutConstraint *redViewLeft = [NSLayoutConstraint constraintWithItem:redView attribute:NSLayoutAttributeLeft relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeLeft multiplier:1.0 constant:20.0]; [self.view addConstraint:redViewLeft]; //相对于父控件的下边距 NSLayoutConstraint *redViewBottom = [NSLayoutConstraint constraintWithItem:redView attribute:NSLayoutAttributeBottom relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeBottom multiplier:1.0 constant:-20.0]; [self.view addConstraint:redViewBottom]; //自身宽度约束（这里是直接添加宽度约束） NSLayoutConstraint *redViewWidth = [NSLayoutConstraint constraintWithItem:redView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:kNilOptions multiplier:1.0 constant:50]; [redView addConstraint:redViewWidth]; //自身高度约束（这里是直接添加高度约束） NSLayoutConstraint *redViewHeight = [NSLayoutConstraint constraintWithItem:redView attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:nil attribute:kNilOptions multiplier:1.0 constant:50]; [redView addConstraint:redViewHeight]; //蓝色的小方块 blueView = [[UIView alloc]init]; blueView.backgroundColor = [UIColor blueColor]; blueView.translatesAutoresizingMaskIntoConstraints = NO; [self.view addSubview:blueView]; //相对于红色视图的顶部约束 NSLayoutConstraint *blueViewTop = [NSLayoutConstraint constraintWithItem:blueView attribute:NSLayoutAttributeTop relatedBy:NSLayoutRelationEqual toItem:redView attribute:NSLayoutAttributeTop multiplier:1.0 constant:0]; [self.view addConstraint:blueViewTop]; //视图左边的边距（相对于红色视图的右边的边距） NSLayoutConstraint *blueViewLeft = [NSLayoutConstraint constraintWithItem:blueView attribute:NSLayoutAttributeLeft relatedBy:NSLayoutRelationEqual toItem:redView attribute:NSLayoutAttributeRight multiplier:1.0 constant:20]; [self.view addConstraint:blueViewLeft]; //等于红色视图的宽 NSLayoutConstraint *blueViewWidth = [NSLayoutConstraint constraintWithItem:blueView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:redView attribute:NSLayoutAttributeWidth multiplier:1.0 constant:0]; [self.view addConstraint:blueViewWidth]; //等于红色视图的高 NSLayoutConstraint *blueViewHeight = [NSLayoutConstraint constraintWithItem:blueView attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:redView attribute:NSLayoutAttributeHeight multiplier:1.0 constant:0]; [self.view addConstraint:blueViewHeight]; //黑色的视图 UIView *blackView = [[UIView alloc]init]; blackView.backgroundColor = [UIColor blackColor]; blackView.translatesAutoresizingMaskIntoConstraints = NO; [self.view addSubview:blackView]; //相对于红色视图的顶部约束 NSLayoutConstraint *blackViewTop = [NSLayoutConstraint constraintWithItem:blackView attribute:NSLayoutAttributeTop relatedBy:NSLayoutRelationEqual toItem:redView attribute:NSLayoutAttributeTop multiplier:1.0 constant:0]; [self.view addConstraint:blackViewTop]; //视图左边的边距（相对于红色视图的右边的边距） NSLayoutConstraint *blackViewLeft = [NSLayoutConstraint constraintWithItem:blackView attribute:NSLayoutAttributeLeft relatedBy:NSLayoutRelationEqual toItem:blueView attribute:NSLayoutAttributeRight multiplier:1.0 constant:20]; [self.view addConstraint:blackViewLeft]; //直接添加黑色视图的宽度约束 NSLayoutConstraint *blackViewWidth = [NSLayoutConstraint constraintWithItem:blackView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:kNilOptions multiplier:1.0 constant:50]; [self.view addConstraint:blackViewWidth]; //直接添加黑色视图的高度约束 NSLayoutConstraint *blackViewHeight = [NSLayoutConstraint constraintWithItem:blackView attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:nil attribute:kNilOptions multiplier:1.0 constant:50]; [self.view addConstraint:blackViewHeight]; //这里介绍了在AutoLayout中做动画的方法。当蓝色视图消失后，这个视图的左边距要设置为相对于红色视图的右边距 NSLayoutConstraint *blackViewWithredViewLeft = [NSLayoutConstraint constraintWithItem:blackView attribute:NSLayoutAttributeLeft relatedBy:NSLayoutRelationEqual toItem:redView attribute:NSLayoutAttributeRight multiplier:1.0 constant:20]; //重复添加约束是回报错的，不正确的做法。但是这里如果蓝色视图消失不改变约束的话就达不到想要的约束效果 //解决方法就是设置约束的优先级 优先级范围为：0 - 1000 数值越大优先级越高 默认为1000 UILayoutPriority left = 200; blackViewWithredViewLeft.priority = left; [self.view addConstraint:blackViewWithredViewLeft];&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; [blueView removeFromSuperview]; [UIView animateWithDuration:2 animations:^&#123; //当视图发生改变需要更新约束 [self.view layoutIfNeeded]; &#125;];&#125;","categories":[],"tags":[{"name":"Autolayout","slug":"Autolayout","permalink":"Aaronzjp.cn/tags/Autolayout/"}]},{"title":"利用Storyboard或Xib实现自适应Cell","slug":"StoryboardOrXibRealizeAutoLayoutCell","date":"2015-12-26T12:47:35.000Z","updated":"2017-07-27T02:53:17.000Z","comments":true,"path":"2015/12/26/StoryboardOrXibRealizeAutoLayoutCell/","link":"","permalink":"Aaronzjp.cn/2015/12/26/StoryboardOrXibRealizeAutoLayoutCell/","excerpt":"​ 首先，UITableView这东西怎么用就不用说了吧，可以拖一个UITableview到UIController中，也可以直接拖一个UITableViewController出来。拖UITableView的时候不要忘记加代理和数据源就对了。 完成这一步后就可以在storyboard中对cell进行约束布局了，就用一个简单的demo来说。","text":"​ 首先，UITableView这东西怎么用就不用说了吧，可以拖一个UITableview到UIController中，也可以直接拖一个UITableViewController出来。拖UITableView的时候不要忘记加代理和数据源就对了。 完成这一步后就可以在storyboard中对cell进行约束布局了，就用一个简单的demo来说。 这里选择你需要自适应换行的label。到右边的属性选择中设置下，这样label就可以自动换行了。不能约束label的高，否则自动换行就无效。设置好约束后，在右边把Lines的选项设置为0（默认为1），这里的0代表不限制label的行数。 设置好以上步骤后，在代码中实现以下代码就已经成功的实现cell的高度只适应了。 1234567//这里是设置单元格的预判高度，根据自己的预估单元格的平均高度随便填写一个就行。self.tableView.estimatedRowHeight = 200;//这里是设置单元格默认的行高，就是会根据自己的计算来获得实际高度;self.tableView.rowHeight = UITableViewAutomaticDimension; 如果对cell的内容有更复杂的需求，需要做cell自适应的话，还是建议用代码来实现。","categories":[],"tags":[{"name":"自适应Cell","slug":"自适应Cell","permalink":"Aaronzjp.cn/tags/自适应Cell/"}]},{"title":"iOS9http请求","slug":"iOS9-http-Request","date":"2015-09-14T06:23:06.000Z","updated":"2017-07-27T02:56:22.000Z","comments":true,"path":"2015/09/14/iOS9-http-Request/","link":"","permalink":"Aaronzjp.cn/2015/09/14/iOS9-http-Request/","excerpt":"因为升级iOS9以后苹果要求App内访问网络时必须使用HTTPS协议，在新建的工程中都是默认使用HTTPS协议的，在不修改的情况下无法正常的访问HTTP协议的网络。以前遇到这个问题解决后就没管，现在记录一下方便查找。","text":"因为升级iOS9以后苹果要求App内访问网络时必须使用HTTPS协议，在新建的工程中都是默认使用HTTPS协议的，在不修改的情况下无法正常的访问HTTP协议的网络。以前遇到这个问题解决后就没管，现在记录一下方便查找。 解决方式找到工程的Info.plist文件在其中添加一个App Transport Security Settings的字段属性，然后在该字典属性下添加一个Allow Arbitrary Loads属性，设置为YES即可。 如下图：","categories":[],"tags":[{"name":"疑难杂症","slug":"疑难杂症","permalink":"Aaronzjp.cn/tags/疑难杂症/"}]},{"title":"git的简单使用","slug":"UseGit","date":"2015-07-05T06:04:25.000Z","updated":"2017-04-19T09:18:41.000Z","comments":true,"path":"2015/07/05/UseGit/","link":"","permalink":"Aaronzjp.cn/2015/07/05/UseGit/","excerpt":"关于安装git因为在Mac上安装Xcode后就会自动的安装git，所有Mac端的安装方式就不需要怎么说了，在Linux下具体的就不怎么说了，自行Google，因为Linux的版本太多，各个版本之间都存在微小的差异。在Windows下推荐使用git for Windows，它包括了图形工具以及命令的使用。","text":"关于安装git因为在Mac上安装Xcode后就会自动的安装git，所有Mac端的安装方式就不需要怎么说了，在Linux下具体的就不怎么说了，自行Google，因为Linux的版本太多，各个版本之间都存在微小的差异。在Windows下推荐使用git for Windows，它包括了图形工具以及命令的使用。 配置git安装完git后我们第一件事要做的就是配置git，其中配置git方式如下： git config –global user.name “用户名” git config –global user.email “邮箱” 配置好这两项后，就能通过git的配置知道谁在git仓库中做了什么。 创建一个新的git仓库创建一个git仓库后，git会把该项目的所有文件以及历史记录通过快照的方式保存在项目中，在创建仓库的时候，首先要进入到项目的根目录下，然后创建git仓库。创建完成后git会在该文件夹下创建一个隐藏的文件夹以.git结尾。 cd desktop/test git init 这样就为这个test的工程创建了一个git仓库。 查看git仓库的状态git仓库的状态是很重要的一个东西，我们通过git仓库的状态可以判断出来该项目仓库中的东西是否为最新的，以及项目是否被(commit)提交到git仓库保存。 git status 通过这个命令就可以在terminal中显示出当前git仓库的状态。 暂存git中有个叫暂存区的东西，我们在提交代码前都先要将代码保存到暂存区在进行代码的提交。如下提交代码到git暂存区的命令： 提交单个的文件到暂存区： git add 文件命 提交所有的文件到暂存区： git add -A 将文件提交到暂存区后再次使用git status查看状态就会发现文件已经提交了，其中的信息还会告诉我们哪些文件发生了改变，修改了什么东西。 提交文件被存到暂存区后我们还是需要提交代码到git git commit 当然我们也可以对提交的代码加以描述，以便清楚的表达我们修改了什么，等等，这样我们能更好的找到某个阶段的代码，回滚等等的其他操作 git commit -m “描述内容” 提交代码到远端仓库上面我们所有的操作都是在本地，文件也都是被保存在本地的，但是当我们处于多人协同开发时，我们需要将代码发布到远端的仓库以便其他的工程师pull以及push代码及时的修改代码和提交合并代码。 这里远端仓库就用github作为示例，首先在github上创建一个仓库，然后找到仓库的ssh地址或者http地址。然后在terminal中输入如下命令： git remote add origin 仓库地址 在本地仓库中添加好远端仓库的地址后就可以提交代码到远端仓库了： git push origin master 成功push到远端仓库后该项目的其他人就可以从远端仓库拉取刚刚push上去的最新的代码： git pull origin master 创建分支每个仓库在默认的时候都只有一个默认的分支master，但是在项目中有时候我们需要开一些新的分支，新开分支： git branch 分支名 查看分支状态： git branch 新开一个分支后我们需要试试看切换到新的分支，切换分支： git checkout 分支名 合并分支，在合并分支的时候，一定要把要合并的分支切换到当前分支，然后去合并被合并的分支，这里就是用master去合并一个分支： git checkout master git merge 分支名 删除分支： git branch -d 分支名 其他使用查看git提交日志： git log 要查看每次更新具体都更新了什么东西： git show 提交的id 查看两次提交的不同： git diff 提交的id..提交的id 差不多git的基本使用就是这些了，已经足够在平常的工作中使用了，最后我还是建议能用图形工具还是使用图形工具吧，因为图形工具更便捷，更清楚明了还不容易出错，有什么不好的呢。OS X上我现在正在使用的是SourceTree，具体使用什么这个看个人的喜好和习惯。","categories":[],"tags":[{"name":"git","slug":"git","permalink":"Aaronzjp.cn/tags/git/"}]},{"title":"一个App多个UITabBar的处理","slug":"Multiple-UITabBar","date":"2015-06-30T07:55:43.000Z","updated":"2017-07-27T02:58:34.000Z","comments":true,"path":"2015/06/30/Multiple-UITabBar/","link":"","permalink":"Aaronzjp.cn/2015/06/30/Multiple-UITabBar/","excerpt":"​ 平时很多常规的App都是一个App只有一个UITabBar，但是这次要做的需求是在不同的ViewController下就会显示不同的UITabBar，因为自己也是第一次做这样的需求的处理，所以一开始就在网上找类似需求的资料，结果是找了半天也没有怎么找到。于是也就只能慢慢的琢磨了，","text":"​ 平时很多常规的App都是一个App只有一个UITabBar，但是这次要做的需求是在不同的ViewController下就会显示不同的UITabBar，因为自己也是第一次做这样的需求的处理，所以一开始就在网上找类似需求的资料，结果是找了半天也没有怎么找到。于是也就只能慢慢的琢磨了， 最开始我想的是多做一个UITabBarController，在那个需要变更TabBar的Controller中就push出另外一个UITabBarController，但是。。。但是。。。但是做出来了发现并没有任何变化。 如下图这样： ​ 试了一下感觉不行，怎么办？删了？正准备删了的时候突发奇想的会不会是上一个TabBar的视图把push出来的这个视图给挡住了呢？于是我在push出第二个TabBar的时候尝试隐藏掉上一个视图的TabBar和NavigationBar： 12[self.navigationController.navigationBar setHidden:YES];[self.tabBarController.tabBar setHidden:YES]; 隐藏后真的可以了，在push出第二个TabBar的时候成功的变更了TabBar但是新的问题又出现了，这样push后原先的navigationBar已经被隐藏了，没有了返回按钮，无法返回到主页面。于是这里就只能自己添加上一个返回按钮，然后pop到根视图： 1234567self.view.backgroundColor = [UIColor whiteColor];UIBarButtonItem *backButton = [[UIBarButtonItem alloc]initWithTitle:@&quot;返回&quot;style:UIBarButtonItemStylePlain target:self action:@selector(backToRootViewController)];//注意这里的不同- (void)backToRootViewController &#123; [self.tabBarController.navigationController popToRootViewControllerAnimated:YES];&#125; 注意这里是self.tabBarController.navigationController 如果是self.navigationController的话是没有效果的，具体原因可能就是TabBar被和navigationBar被嵌套后就要获取到tabBarController的navigationBar来pop到主页的根视图。","categories":[],"tags":[{"name":"思路","slug":"思路","permalink":"Aaronzjp.cn/tags/思路/"}]},{"title":"iOS-预处理程序","slug":"iOS-Precompiling","date":"2015-06-21T04:13:45.000Z","updated":"2017-07-27T02:56:48.000Z","comments":true,"path":"2015/06/21/iOS-Precompiling/","link":"","permalink":"Aaronzjp.cn/2015/06/21/iOS-Precompiling/","excerpt":"预处理程序，即预编译。预处理程序是程序编译过程中的一部分。顾名思义大概就是在程序编译之前就处理这些预编译程序指令。在平常开发工作中可能经常看到一大堆的全大写的代码有的还用下划线来连接起来，其实这个就是预编译代码。","text":"预处理程序，即预编译。预处理程序是程序编译过程中的一部分。顾名思义大概就是在程序编译之前就处理这些预编译程序指令。在平常开发工作中可能经常看到一大堆的全大写的代码有的还用下划线来连接起来，其实这个就是预编译代码。 讲到预编译指令首先就要说 #define 宏定义。 #define#define 宏定义语句的主要用途就是替换，只要在程序中出现该宏定义的地方就会把其替换为宏定义后的常量或者表达式。 宏定义的简单使用如下： 123456789101112#define ONE 1#define IRON_MAN @&quot;iron man&quot;if (a == ONE) &#123; NSLog(@&quot;a = 1&quot;);&#125; else &#123; NSLog(@&quot;a != 1&quot;);&#125;NSString *ironman = @&quot;iron man&quot;;if ([ironman isEqualToString:IRON_MAN]) &#123; NSLog(IRON_MAN);&#125; 输出： 12a = 1iron man 可以看到这里的宏定义只是做出了简单的替换，但是接着看，宏定义还有更高级的用法，宏定义也可以是表达式，或者带参数的宏定义。 12#define TWO_FIVE 5 + 5NSLog(@&quot;%f&quot;,TWO_FIVE); 这里这个宏定义是一个简短的表达式，这里会输出10。再来看一下带有参数的宏定义是什么样的吧。如下： 12#define MAX_OF_NUMBER(a,b) a &gt;b ? a : bNSLog(@&quot;%d&quot;,MAX_OF_NUMBER(5, 10)); 这段代码会输出10，该宏定义是带有两个参数的宏定义，其作用是取这两个数的最大值。 消除宏定义可以使用 #undef 语句，如下： 如果要在宏定义中换行，则需呀在每行的结尾处添加反斜杠\\。 这里不讨论宏定义的正确性，只是简单介绍一下宏定义的使用，关于宏定义可以参考下面的资料。 宏定义的黑魔法 - 宏菜鸟起飞手册 条件编译条件编译的语句： #if 在预处理指令中的条件判断，相当于 if #ifdef 在预处理指令中判断某个宏是否已经被定义 #ifndef 与上一条相反，判断某个宏定义是否未定义 #elif 预处理指令中如果其他条件不满足则执行 #elif 内的语句，和 else if 一样 #else 预处理指令中如果其他条件都不满足则执行 #else 后的语句，和 else 一样 #endif 条件语句结束的标志语句 值得注意的就是这里的语句都是判断后面的条件是否满足，只有 #ifdef 是判断某个宏是否被定义。在使用上这两个是相同的： 1234567#ifdef IPHONE NSLog(IPHONE);#endif// ********************* #if defined (IPHONE) NSLog(IPHONE);#endif 其中 defined () 也是判断某个宏是否已经被定义，条件编译语句和普通的条件判断语句一样也是可以嵌套的。这里贴出一部分 Foudation 框架中的代码参考，可以看一下别人的使用。 另外在很多时候创建头文件中都会有如下的代码： 1234#ifndef Header_h #define Header_h #endif 上面的这些预编于指令代码其实就是为了防止头文件重复导入。 文件导入文件导入其实也是属于预处理程序的一种，但是文件导入像什么 #import #include @class经常都在使用已经很熟悉其中的用法和含义了这里就不记录了。","categories":[],"tags":[{"name":"宏","slug":"宏","permalink":"Aaronzjp.cn/tags/宏/"}]},{"title":"如何搭建自己的个人博客","slug":"CreateBlog","date":"2015-03-04T17:04:20.000Z","updated":"2017-04-19T09:09:07.000Z","comments":true,"path":"2015/03/05/CreateBlog/","link":"","permalink":"Aaronzjp.cn/2015/03/05/CreateBlog/","excerpt":"自己也搭建了个人博客，在搭建的过程中也又遇到了很多问题，所以在这里我自己来总结一下，搭建一个博客的过程。方便以后博客出问题的时候来这里查找。","text":"自己也搭建了个人博客，在搭建的过程中也又遇到了很多问题，所以在这里我自己来总结一下，搭建一个博客的过程。方便以后博客出问题的时候来这里查找。 首先环境搭建 安装Node.js。官网下载，下载后打开按照提示一步一步的安装即可。 git这个不用多说，因为我使用的是Mac电脑，所以自带git。 npm的安装，npm使用命令安装 npm install -g hexo-cli,也可以到官网下载下来进行安装官网链接 上面几步做好后我们的准备工作就做的差不多了，查看上面的工具是否安装成功可以通过查看版本的方式来查看。如：node -v 建立本地站点 hexo init &lt;文件夹名称&gt; cd &lt;文件夹名称&gt; npm install 克隆主题&emsp;&emsp;不知道在哪找主题吧，可以进入到官网链接去查看，点击主题里面有一部分的主题，也可以去这里 有哪些好看的hexo主题？ 发布到github 注册github这些我就不说了吧，进入到githu登陆账号后，点击New repository创建一个新的项目，注意这里的这个项目命名是有规定的，必须是如下的这种格式命名： 你的github名称.github.io ​ 因为github规定只能是这样命名的才能以page的样式展现，其他的全部默认就好，创建完成后，我们可以像平时使用github一样的，把博客的文件push到这个项目即可。（注意push博客的时候是push&lt;文件夹名称&gt;–&gt;public这个文件夹下所有的文件）。 为了更方便的管理博客和平时文件的更新，我们来配置一个deploy。打开站点配置文件_config.yml，找到deploy字段，修改成如下的样式即可。 1234567&gt; # Deployment&gt; ## Docs: http://hexo.io/docs/deployment.html&gt; deploy:&gt; type: git&gt; repository: git@github.com:用户名/用户名.github.io.git&gt; branch: master&gt; 这样配置好以后，有新的博客添加，或者修改后，只需要执行如下的操作就可以将博客发布到github： hexo g //生成静态网页 hexo s //部署在本地，此步操作完后就可以在本地查看网页预览 hexo deploy //没有问题后就可以部署到github上了 这三步操作完成后就其他人也可以通过github来访问你的个人博客了。 ⚠️注意：使用hexo d来部署博客到github首先要安装一个插件hexo-deployer-git，安装方式，cd 到你当前的博客根目录文件夹下执行以下命令： npm install hexo-deployer-git –save 发布新的文章hexo new &quot;文章标题名称&quot; 执行以上命令后，相应文件夹中生成.md文件，找到编辑并保存后。执行以上发布到github这部分，就可以把文章发布出去了。 hexo clean清理，这个操作会将public文件夹删除，这个慎用，在遇到问题的时候可以通过这个来清除后再通过hexo g重新生成，并同步到github。","categories":[{"name":"其他","slug":"其他","permalink":"Aaronzjp.cn/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"Aaronzjp.cn/tags/其他/"}]}]}