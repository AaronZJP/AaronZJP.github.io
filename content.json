{"meta":{"title":"Aaron的博客","subtitle":"技术博客，记录和学习","description":"Stay foolish,Stay hungry!","author":"Aaron_36","url":"Aaronzjp.cn"},"pages":[{"title":"标签","date":"2014-12-22T04:39:04.000Z","updated":"2017-06-08T02:00:29.000Z","comments":true,"path":"tags/index.html","permalink":"Aaronzjp.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Apple Watch 设计（Code + Design 翻译）","slug":"Designing-for-Apple-Watch","date":"2018-11-25T16:02:12.000Z","updated":"2018-11-25T16:27:24.109Z","comments":true,"path":"2018/11/26/Designing-for-Apple-Watch/","link":"","permalink":"Aaronzjp.cn/2018/11/26/Designing-for-Apple-Watch/","excerpt":"","text":"Apple Watch 发布于 2015 年 4 月 24 ，收到了开发者，设计师和媒体的高度期待。这真的是第一个出乎预料的可穿戴设备，使苹果成为了全世界第一个的手表制造商。 虽然它是苹果设备家族中的一员，但是它拥有自己的人机交互指南。对于 Apple Watch 来说，拥有自己的生态系统是非常重要的。 根据Asymco的数据，苹果手表的销量为3300万。对于你的 app 来说这是很大的用户群。 概要Apple Watch 的设计和 iOS 的设计是完全不同的。我们需要了解不同的方面，这使得苹果手表成为一个令人惊讶的小型计算机，同时，它是 iPhone 的扩展。 对于设计师来说，我们需要考虑 Apple Watch 的屏幕尺寸以及理解哪一部分的设计是与 iPhone 是完全不同的。 这一点非常重要，因为屏幕大小带来了新的手势和新的UI/UX考虑。 Apple Watch 设计概览或许我们对Apple Watch的第一次体验，是我们第一次收到通知。作为一名用户，直接从手表上操作而不使用手机是一种非常棒的体验。 但是，是什么让体验如此棒呢？Overall 的设计主题是: 人机交流Apple Watch 或许是第一个与用户建立亲密联系的设备，所以你需要在设计过程中利用这种独特的联系。 整体设计Force Touch和Digital Crown是让用户与屏幕内容无缝交互的关键部件。当你在设计你的应用程序时，目标应该是增强用户的体检，即硬件和软件的体验是不可分割的。 轻量级交互在 Apple Watch 上快速的交互对用户体验来说是很有必要的。动画和声音的同步对于用户来说是至关重要的。重要的是要考虑显示的信息应该是快速浏览和容易忽略的。 Apple Watch 优秀高品质的体验当你开始设计你的 Apple Watch 的 app 的时候你需要小心仔细的计划。在这里有一段苹果公司的视频，提供了一些计较和提示，让你更好的计划你的 app。 评估里 app 最好的方式是需要考虑以下4个点： 清晰用户需要一眼就能看到你展示的信息。 简洁很直接的一点就是，需要记住当你的用户从收到你的信息抬起手腕到放下手腕的时候，你只有几秒钟的时间。 及时尽可能的在最短的时间内向用户展示最相关的信息。像这样，你可以让你的 app 更加贴近用户。 个人的如果你的应用程序完成了前三个元素，你的用户将会感到一种个人的联系。理想情况下，尝试加深与用户的关系。 Apple Watch 设计基本要素苹果提供了一些很好的资源，方便你开始设计你的 Apple Watch app。当你开始设计的时候你需要考虑一下遵守如下的一些原则： 问你自己一个问题确定一下在你的 Apple Watch app 中需要展示的最重要的是什么。找到终端用户特有的特性。问你自己：用户一眼看到的最重要的东西是什么？这是你需要理解的重点。如果你的 app 是关于天气的，这个问题答案应该是今天是什么天气？在最后，你的设计应该回答这个问题。 你需要明白，你的设计将试图回答你的应用解决的主要问题，所以要保持简洁、重要和专注。 迭代好的就这样，你的 Apple Watch app有了一个很好的设计。很受用户喜欢。不要停留在这里，你要一直问你自己，怎样才能做得更好？ 总是有新的和创造性的方法为你的用户想出更好的设计。 通知Apple Watch 的 app 有两种类型的通知：短时间展示和长时间展示通知。 首先用户会收到一个通知，这是一个短时间展示的通知。这个通知会显示很短的时间，如果用户想关闭这个通知，只需要放下手腕即可。如果想查看更多的细节，用户可以抬起手腕，点击通知界面。 视觉设计这里有一些关于视觉设计的设计指南。 动画你需要保持动画简短，以及目的明确。你不需要在通知界面使用布局动画。尽量减少动画并发的情况，并让动画是可选的。 你可以对以下属性做动画： 高 宽 组嵌套 对齐方式 背景色 色调 透明度 颜色你需要为你的 app 选择一个全局色，这个颜色与你的 app 在其他设备上的颜色一致，比如 iPhone 。苹果建议从以下这几个方面考虑： 使用黑色作为你的应用的背景颜色，因为它与苹果手表的边框混合在一起，创造了一个没有边缘的屏幕的错觉。 注意色盲，以及不同文化群体对颜色的感知。 尽量避免使用颜色作为显示交互性的唯一方法。 显示尺寸Apple Watch 发布了两种尺寸的版本： 38 mm 和 42 mm。 所以你需要用一个图片资源同时在两种尺寸的屏幕中展示。 定制颜色，字体，和图标对于你需要定制的 app 来说是相当重要的一部分。但是这里有一些你必须要遵守的一些规则： 始终尝试使用字体，颜色，图片选择，来明确的表明品牌标识。这些可以帮助你创建自己独一无二的风格。 避免在 app 内显示你的 logo 不要包含启动屏幕 如果你需要不一样的排版，一定要让排版清晰，更多的信息你可以阅读 页面排版 避免使用品牌颜色和 logo 填充背景区域 使用你的品牌颜色作为 app 的全局色调 排版在苹果手表发布的同一年，苹果给设计界带来了另一个惊喜。他们发布了第一个系列的字体，叫做旧金山字体（San Francisco）。当时 Helvetica Neue 字体应用于iOS，但不适用于小屏幕上的文本。 旧金山字体（San Francisco）有一个目的就是统一苹果平台，无论怎么样它不是一个单独的字体。 旧金山字体（San Francisco）由两个主要的子系列组成。 SF Pro 运行于 iOS 和 macOS , SF Compact 运行于 Apple Watch。 第一个是文本风格上的，但是第二个是功能上的。 SF Pro 和 SF Compact 是同类字体，这意味着它们是相关的，但不是完全相同的。两者之间最大的区别是如何处理圆形的形状。 与 SF Pro 相比，SF Compact 有相当平坦的垂直线条，这是因为苹果希望在小屏幕上容纳更多的文字。 确实，旧金山的 iOS、macOS 和 watchOS 字体是不一样的。你可以很容易地分辨出像 “o” 、“e” 这样的圆形字母的区别。 图标和图片致于其他应用，你需要优化你应用的图片。苹果推荐你使用去交错式图像 PNG 位图文件或者光栅化图片。同时应该尝试避免图片的透明度，因为 alpha 通道会增加图片文件的大小。你也可以为不需要使用 24 位色的 PNG 图片使用 8 位色的图片。这个调色板不适用于照片。 导出 Apple Watch 应用 icon图标当你需要为你的 Apple Watch 应用导出图片资源的时候，有一个简洁的付费应用程序非常的方便。Asset Catalog Creator 是一个可以导出 Apple Watch 应用 icon 图标的应用程序。 为其他可穿戴设备设计虽然Apple Watch是目前最流行的可穿戴设备，但作为设计师，我们有时也会被要求为其他可穿戴设备设计产品。针对于这个特例，你接下来看到的这个链接是非常有用的 Android Wear ， Android Wear。 结论综上所述，作为一个设计师，最重要的是你应该记住，你的设计应该是在不断的回答的一个问题：用户在这一瞥中最想看到的最重要的东西是什么？最终始终需要考虑到的4个重要的因素：清晰、简洁、及时、个性化。 Cl","categories":[],"tags":[{"name":"Design+Code","slug":"Design-Code","permalink":"Aaronzjp.cn/tags/Design-Code/"},{"name":"iOS编程和设计","slug":"iOS编程和设计","permalink":"Aaronzjp.cn/tags/iOS编程和设计/"}]},{"title":"如何使用颜色（Code + Design 翻译）","slug":"Designing-with-Colors","date":"2018-05-18T16:10:12.000Z","updated":"2018-11-24T09:32:45.643Z","comments":true,"path":"2018/05/19/Designing-with-Colors/","link":"","permalink":"Aaronzjp.cn/2018/05/19/Designing-with-Colors/","excerpt":"颜色很难掌握，因为太容易过度。当我们设计的时候，很容易过度设计。对于颜色，我们太倾向于使用鲜艳的色彩了，这样太过分散注意力，并且感觉十分不自然。我可以推荐的是简单的坚持基础基本原则，并且通过关注实用性和愉悦性来调节颜色的使用。当有疑问的时候，使用颜色来吸引注意力到按钮或重要元素上。 大自然可能是所有事物的最大灵感来源。在自然中的和谐，你只需要将它转换到数码世界里，应用到你的设计中。你会想选择一个基于自然中美丽的颜色，像天空，云朵，日落和植物。","text":"颜色很难掌握，因为太容易过度。当我们设计的时候，很容易过度设计。对于颜色，我们太倾向于使用鲜艳的色彩了，这样太过分散注意力，并且感觉十分不自然。我可以推荐的是简单的坚持基础基本原则，并且通过关注实用性和愉悦性来调节颜色的使用。当有疑问的时候，使用颜色来吸引注意力到按钮或重要元素上。 大自然可能是所有事物的最大灵感来源。在自然中的和谐，你只需要将它转换到数码世界里，应用到你的设计中。你会想选择一个基于自然中美丽的颜色，像天空，云朵，日落和植物。 主要色，次要色和第三色我建议，在主要色和次要色选择，先从有活力，柔和的颜色开始。没有错误的选择，关键是你如何使用以及怎么选择补充色的方式。 iOS 调色板这些是苹果在其自己原生应用中使用的颜色。这些颜色充满活力，但是不会太过华丽。通常，蓝色在整个系统中被用作按钮，图标和可操作元素的通用颜色。但是其他颜色可以用来设置成标志性的商标颜色，如：黄色用于记事本，粉色用于 Apple Music，绿色用于信息，等等。如果你不是很懂，那就使用蓝色。在设计的时候请记住，红色通常用于具有破坏性的操作，绿色用于成功的操作。 例子颜色是用来引导注意力到可交互的地方。不可交互的元素，通常会使用更加温和自然的颜色，使用黑色，灰色或者白色。如果可能的话尽量使用一种颜色，让内容去交流，互动。 色相，饱和度，亮度当我们使用颜色的时候，理解颜色相关的属性是至关重要的。很多人使用 RGB，但是就我个人而言，我发现 HSB 更加容易使用。这是因为对于一个颜色来说，很难判断有多少红色，绿色，和蓝色。在另一种方式，我可以很容易的想象出，色相，饱和度，和亮度。这些值给我的更加强烈的感官感受。 单一颜色最常见的情况是使用一种主色调，并在上面添加一个透明度 10-90% 的白色或者黑色的图层。对于那些对颜色不熟悉的人来说，坚持使用一种主色调是一个很明智的选择。对于新的概念，简化操作总是很有帮助。 通过添加具有不同透明度的黑色或者白色图层，你可以获得全新的一个色彩，并且可以很好的相互补充。 创建单一色你可以使用颜色拾取器来改亮度和饱和度，知道你感到更加舒适。只要色值大致相同（红色要是红色），你就能得到一个单一颜色。 相近色这个意思就是选择与主色颜色相近的颜色。在色盘中它是主色旁边的一种颜色。当你感觉你的内容没有提供足够的色彩变化，并且你不得不求助于新的色彩来补充它时，这是特别有用的。 例如，红色的相近色是橘色，橘色的相近色就是黄色。 创建相近色通过调整现有颜色的色相值，在 30 到 50 之间，你可以获得一个新的相近色。 互补色互补色是与主色相对的颜色。在色盘中互补色常常是主色对面的那个颜色。补充色提供了出色的对比，这对于激活用户界面是相当重要的。 但是，他们是很难一起使用的，所以谨慎使用。 创建补充色使用颜色拾取器，你可以简单的将色相值，颜色调节工具条拖动一半的距离。 中性色调或许色彩中最重要的方面是中性色调。他们是中和剂，让你的设计不会感到太过沉重。太多的颜色意味着长时间的使用性较差。最重要的是，中性色调延迟了用户对内容的关注。 创建中性色调中性色调不能与主色调产生竞争。为了获得中性色调，你必须将饱和度几乎拖到0。然后调节亮度为亮色或者暗色。 对比度颜色不应该妨碍易读性。对比需要能够让用户更加舒适的阅读并让用户沉浸其中。为了良好的对比度，请使用相反的颜色：白色与黑色对比，浅蓝色与深蓝色对比，高亮度与低亮度对比。 使用图片的颜色你周围充满了激发灵感的色彩。当你看到一个漂亮的照片，物品或者数码设计的时候，你注意到的第一件事就是好漂亮的颜色啊。发生这样的情况的时候，你应该拍摄图片，或屏幕截图，并提取颜色。通过这些颜色你可以创建一个调色板。 Sip 是一款出色的iOS应用程序，可让您从照片中创建调色板。 手动创建手动创建一个调色板是很好的方式，但是需要你对颜色有很好的理解。任何自动式的都是在有价格的：最好使用你的直觉，这还是很准确的。 在这个例子中，我选择了一个媒体应用程序，并手动提取了主色，次要色和中性色调。 主色通常用于吸引注意力到可操作元素。次要色主要是作为主色的补充，并添加差异。至于背景色，习惯性的遵循内容以及为整设计中增加内容的对比度。这就是为什么我们有明暗对比的背景色。 使用 Adobe 的 Kuler如果您将图像拖放到 Adobe Kuler，它可以为您提供主要颜色，甚至是背景中的颜色。 你可以在不同的主题中玩一下，甚至可以移动圆圈将将关注点放在 UI 上而不是背景。这并不完美，无论怎么样可以自定义一点，我从我上传的图片中获得了我想要的调色板。 收集颜色在 Dribbble 中，你可以浏览和存储好的颜色方案。然后你可以浏览这些颜色用于激发你的灵感。 中性调色板虽然主色很容易提取，但背景和文字颜色却不是。它们更加的微妙，需要更多的实验和研究才能正确的使用。在中性色调中，这里有一些我非常喜欢的 UI 设计调色板。 蓝色组合蓝色是一种令人愉快的颜色，因为它让人们想起天空和水。当人们看到蓝色时，他们更可能感到冷静和信任。蓝色通常和其他颜色也很好搭配。 灰色组合UI 颜色应避免绝对黑色。黑色提供了太多的对比度，并与 iPhone 的黑色屏融为一体。 灰色的使用如果您要使用灰色，请记住将其亮度设置为30％以下或70％以上。普通灰色色调看起来无趣，不能很好地补充其他颜色。 在这个例子中，当亮度在该范围内时，我们获得了更多的对比。一旦灰色变成中间色调，我们几乎不能阅读文字，并且这些颜色看起来并不漂亮。 自定义颜色组合除了常见的蓝色和灰色调色板之外，您可以选择任何您喜欢的颜色，只要确保它们拥有良好的互补性即可。 在颜色选择器中滑动色相，并尝试单色，相近色和互补色（按此顺序）。然后，尝试调整饱和度和亮度以增加对比度和活力。 明亮和黑夜模式 UI有时，你必须在明亮和黑夜模式之间进行切换，无论是基于品牌还是可用性。想想iBooks：当环境光线较弱时，用户界面会自动切换到暗模式。 黑夜模式例子另一个例子是Apple Watch：它使用绝对黑色背景与物理边框完美融合。 明亮模式 UI 指南1.内容应该比背景更亮。需要关注的物体通常比背景更亮。 2.不要过度使用颜色。他们真的会让你过度关注颜色。使用颜色来突出按钮和高亮状态。 3.避免普通的颜色。90-100％的白色通常是最好的范围。 黑夜模式 UI 指南1.不要使用绝对黑色。太黑了很难看到细节，而且和白色使用对比度太高了。 2.如果您必须使用黑色，请确保具有深灰色以缓解高对比度。 3.使用蓝色时避免灰色。深蓝色比灰色更好地补充蓝色。 额外资源了解颜色如何工作，它们如何相互补充以及何时使用它们对于您的应用的品牌和可用性至关重要。这些资源将加强您对颜色的掌握并为您提供有价值的工具和实例，以将这些知识应用于实际项目中。 Material Design 颜色一个关于Google Material 设计中颜色的绝佳指南。这对iOS也有帮助。 Google Material Colors Sketch 调色板Sketch Palettes 的调色板让你可以很简单的储存和导入颜色组合到全局，和颜色文档中。我使用 iOS，Material Design 和 Flat UI 颜色组合开始调色。 UI 渐变我们知道 iOS 在某些地方使用了漂亮的渐变。你可以很简单的对 UI 使用两种互补的颜色进行渐变整合。这是一个很好的渐变集合。 Skala Color这是一个很优秀的颜色拾取器，很好的支持 Swift 和 HEX。 设计的可访问性Contrast 应用 是一款很实用的工具。它遵守了无障碍指南设计和选择正确的颜色。 您可以确保您设计中的文本在界面中不至于太亮。你也可以手动输入 hex 值颜色，也可以使用内置颜色拾取器直接从设计中对他颜色采样。 它将在你的设计工具中一直保持活跃，以便能够快速对访问 WCAG 对比分数。 Coolors.coCoolors.co 是一个快速生成颜色组合方案的工具，只需要按下空格键，你就可以在几秒钟之内浏览到不同的颜色搭配组合。如果你喜欢单一颜色，你可以锁定该颜色并继续浏览，知道找到你想要的颜色组合，一旦你找到了合适的颜色，你可以导出它。这个工具还有相对应的 iOS 应用，非常的方便。 Color Juicer这是另一个很有用的应用，在你将图片拖放到应用的时候，只需要几秒钟就可以帮助你从图片中获取到主色。应用会为你创建一个颜色组合，你只需要点击一下就可以复制任何颜色。","categories":[],"tags":[{"name":"Design+Code","slug":"Design-Code","permalink":"Aaronzjp.cn/tags/Design-Code/"},{"name":"iOS编程和设计","slug":"iOS编程和设计","permalink":"Aaronzjp.cn/tags/iOS编程和设计/"}]},{"title":"iPad 设计指南（Code + Design 翻译）","slug":"Designing-for-iPad","date":"2018-05-18T16:10:12.000Z","updated":"2018-11-24T09:32:07.037Z","comments":true,"path":"2018/05/19/Designing-for-iPad/","link":"","permalink":"Aaronzjp.cn/2018/05/19/Designing-for-iPad/","excerpt":"针对 iPad 的设计并不是像翻转一个开关的那样简单，或者仅仅是将所有的东西变大。更大的屏幕提供了一个真正的机会来呈现更多的内容，同时也要遵守导航，排版，视觉层次的一些基本规则。不要仅仅是当作一个大的 iPhone 来对待 iPad。应该更多的像对待一个可以触摸的桌面电脑一样。换句话说，你的用户可以更加高效，查看更多的内容，更快的执行任务，比如，输入，拖放，以及多任务。","text":"针对 iPad 的设计并不是像翻转一个开关的那样简单，或者仅仅是将所有的东西变大。更大的屏幕提供了一个真正的机会来呈现更多的内容，同时也要遵守导航，排版，视觉层次的一些基本规则。不要仅仅是当作一个大的 iPhone 来对待 iPad。应该更多的像对待一个可以触摸的桌面电脑一样。换句话说，你的用户可以更加高效，查看更多的内容，更快的执行任务，比如，输入，拖放，以及多任务。 更多的内容通常情况下，应用程序在 iPhone 上都有较小的图片来适配较小的屏幕。这在 iPad 上并不是很好的转换方式。相反尝试拥有更大的图片，如果在内容没有收到影响的情况下，可以允许每一行有更多的图片。例如：在 App Store ，卡片的大小会在横屏模式和竖屏模式以及 iPhone 上作出相应的改变。此外，在 iPad 上每行有两张卡片，而 iPhone 上每行有一张卡片。 在 iPhone 上，文本会占用屏幕全部的宽度，但是在 iPad 上的时候，文本被包装在一个容器中，以确保每一行不超过90个字符。 请注意，在 App Store 这个应用中，文本被很好的包裹并且每行的文本不会太长。即使在 iPad Pro 上这个容器的宽度也不会超过 800 pt。 将模态视图居中在 iPhone 上，模态视图通常是仅靠着边缘。这是正常的做法。在 iPad 上，你应该忽略这一点，因为它将会让你的模态视图没有必要的变大。如果你的模态视图小于屏幕尺寸，试着在水平和垂直居中的同时修改尺寸。 转移内容最困难的事之一就是为更大的屏幕重写设计排版。如果你的应用让人感觉很奇怪，有很多的负空间，试着用你的内容模块来填充。例如，在音乐应用上中，将封面图片和描述文字移到布局的左侧区域。尝试将内容组合在一起，这样更加内容转换。 iPad 分辨率目前 iPad 有 3 种分辨率：768 x 1024 pt (iPad), 834 x 1112 pt (iPad Pro 10.5”) and 1024 x 1366 pt (iPad Pro 12.9”)。在 12.9 英寸的 iPad Pro 中，竖屏模式的宽度相当于 iPad 横屏模式的宽度 1024 pt。在硬件方面，iPad 看起来就像是一台专业的桌面电脑。唯一需要赶上的就是软件。 不幸的是，像 Sketch 或者 Xcode 这样全面的应用目前为止还没有出现在 iPad 上。但是对于那些使用不是特别复杂的工具，比如照片编辑，视频编辑，或者其他生产力应用程序的人来说，iPad 已经成为了可以替换桌面电脑的设备。因此，你必须考虑到这些限制，同时也应该知道对专业应用程序的需求在不断增长。 多任务因为 iPad 允许多任务操作，有一个自适应的布局是至关重要的。就像这样，布局可以同时适应全屏模式，侧边浮动或者分屏模式。 侧边浮动侧边浮动模式是在屏幕右侧覆盖出现的，不会影响当前应用的布局。它可以通过在 iOS 11 的 Dock 中拖动一个应用程序来触发。这个浮动显示的应用在 12.9 英寸的 iPad Pro 上尺寸宽度为 375 pt，在其他的 iPad 上尺寸宽度为 320 pt。 分屏视图分屏视图允许用户通过同时运行两个应用程序来执行多任务操作。你的应用必须要适配 16 种宽度。由于分辨率太多，使用自适应布局和尺寸分类是唯一可行的方法。 分屏模式的应用在横屏模式下可以分别占据屏幕的 1/3, 2/3 或者 1/2。在竖屏模式下可以分别占据 1/3 或者 2/3。就像侧边浮动模式一样，在占据屏幕 1/3 的时候，在 12.9 英寸的 iPad Pro 上尺寸宽度为 375 pt，在其他的 iPad 上尺寸宽度为 320 pt。 iPad 尺寸分类（Size Classes）Size Classes 允许你对屏幕的宽度和高度分类，并根据这些分类组合设置布局约束。它们在 iPad 上更加的重要，因为在多任务这样的新特性下，屏幕分辨率十分多样。 有三种类型的宽度和高度分类：Compact，Regular 和 Any。通过这些不同的搭配，可以同时作用于不同的设备。在全屏幕上，通常是 Regular * Regular。 在分屏模式下，由于 12.9 英寸的 iPad Pro 分辨率更大，呈现的效果可能有略微的不同。 拖放（Drag and Drop）在 iOS 11 种有一个新功能可以跨应用拖放文字和图片。这个特性对于可以分屏多任务的大屏 iPad 来说尤其有用。对于设计人员来说这意味着必须要确保内容是可以拖动的。换句话说就是不要使用嵌入图片的文字或者不可拖动的元素。 控制中心在 iPad 上，控制中心会显示额外的元素，比如打开的应用程序和 Dock。应用程序会以很小的样式显示在控制中心，所以要确保你应用的内容是有趣的，并且在这种模式下便于浏览的。正如推荐排版那部分说的一样，标题应该要大，正文字体最小应该有 17 pt。 注意事项这里有一些 iPad 的很好的实例。总之你的布局应该是自适应的，并且充分利用了大屏幕的特性。通常图片和媒体应该更大，文本应该更加易于阅读。 资源iPad 相对于 iPhone 来说，资源是很少有的。的确，iPhone 对于设计师来说是一个更大的市场，但同时你也不能放弃那些使用你应用程序的专业用户。对于工具，视频，阅读，和其他专业应用程序，这是一个很好扩大用户群的机会，他们更加愿意为高质量的应用付费。 适配和布局为了呈现优秀的页面，可以阅读更多关于自适应布局的资料。iOS 人机交互指南。 iPad UI KitiPad 目前还没有 iOS 11 的 UI Kit，但是这有目前最广泛，支持最好的模版。","categories":[],"tags":[{"name":"Design+Code","slug":"Design-Code","permalink":"Aaronzjp.cn/tags/Design-Code/"},{"name":"iOS编程和设计","slug":"iOS编程和设计","permalink":"Aaronzjp.cn/tags/iOS编程和设计/"}]},{"title":"iPhone X 设计指南（Code + Design 翻译）","slug":"Designing-for-iPhoneX","date":"2018-05-18T10:24:12.000Z","updated":"2018-11-24T09:32:23.262Z","comments":true,"path":"2018/05/18/Designing-for-iPhoneX/","link":"","permalink":"Aaronzjp.cn/2018/05/18/Designing-for-iPhoneX/","excerpt":"iOS 11 标志着 iPhone X 的推出，这款高得多的 iPhone 几乎没有边框。5.8 英寸的 OLED 屏幕比 iPhone 8 Plus 的 5.5英寸的屏幕还要大，同时机身尺寸几乎和 iPhone 8 一样大。对于设计师来说，这意味着我们有更多的画布。","text":"iOS 11 标志着 iPhone X 的推出，这款高得多的 iPhone 几乎没有边框。5.8 英寸的 OLED 屏幕比 iPhone 8 Plus 的 5.5英寸的屏幕还要大，同时机身尺寸几乎和 iPhone 8 一样大。对于设计师来说，这意味着我们有更多的画布。 更高的屏幕额外高出的 145 pt 的屏幕意味着额外的多出了一行内容，或者额外的我们曾经认为拥挤的菜单。这一额外的空间同时也适用于 iPhone 8 和 8 Plus，因为它们拥有相同的比例，尽管它们的分辨率不同。 更多的内容空间如果和初代的 iPhone 相比较，高度上增加了 332 pt，这相当于 7 个导航栏的高度。对于未来的内容是非常棒的，相对于逐渐消失的汉堡菜单来说。 当你把初代 iPhone 和 iPhone X 并排放在一起，你会发现内容空间的高度几乎是原来初代 iPhone 的两倍。普遍来说这意味着当今的应用程序始终需要包括所有的工具栏：状态栏，导航栏，标签栏以及主页指示器。忽略到这些工具栏就不仅仅意味着糟糕到用户体验，而且还会使你的应用程序和苹果自带的应用程序不一致。 刘海或许在新的设计中有10%最受争议的方面是在顶部。传感器模块，也被称为刘海，它是一个可以让你意识到 iPhone X 是一个真正的无边框设计的存在。从技术上来讲当前的技术是不可能去掉那部分的，因为包含了人脸识别，摄像头和扬声器。在设计上来说，这是苹果近年来作出最大的妥协。但是在看了其他的手机制造厂商是如何解决这个刘海和下巴的问题的时候，我不能说他们没有妥协。 苹果建议不要使用黑条去隐藏这个刘海。他们的理由是尽管如此这个刘海还是为状态栏和内容提供了更多的宝贵的空间。它提供了下面内容的上下文，并让人感觉屏幕更大。背景元素，例如墙纸，地图和颜色，在圆角和刘海的裁剪下并不会受到影响。如果你隐藏了这个空间，会让你的应用程序屏幕感觉更小，与其他的应用程序不一致，正如这段视频中解释的一样。 大标题在 iOS 11 中屏幕标题的一般大小为 34 pt。它们被设置成黑色的Semibold（半黑体）。有趣的是当你滚都滚屏幕的时候，标题会切换到导航栏，将这块有价值的空了给了回来。在横屏状态下，仅仅是保留很小一部分在导航栏。这给设计师们传达了一个清晰的信息:首先，你应该明智地使用额外的空间，其次，你需要使你的设计适应这种情况，因为在竖屏模式中可能存在额外的空间，而不是在横向模式中。 更大的状态栏状态栏的高度增加了一倍以上，从原来的 20pt 增加到了 44 pt。现在通知中心可以从左上角拖出来。控制中心可以通过拖动右上角切换出来。快速回到主屏幕的方式切换成了从底部向上滑动。或者要到达程序切换的页面，你必须在回到主屏幕的滑动中暂停操作。 安全区域布局指南在针对 iPhone X 的设计中，屏幕的圆角和刘海会裁剪内容。这一点在任何时候都要避免。遵守安全区域的布局指南，你可以将内容推到刘海的位置，这样就可以保证不会出现裁剪内容。一般来说，背景可以不遵循安全区域指南，而文本、图像和按钮等内容都应该遵循这些指南。 iPhone X 的横屏在横屏状态下，状态栏被隐藏，以最大化内容空间。状态栏缩小到 32pt，标签栏缩小到 30 pt，主屏幕指示器缩小到了 23pt。虽然大多数用户不会在 iPhone X 上切换到横屏模式，但仍然有一些重要的应用场景。例如，浏览横屏照片，全屏视频，或者阅读带有较大文字的文章。在完成之后就立即切换到竖屏状态这是反直觉的，特别是在设备放在一个特别舒适的横屏状态下。 如果你的应用已经适配了 iPads ，为什么不更友好的支持 iPhone 的横屏模式呢？当前大部分的应用都是根据自适应布局设计的，用最少的努力获取最大的收益。 网页的横屏如果你是一个产品设计，那么你很有可能已经设计过一些网页了。在 iPhone X 的横屏状态下，你网页的左边和右边将会有很大一部分的空白。这是因为安全区域自动避免了内容裁剪，这是一个很糟糕的结果。为了避免这样的情况，苹果针对 iPhone X 横屏模式下的网页创建了一个网页适配指南。基本上，你可以扩展您的背景来填充整个屏幕，同时保留基于安全区域的内容 屏幕圆角内容裁剪的问题同样会发生在 iPhone X 的边角上。只有在你隐藏了导航栏和主屏幕指示器的情况下才会出现这样的情况，否则是不会出现这样的情况的，因为它们已经覆盖了这些边角。然而，对于大多数在全屏幕使用的应用，比如相机，确保角落里有足够的空间是很重要的。为了完美的适应圆角，你的按钮距离圆角的半径至少要有 16pt。 在模拟器上预览应用iPhone X 的设备还没有发售，只有在发售后才能够购买到，所有大多数人是见不到的。如果没有设备在手上，那么唯一的体验方式就是通过 iOS 模拟器。你可以通过安装 Xcode 来预览你的网页和应用。 消失的汉堡菜单十年来，设计师们都在努力地将自己的内容融入到初代的 iPhone 的小屏幕上。很多的设计师决定删掉标签栏，因为它占据了太多的屏幕空间。一些有创意的人决定在左边放一个按钮。这就是著名的汉堡菜单的诞生。虽然一开始的时候觉得很有趣很新鲜，但是在可用性上来说这就是一个噩梦。这需要多次的点击才能进入到其他的屏幕。因此这意味着次要标签的使用减少，人们常常忘记那里有更多的内容。 在大屏幕的使用下，单手操作受到了影响。苹果甚至做到了双击主屏幕按钮来下滑整个 UI 界面使导航栏到达大拇指可以触及到的范围。汉堡菜单通常位于屏幕的左上角，想要够到这个菜单就会有点困难。所以，这样转变到了双击进入菜单。但是在更高的屏幕下，就不在需要为了更多更多的空间这样做。现在标签栏是取代汉堡菜单很明显的选择，因为有了更多的空间。在 iPhone X 上更好的巩固了这样的方式。如果您的应用程序中有多个部分，那么没有理由不使用标签栏。在横屏的情况下，在 iOS 11 中，标签栏的空间更小。 汉堡菜单在网页上是很普遍的，这也就说明了移动设备上网页的体验是没有原生 App 体验好的原因。甚至 ReactNative 都使用了原生控件，这是一个很好的发展方向，对于网页技术来说。不管怎么样，在 iOS 中尤其是在 iPhone X 上，你应该使用标签栏来替代汉堡菜单。 自适应布局和多任务随着不同分辨率设备的增加，使你的布局能自适应各种分辨率是非常重要的。使用像 Sketch 的约束和 Xcode 的自适应布局这样的工具的时候，你必须以能够灵活的适配各种屏幕大小的方式去设计，如果有需要可以显示额外的菜单。 Stack Views在 Xcode 中你可以找到 Stack Views，这是一个可以让你的布局更加灵活响应的工具。相同的元素和分组可以动态的叠加在一起，你只需要编辑元素间的距离以及如何填充这个空间。然后你就可以完成自适应布局了。苹果建议先使用 Stack Views，然后在使用自适应布局。 点和像素开发者使用点数值来工作的，所以理解点和像素的区别是很重要的。当 iPhone 首次推出的时候这两个地方是一样的，1pt 等于 1px。但是没有多久视网膜屏幕就到来了，1pt 变成了 2px。所以，将初代 iPhone 中的点作为原始值。点以实际像素为准，根据像素密度而定（iPhone 4, 5, 6, 7, 8 = @2x, iPhone 8 Plus, iPhone X = @3x）。可以观看这个视频以更好的理解点和像素之间的区别。 iPhone的分辨率iPhone 主要有以下五种分辨率： 320 x 480 pt (iPhone 4S), 320 x 568 pt(iPhone SE), 375 x 667 pt (iPhone 8), 414 x 736 pt (iPhone 8 Plus) and 375 x 812 pt (iPhone X)。布局不是按比例扩展的，而是基于分辨率扩展的。例如，导航栏只是调整了宽度，高度不变，但是里面的元素是不受影响的。 iPhone Plus 系列是唯一一个在横屏模式下更像 iPad 的 iPhone。也就是说在 Plus 系列上左边的导航栏可以取代标签栏。 iPhone Size ClassesSize Classes 允许你根据屏幕的宽度和高度进行分类，并根据这些分类设置条件。例如，你可以决定在 Compact 宽的屏幕中使用 30 30 pt 的头像，在 Regular 宽的屏幕中使用 50 50 pt 的头像，就是因为在更大的屏幕上有更多的空余的空间。Size Classes 在常规的 Auto Layout 的基础上进行自己定义布局，可以完美的呈现横屏模式和竖屏模式下的区别，或者 iPhone 和 iPad 之间。 在 Size Classes 中宽度和高度有三种不同的类型：Compact，Regular 和 Any。通过使用 Size Classes 对不同设备的合并，你将一次适配影响多个设备。例如：Compact（width） * Regular（height） 对应的目标是所有竖屏模式下的iPhone，但是不会对横屏模式和 iPad 产生影响。 有趣的是 Compact * Compact 的模式将会作用于所有横屏模式下的 iPhone （iPhone 6+，7+，8+除外），尽管屏幕的宽度相当的大。因此，熟悉不同的组合是很重要的，如下图所示。 App Icon应用图标用于你的应用程序的商标。这是用户首先会体验到的。它会出现在主屏幕，应用商店，聚焦搜索和设置中。 图标支持@1x（一倍图） 部分的图标已经不在支持 iPhone 了，所以你不需要生成它们。现在应用程序图标有两个部分：@2x（二倍图） 和 @3x （三倍图）。它们有三种类型：应用程序图标，聚焦搜索和设置。对于 iPad 使用 @1x（一倍图） 和 @2x（二倍图）。 完美圆角从 iOS 7开始，图标从普通的圆角图标变成了完美圆角。有一件你需要记住的很重要的事就是在导出图标的时候不要连通遮罩一起导出，否则你会发现有一些黑色的部分。相反的，只需要导出正方形这部分用于应用商店。在 Sketch47 中，你可以使用 Smooth Corners 来创建这个图形。 图标网格苹果在一些图标上应用了黄金比例。这样保证了图标在很受欢迎的同时保持良好的比例。尽管这是一个很好的切受欢迎的规则，但是这并不是必须的规则。甚至苹果在以部分图标中省略了这个规则。 颜色iOS 使用鲜明的颜色来现实按钮。这些颜色更倾向于在白色背景中工作的更好，比起在黑色背景中。请记住应该尽量少的使用颜色，对于发起操作的部分和小的标签区域 ，例如导航栏。粗略的来说，在你的设计中应该仅仅只需要 10-20% 应该有颜色，否则的话过多的颜色会对内容造成不好的影响。 iOS 中常常使用比较中性的颜色来作为背景色和菜单区域。一个很好的差异是黑色的文本在白色背景中可以使得阅读更加的舒适。最后，用柔和的蓝色来让按钮脱颖而出。 系统字体目前该系统中的字体被称为 SF Pro Text。这是用于显示小于 20pt 或者 20pt 以及大于 20pt的文字。需要注意很重要的一点是当使用系统字体的时候，你可以访问动态类型，它可以根据用户的偏好设置调整字体大小。 按钮和字体大小一般情况下的规则按钮字体大小为 44pt，小文本的字体大小为 12pt，正文文本字体大小为 17pt，20pt+ 的字体则用于标题。 间距和对齐一般情况下，最小的的外边距或者内边距为 8pt。这就创造了足够的呼吸空间，这让排版更加易于浏览，以及更强的文字可阅读性。另外，UI 元素应该对齐，文本应该有相同的基准线。 状态栏（Status Bar）建议尽量在所有的地方都包含状态栏，因为用户依靠它获取一些重要的信息，如：信号，时间，电量。文字和图标颜色可以是白色和黑色，但是背景色是可以自定义的，以及可以和导航栏合并。 导航栏（Navigation Bar）导航栏是用来快速获取屏幕信息的。左边部分可以用于返回、配置文件、菜单按钮，然而右边部分通常同于操作按钮，比如，添加、编辑、完成。需要记住的是如果你使用这些系统自带的图标，你是不需要创建为它们创建资源的。 就像状态栏一样，背景色也是可以自定义的，并且通常会有轻微的模糊效果以保证文字始终是易读的。当状态栏出现时，背景是可以合并的。 搜索栏（Search Bar）当你有大量的内容的时候，比较明智的做法是让其是可以搜索的。 工具栏（Tool Bar）当你需要更多的固定的地方来放置你的操作按钮以及屏幕状态的时候，你可能会想要使用工具栏 标签栏（Tab Bar）标签栏在多个屏幕间是主要的导航工具。如果你的项目很少，请忽略汉堡菜单。总是可见的菜单会增加使用，因为显而易见的总是能够赢得关注（abvious always win）。另外建议在图标旁边添加文本，因为在这些图标还没有被普遍认识的时候，大部分的人不会立即识别图标的含义。 状态当标签处于非活跃状态的时候图标将会变成灰色。就像下面这样，这样可以减少注意力的吸引。 列表（Table View）Table View 是一个很常见的用于列表视图的控件。很多 App 都使用 Table View，那是因为这是非常基础的，以及可以高度自定义到每一个小的元素。 基本样式在基本使用中，你可以使用以下这几种预设的样式和附加操作。 分区Cell 同样是可以分组的，可以在上面添加标题，下面添加描述。 集合视图（Collection View）当你的视图中有网格样式同时有多行和多列的时候，你将需要 Collection View。虽然这个有点高阶，但是你可以使用它创建任何你想要的布局。 集合试图布局Collection View 布局可能是下面这样的，或者是它们的组合。有无限的可能性。 模态警告对话框用于传递关键信息和提示，以及及时操作。 活动模态视图活动提示框允许你通过iOS的功能分享内容（文本，图片，链接），如 Airdrop，收藏，书签，或者应用程序，比如：邮件，Facebook，Twitter。虽然外观是不能自定义的，但是这些选项是可以的。 全屏模态视图当你要呈现较多信息的时候，你可以设计一个全屏的模态视图，典型的有滑动出现，渐变，或者页面动画。和其他的模态视图一样，必须易于取消，以及尽可能简短的内容。 键盘键盘用来输入信息到输入控件（Text Field）中。比如，搜索，聊天或者登录。键盘是可以高度自定义的，用于，URL，Email，电话号码，甚至是 Emoji 表情。你可以选择亮色和暗色主题，以及设置操作按钮的标题（return 是默认的）。 选择器（Picker）当您有多个选项可供选择时，您可以使用选择器控件。它对日期特别有用，它可以通过一个操作控制 3 个不同区域。 分段选择器（Segmented Control）当标签栏导航到主要分区时，分段控制用子分区的选择。 滑动控制器（Slider）滑动控制器是一个不怎么精确的可交互控制器，但是在快速设置类似于音量，屏幕亮度和视频播放进度的时候非常有用。 进度条进度条用来标示显示操作还有多久能完成。例如，你可以使用它来显示网页视图的加载进度。记住它的高度是可以自定义的。 开关开关用来快速切换打开关闭状态的。不要用它来做开关以外的任何使用。 步进器（Stepper）操作上比滑块更慢但更精确的一个控件，Stepper 允许用户通过点击来增加一个值或减少一个值。边框和背景是可以自定义的。 iOS图标下面列出的图标是 iOS 中原生的图标。由于它们经常被使用，所以用户可以很快的识别出它们的含义。如果将这些图标用于其他的目的，会让用户感到很困惑。因此了解它们在iOS中是如何使用的是很重要的。 当你使用自定义图标的时候，应该使用大家所有熟知的图标，这是很重要的。另外建议在使用自定义图标的时候，应该配有 10pt 大小的文字。 资源这些模版不仅用于学习，你可以重用或者自定义，所以你不必从头开始，这样可以避免一些错误。当你对这些东西越来越熟悉的时候，你将会变得更加有创造力。 iOS11 苹果官方GUI如果你正在对 iOS 做设计，你会想要使用预置元素，例如状态栏，导航栏，标签栏。通过苹果官方的支持，熟悉所有的颜色，尺寸，字体和组件。 iOS11 GREAT SIMPLE GUI最完成的 iOS GUI，有很多有可玩性的元素。 矢量图设备模型这是我个人收集的超过 260 个矢量图设备模型，这可以用来完美的展示你的设计。这些设备在这本书中广泛的使用。 Facebook 设计资源这是一个很宝贵的 iOS 设计资源，包括了 SoundKit，各种的手持设备以及有用的 GUI。 禁忌这有一篇很优秀的关于 iPhone X 设计的文章，包括了一些在 iPhone X 设计上的设计禁忌的很好的个例。 UI 设计中规则有一些实践是你应该不惜一切代价避免的，特别是如果你是 iOS 新手的话。下面链接中是苹果公司一些简单的例子。即使是快速的浏览下也会为你增加很多的经验。 苹果官方设计提示 由 IVO MYNTTINEN 编写的 iOS 指南如果您想从不同的角度阅读更多关于iOS的信息，可以查看这个优秀的指南。 iOS设计指南","categories":[],"tags":[{"name":"Design+Code","slug":"Design-Code","permalink":"Aaronzjp.cn/tags/Design-Code/"},{"name":"iOS编程和设计","slug":"iOS编程和设计","permalink":"Aaronzjp.cn/tags/iOS编程和设计/"}]},{"title":"iOS 发现与自定义图标（Code + Design 翻译）","slug":"iOS-Icons","date":"2018-05-15T15:39:12.000Z","updated":"2018-11-24T09:33:52.156Z","comments":true,"path":"2018/05/15/iOS-Icons/","link":"","permalink":"Aaronzjp.cn/2018/05/15/iOS-Icons/","excerpt":"好的图标总是给人很熟悉的感觉，因为他们与我们每天看到的事物都是有联系的：相机，垃圾桶，云朵☁️。它们没有文字，但是设置了很友好的色调。在这一节中，你将要学到怎么找到好的图标，什么时候使用，什么时候不使用，以及如何自己制作，这样就可以使图标在你的应用程序中设计得更加漂亮。","text":"好的图标总是给人很熟悉的感觉，因为他们与我们每天看到的事物都是有联系的：相机，垃圾桶，云朵☁️。它们没有文字，但是设置了很友好的色调。在这一节中，你将要学到怎么找到好的图标，什么时候使用，什么时候不使用，以及如何自己制作，这样就可以使图标在你的应用程序中设计得更加漂亮。 iOS 图标在 iOS 11中，图标不仅仅只是线条了。当导航栏仍然使用线条图标的时候，标签栏图标普遍的使用了填充，更加的醒目，更容易识别。 图标状态用于标签栏的图标具有两种状态：灰色和有颜色的。当图标有颜色的时候，那意味着当前屏幕被选中。 常见图标你应该始终要选择那些比较容易识别的图标。并鼓励在图标下方配上文字，以便更加清楚明了。不是所有的图标都是大家公认的，所以需要仔细的挑选。先熟悉下 iOS 中自带的一些图标。 如果你不希望在图标下总是有文字，可以先介绍一下，这样在下次使用的时候就可以不使用文字描述了。一旦用户在第一次学习到了，那么在下一次中就不用再次学习了。 避免混淆避免使用苹果已经使用的图标用于不同的目的。这样可能会使用户感到困惑，因为他们已经在其他地方的使用上熟悉该图标了。 你不需要学习所有的事情，你只需要对学习充满好奇。当你需要它的时候，你就已经准备好了。 导航栏和标签栏图标导航条和标签栏中使用的图标的画布尺寸应该是30×30 pt。实际上，除了应用程序图标以外，大多数图标都是这样的。 应用程序图标应用图标用于你的应用程序的商标。这是用户首先会体验到的。它会出现在主屏幕，应用商店，聚焦搜索和设置中。 @1x（一倍图） 部分的图标已经不在支持 iPhone 了，所以你不需要生成它们。现在应用程序图标有两个部分：@2x（二倍图） 和 @3x （三倍图）。它们有三种类型：应用程序图标，聚焦搜索和设置。对于 iPad 使用 @1x（一倍图） 和 @2x（二倍图）。 完美圆角从 iOS 7开始，图标从普通的圆角图标变成了完美圆角。有一件你需要记住的很重要的事就是在导出图标的时候不要连通遮罩一起导出，否则你会发现有一些黑色的部分。相反的，只需要导出正方形这部分用于应用商店。在 Sketch47 中，你可以使用 Smooth Corners 来创建这个图形。 图标网格苹果在一些图标上应用了黄金比例。这样保证了图标在很受欢迎的同时保持良好的比例。尽管这是一个很好的切受欢迎的规则，但是这并不是必须的规则。甚至苹果在以部分图标中省略了这个规则。 iOS图标集我们大多数都不是图标设计师。这就是为什么我们最好找到可以自己修改定制的矢量图标集。这是我所推荐的，我在个人项目中也是这样做的。有了这些图标集合你将有数以千计的图标可以选择。 PIXEL LOVE这5000个图标的集合与默认的iOS风格完美契合。它是目前我最喜欢使用的，因为它干净的外观和优雅的比例。 STREAMLINE一个有一点线条感和有趣的风格的 iOS 主题。如果你在寻找有一些不同的图标，那么 Streamline 就是，这里拥有超过 5000 个漂亮的图标。 IONICONS一个免费的图标集合，包含了大量的 iOS 原生的图标，以及数百个其他的图标。你可以像使用字体一样的使用它们。 FONT AWESOME2481个图标广泛用于网络和移动。你也可以像使用字体一样的使用它们。 IconFont Sketch 插件这个插件可以让你有数以千计的图标选择，图标来自 Font Awesome，Ionicons 和 Material icons。你可以像文字一样浏览，搜索，插入图标并转换成图标轮廓。 IconJar Mac 应用当你堆积了数千个图标时，很难找到需要的图标。IconJar 是一个很好的选择。（这是一个图标管理的应用，可以帮助管理图标）。 图标的使用现在你有了在 Sketch 中你喜爱的图标，你很想要学习如何使用以及自定义图标，以适应你 App 中的设计。在 Sketch 中这是相当简单的一个过程。 修改图标有些时候，图标并不是你完全想要的。在这些情况下，你会想要通过使用Union, Subtract, Intersect 和 Difference 来编辑图层。 Noun Project这个 Noun Project 是一个有超过一百万图标的Web和Mac应用程序。你所需要做的就是搜索你想要的图标样式，在 SVG，PNG 或者 PDF 格式中选择并自定义修改颜色。直到你满意为止，你可以直接将图标拖到你 Sketch 的画板中。 FontelloFontello 是一个很好用的工具，尤其是当你和开发者一起工作的时候。这是一个 Web 应用，可以使用 CSS 来编辑图标字体。在你创建完成图标后，可以导出到 SVG 格式。导入图标并单击“下载web字体”。你会在demo中找到你的图标。html和CSS文件。 Sketch IconsSketch Icons 是一个简洁的插件，可以导入一组图标或文件夹，并将其转换为动态图标库。该插件自动将彩色遮罩应用于你的图标，可以定制。","categories":[],"tags":[{"name":"Design+Code","slug":"Design-Code","permalink":"Aaronzjp.cn/tags/Design-Code/"},{"name":"iOS编程和设计","slug":"iOS编程和设计","permalink":"Aaronzjp.cn/tags/iOS编程和设计/"}]},{"title":"iOS11设计概览（Code + Design 翻译）","slug":"iOS11-design-guide","date":"2018-04-22T14:23:12.000Z","updated":"2018-11-24T09:33:38.926Z","comments":true,"path":"2018/04/22/iOS11-design-guide/","link":"","permalink":"Aaronzjp.cn/2018/04/22/iOS11-design-guide/","excerpt":"在过去的五年时间扁平化设计已经变得很普遍了，但是在 iOS7 之前却并不普遍。正是因为这样设计风格开始转变，但是说这样的设计没有太多的变化是不准确的。iOS 的设计已经适应了更大的屏幕，与之前超写实拟物设计风格恰恰相反。现在扁平化的设计更加的微妙，在去掉了渐变、阴影、卡片等设计后。 iOS的演变让我们从头开始，看看下面的一组图片。在最左边是超写实设计，也就是我们所熟知的拟物化设计。这样的拟物化的设计在2007年是很有效的，因为那个时候很少人熟悉放在你口袋里的超级计算机。 在中间的这个图中，我们去掉了所有的装饰，使用带有色彩，漂亮字体以及简介清楚的内容的扁平化设计。由于人们对现代技术越来越熟悉适应，以及对智能手机的熟悉，所以在设计上去掉了原本厚重的装饰。","text":"在过去的五年时间扁平化设计已经变得很普遍了，但是在 iOS7 之前却并不普遍。正是因为这样设计风格开始转变，但是说这样的设计没有太多的变化是不准确的。iOS 的设计已经适应了更大的屏幕，与之前超写实拟物设计风格恰恰相反。现在扁平化的设计更加的微妙，在去掉了渐变、阴影、卡片等设计后。 iOS的演变让我们从头开始，看看下面的一组图片。在最左边是超写实设计，也就是我们所熟知的拟物化设计。这样的拟物化的设计在2007年是很有效的，因为那个时候很少人熟悉放在你口袋里的超级计算机。 在中间的这个图中，我们去掉了所有的装饰，使用带有色彩，漂亮字体以及简介清楚的内容的扁平化设计。由于人们对现代技术越来越熟悉适应，以及对智能手机的熟悉，所以在设计上去掉了原本厚重的装饰。 最右边这便是 iOS11 的截图，更加突出的标题，以及更强的可读性。因为有更高的屏幕，所以底部导航栏也越来越常见。在设计上设计师也需要根据不同的分辨率和尺寸去调整布局。不过好消息是我们有更好的工具例如 Sketch，Xcode ，去适应这些新的技术。 大标题iOS11 比以往的设计更加回归本质，因为有了比以往高出两倍的屏幕高度，所以有无处不在的醒目的字体，更大的标题，黑色的字体。这样才有大标题存在的意义。另一个原因是更大的字体更加容易阅读和理解。 每天有数十亿的各个年龄阶段的人都在使用手机，重要的是尽可能的让内容更加的清晰，更高的可读性，便于理解。 在 iOS11 的辅助功能中，可以设置更大的字体，在支持该功能的 App 中字体也会被设置成相应的大小。苹果所有的自带的 App都支持这个选项。因为你发现现在用户对这个功能非常的期待 卡片更大的屏幕意味着可以展示更多的内容。在大屏 iPhone 出现之前，摆脱屏幕的限制显示更多的内容。但是当 iPhone X 和 iPhone 8 出现了就不用这样了。我们可以简单的利用导航栏，状态栏，底部导航栏以及卡片来更好的排版内容。 带有圆角的卡片设计可以让内容看起来更加的有触感和友好。你可以使用模糊背景和底部阴影在你的设计上增加深度和背景。 iOS设计现状现在的设计更加的简单，让我们更加专注于动画和功能的设计而不是更多的视觉细节。在 iOS7 之前，我每天需要花费大量的时间在设计复杂的纹理，比如木头，皮革，和金属感。今天我花同样多的时间在动画和代码上，不再是静态的设计，而是怎样让设计更加生动，更加深层次的与用户交互。这也是为什么我写这本书的原因，不仅仅是因为视觉设计。从技术的角度来看，动画和代码从未如此重要。这就是为什么我们几乎每周都能看到新的原型工具和代码框架的出现。与此同时设计变得更加的宽泛，也与许多学科有着相互的联系。当一个设计师对于他相关联的学科有了更多的了解，他就能在他工作的过程中变得独立，与此同时也能成为工程师更好的搭档。 我已经被闻到很多次了，怎么开始学习设计，以及如何快速的成为一个好的设计师。在这里，虽然没有很好的方法，但是关于 iOS 有一些技巧和规则将会影响你的设计方式。 即使你为完全不同的平台设计，但是同样的设计理念，以及同样的技术都可以应用在 Web 和印刷中。iOS 是一个让设计回归本质的平台。像是阅读现代杂志一样，漂亮的排版以及简单的布局。你在这本书中学到的知识，将会为你创造更好的产品打下基础。 核心理念让我们来回顾一下基本要素。iOS 由三个核心理念驱动：遵从原则(Deference)、清晰明确(Clarity)、深度，层次感(Depth)。受这些设计原则的启发，将这些拆分为可以具体操作的步骤，比起那些指南更加简单，更加有视觉上的直观感受。 遵从原则(Deference)你的内容应该是主角，其他的都是次要的。使用设计元素的时候要考虑这些与元素在视觉上是否会与内容有所冲突，影响内容。比如，使用漂亮的动画，从一个屏幕优雅的过渡到另一个，让用户不会一脸懵逼。模糊背景可以使用户将注意力放在前面的内容上。如果有什么疑惑可以从这里提供的模版开始学习。 简洁你的 UI 应该精简，但要保持核心审美观。每一次添加元素，你都要问自己：这是必需的吗？除非你的 App 是一个游戏或者是一个特定的主题，这样你可以使用厚重的纹理，3D效果，以及各种阴影。否则应该更加关注于颜色，和谐的颜色搭配和漂亮的排版。 内容最大化内容应该填满整个屏幕，让里面的每个元素获得最大的空间。避免容器相互嵌套叠加，最大化滚动区域，以允许更多的交互空间。 颜色使用显眼的颜色来标示元素是可点击的，和处于高亮状态的部分。选择正确的颜色和中性的色调保持设计的不会显得突兀被破坏。蓝色对于按钮和状态的显示是一个保险的选择。另外建议使用白色或者亮灰色来作为黑色字体的背景，这样提供了极好的对比，这对于提高可读性是非常好的选择。 排版即内容由于对界面的简化和对内容的关注，你的排版将占据整个屏幕的 50-90%。所以选择一个漂亮的字体，设置字体粗细，行高，颜色，以在愉悦的视觉感受和易读性上是十分重要的。默认的旧金山(San Francisco font)字体是推荐的选择，因为它是为提高易读性设计的。苹果在所有的 App 中都使用该字体。 留白使用留白把焦点转移到内容上。你看到的越少就越能把注意力集中于某一事物。留白给出了 UI 元素间舒适的空间。不要使用太多的结构和不必要的视觉元素来覆盖屏幕。如果还是不明白就使用 Xcode 中默认的边距，苹果通常使用的边距在 8pt 到 16pt 之间。 清晰(Clarity)让一切更明显。按钮应该是一目了然的，排版文字应该尽可能大，且易读性强，元素与元素间有舒适的距离。你的内容应该清晰明确标示出你的 App 是干什么的。比如，这是一个关于咖啡的 App 那么应该能使你想起咖啡豆、浓缩咖啡、或者咖啡色。 文字的易读性标题应该尽可能的大，且对比鲜明。带有说明性的副标题文字应该简短且易于浏览。正文文本应该有良好的间距，避免文字内容太长造成阅读疲劳。 正文文本的大小至少要有 11pt。易于阅读的文字最佳大小是 17pt 到 19pt 之间，屏幕标题应该在 34pt 或者以上，正文标题应该设置在 20pt 到 30pt 之间。整齐的文本和其他元素可以易于浏览。最后使用黑色或者深灰色文本与亮色的背景呈现出鲜明的对比。 一目了然的图标图标应该显而易见，不应带有歧义也模糊的含义，应该清楚明确的标示出图标的含义。无论如何都应该使用文字搭配图标。一旦使用了一个图标，就不要在其他地方出现该图标的变种或者在其他地方使用一样的图标，这样会是用户感到困惑。同样的也不要使用通用的文本比如：“返回”、“提交”等，应该使用更加具体的文本，比如：“返回到主页”、“注册一个新的账户”。设计图形，矢量图标等，要让其易于适配不同分辨率的屏幕，以确保可以在 @1x、@2x、@3x下正常使用。 屏幕的描述每一个页面都应该清楚的解释它是用来干什么的。应该有一个小的标示或品牌用来取代干净的屏幕标题，或者底部状态栏高亮突出显示的标签。在选择图片的时候要慎重，最好是选择具有代表性的。 颜色的含义颜色是具有意义的，明知的使用红色、绿色、蓝色、或者中性的颜色来分别代表具有破坏性的操作，肯定的操作，或者是链接和不可活动状态。为不同的操作使用不同的颜色，避免用户产生困惑。比如：不要在表示“删除”的按钮上使用绿色。 触摸元素的设计按钮应该是易于触摸的。按钮的尺寸的宽度应该在 30-60pt 之间。最佳的尺寸为 44pt。在很少的情况下会设置为 22pt 比如文本中的链接，但是要很谨慎的这样使用，因为这样会变得很难点击。即使是文本按钮也有至少 30pt 的触摸区域。当打开图片的时候应该具有手指捏合缩放的功能和手势滑动返回到上一个页面的功能。 横屏模式用户常常在横屏模式下使用 iPad 和大屏的 iPhone。在横屏模式下 App 将显示更小的导航栏和底部导航栏，状态栏会被隐藏。有时候在左边会显示额外的菜单，就像在 iPad 上那样。自适应布局是一种根据屏幕大小调整布局的方法，现在是很常见的做法。得益于 Xcode 中 AutoLayout 和 Size Classes 的功能，基于屏幕方向修改布局变得相当的简单。所以不用担心在设计中对该功能的支持。 层次感或许这是最难理解的一部分，这是一个非常抽象的概念，但同时也是非常强大也独特的。深度是一种观念，即一切事物都应该是有上下文和过渡的。在现实生活中，当你从一个房间走到另一个房间，你会有一种距离前进缩短的感觉，这样就不会导致很迷惑。这个同样的概念应该应用到用户交互上。 对人的冷漠和他们所生活的现实，实际上是设计中唯一的罪恶感。- Dieter Rams 过渡交互iOS 中最令人兴奋和独特的一面就是动画。每个屏幕从一个过渡到另一个。从主页面放大进入到文件夹，在放大进入到一个 App。以前的动画很难执行，但是得益于 Xcode9 它让动画变得比以前更加容易访问。实际上你将在 Swift 章节确切的学习这项技术。 背景模糊在保持背景UI上下文的同时不应该影响内容的清晰性。使背景模糊不仅能保持自然的颜色而且还能将用户的注意力带到前景中的内容上。模糊并不是一项发明，它已经存在于我们的生活中，当你专注于某些事的时候，其他的一切都会变得模糊。 你认为人们想要的，乘以10倍那才是你应该创造设计的。在人们的心中，任何少于一天的事情都不会持续太久。做对的事却会持续一生。 动画动画不仅仅是用于从一个屏幕过渡到另一个屏幕，同时也回为你的设计增加一些活波有趣和愉快的感觉。它对于那些很容易被忽略的元素来说是很重要的。通知中心就是非常明显的例子，还有天气 App 中当背景下雨的时候可以更好的帮助用户理解。 虽然很鼓励使用动画，但是不应该太过夸张的使用。太过夸张的使用动画不但会分散用户的注意力，还可能会使用户感到眩晕。没有缘由出现的身影的动画会让用户感到无所适从。相反当用户对内容进行操作的时候使用动画让用户感知到操作的反馈，以及使用动画优雅的将用户的注意力转移到操作的进度上。 最后，在动画的展现上要切合实际。从屏幕底部模态画出的视图，在返回的时候也应该返回到屏幕的底部。这样用户就能真切的感知到元素的存在，即使是呈现在屏幕上的。 手势随着手机屏幕越来越大，返回按钮对于大拇指能触摸到的区域来说太高了。因此对于一个明显可见的按钮来说一个可见的手势交互也是不错的方式，让用户更加容易使用。这就是为什么需要使用一些视觉线索和一些更加有用的功能。 三维触控三维触控的功能允许用户快速的访问可选的功能进入 App 和退出 App。想象一下三维触控就像你 Mac 上的快捷键一样，可以让用户快速的完成重复性的任务。你必须设计一些快捷键让用户更加有效率。但是就像键盘的快捷键一样，这些功能不应该是只能通过三维触控才能访问的，用户在正常使用 App 的时候必须也能访问这些功能。 比如用户可以用力按压 App 的图标来访问经常使用的项目。在一个 App 中用户可以通过按压屏幕在进入到全屏之前查看里面的内容。 声音在 App 中很少使用声音，但是当它们被使用到 App 中被播放的时候，声音可以把一个很乏味的任务变成一个很有趣的体验，让体验更好。用户可以在没有看到任何具有辨识性东西的时候识别出你的 App，比如通过推送通知的声音。当声音给用户留下好的印象，这会是很好的加分，在用户心中。 好的设计是通用的，你不需要过度的文字修饰。人们只管使用它 进一步的阅读一个可以更加深入了解的文档，就是来自苹果的官方文档。建议可以浏览下，可以看下觉得自己需要的部分，因为这个文档是非常的详细的。","categories":[],"tags":[{"name":"Design+Code","slug":"Design-Code","permalink":"Aaronzjp.cn/tags/Design-Code/"},{"name":"iOS编程和设计","slug":"iOS编程和设计","permalink":"Aaronzjp.cn/tags/iOS编程和设计/"}]},{"title":"JavaScript-BOMAndDOM","slug":"JavaScript-BOMAndDOM","date":"2018-04-19T06:37:13.000Z","updated":"2018-06-19T05:48:00.198Z","comments":true,"path":"2018/04/19/JavaScript-BOMAndDOM/","link":"","permalink":"Aaronzjp.cn/2018/04/19/JavaScript-BOMAndDOM/","excerpt":"BOM(浏览器对象模型)JavaScript 可以获取浏览器提供的很多对象。浏览器对象模型（Browser Object Model）尚无正式标准。由于浏览器已经实现了 JavaScript 交互性方面的相同方法和属性，因此常被认为是 BOM 的方法和属性。 window 对象所有的浏览器都支持 window 对象，表示浏览器窗口。window 是一个全局对象，不但这样所有 JavaScript 全局对象、函数以及变量都会成为 window 对象的成员。","text":"BOM(浏览器对象模型)JavaScript 可以获取浏览器提供的很多对象。浏览器对象模型（Browser Object Model）尚无正式标准。由于浏览器已经实现了 JavaScript 交互性方面的相同方法和属性，因此常被认为是 BOM 的方法和属性。 window 对象所有的浏览器都支持 window 对象，表示浏览器窗口。window 是一个全局对象，不但这样所有 JavaScript 全局对象、函数以及变量都会成为 window 对象的成员。 通过 window 对象我们可以获取到浏览器内容的尺寸 12var width = window.innerWidth;var height = window.innerHeight; 当然也可以获取浏览器窗口的尺寸 12var outWidth = window.outerWidth;var outHeight = window.outerHeight; window 还有一些其他的方法。 1234window.open() // 打开新窗口window.close() // 关闭当前窗口window.moveTo() // 移动当前窗口window.resizeTo() // 调整当前窗口的尺寸 screen 对象通过 screen 对象可以获取设备屏幕相关的信息。 1234567screen.width; //屏幕宽度screen.height; //屏幕高度screen.availWidth //可用屏幕宽度screen.availHeight; //可用屏幕高度screen.colorDepth; //屏幕色彩位数 navigator 对象navigator 对象中可以获取到浏览器的相关信息，以及常用的属性。 12345navigator.appName //浏览器名称；navigator.appVersion //浏览器版本；navigator.language //浏览器设置的语言；navigator.platform //操作系统类型；navigator.userAgent //浏览器设定的User-Agent字符串。 但是需要注意的是 navigator 的信息可以很容易的被用户修改，所以得到的值不一定是正确的。 location 对象通过 location 对象可以获取到当前页面的 URL 地址。 123window.location.href// 获取当前页面 URL 地址// http://www.w3school.com.cn/js/js_window_location.asp 获取 location 其他信息 12345678window.location.host// www.w3school.com.cn web主机的域名window.location.protocol// http 当前页面使用的web协议window.location.port//端口window.location.pathname//当前页面路径和文件名 也可以通过 location 加载新的文档 1window.location.assign(\"http://www.google.com\"); document 对象document 对象表示当前页面，在 HTML 浏览器中 DOM 形式表示为树状结构，document 就是整个 DOM 树的根节点。通过 document 可以动态的修改当前页面。 1document.title = \"学习 JavaScript 中！\"; 在浏览器的控制台中输入上面的代码，可以看到浏览器的标题被修改了。 要查找 DOM 树的某个节点就需要从 document 对象开始查找，常用的是更加 HTML 元素的 id 和 tagname 来查找。 document 对象还有一个 cookie 属性，可以获取到当前页面的 cookie。cookie 主要存储了用户的一些相关信息，比如用户登录相关信息，区分用户，等就可以使用 cookie 来实现。此后浏览器在访问该网页的时候就会在请求头中附上这个 cookie 。基于安全。cookie 一般都是要设置 httpOnly 的，设置了 httpOnly 的 cookie 是不能被 JavaScript 读取到的。 history 对象history 对象保存了浏览器的历史记录。可以通过 JavaScript 调用 history 对象的 back() 和 forward() 对象来前进后退页面，相当于用户点击了前进和后退按钮。但是尽量不要使用这两个方法。 DOM(文档对象模型)HTML 文档被浏览器解析后就是一颗 DOM 树，要改变 HTML 文档的结构，就需要通过 JavaScript 来操作 DOM。 操作 DOM需要始终记住的是 DOM 是一个树状结构。操作一个 DOM 节点实际上就是如下几个操作： 更新：更新 DOM 节点的内容，相当于更新了 DOM 节点表示的内容； 遍历：遍历节点下的子节点； 添加：在 DOM 节点下新增一个子节点，其实就是动态的添加了一个 HTML 节点； 删除：从 DOM 中删除一个节点，相当于删除了该节点的内容以及该节点包含的所有的子节点。 在对 DOM 节点进行操作的时候，首先是要获取该节点。最常用的方法有如下几个： document.getElementById()。 document.getElementsByTagName()。 以及 CSS 选择器的方法： document.getElementsByClassName()。 document.getElementById() 该方法是通过 ID 获取的，在 HTML 中 ID 是唯一的，所有可以用来直接获取唯一的一个DOM节点。document.getElementsByTagName() 和 document.getElementsByClassName() 是通过标签名和类名来获取节点的，在 HTML 文档中这些都不是唯一的，所有总是返回一组节点，想要通过这两个方法精确的获取及诶单，可以一层一层的获取，缩小范围。 例子： 123456789101112131415//返回 ID 为 header 的节点var test = document.getElementById('header');//先通过 ID classNumber 获取节点，在获取其下的所有 tag 为 workmate 的节点var names = document.getElementById(\"classNumber\").getElementsByTagName:(\"workmate\");//通过 ClassName 获取节点var weather = getElementsByClassName('weather');//获取 weather 下的所有子节点var weathers = weather.children;//获取 waether 下的第一个子节点var first = weather.firstElementChild;//获取 waether 下的最后一个子节点var last = weather.lastElementChild; 第二种获取 DOM 节点的方法是使用 qureySelector() 和 querySelectorAll()。使用该方式获取节点需要了解 selector 语法，该方式还可以通过条件来获取节点。 12345//获取 ID 为 name 的节点var name = document.querySelector('#name');// 通过querySelectorAll获取q1节点内的符合条件的所有节点：var ps = q1.querySelectorAll('div.highlighted &gt; p'); 需要注意的是这两个方法在 IE&lt;8 的版本中是不支持的，IE8 也仅支持部分。 更新 DOM","categories":[],"tags":[]},{"title":"JavaScript-面向对象编程","slug":"JavaScript-OOP","date":"2018-04-11T05:56:16.000Z","updated":"2018-04-20T09:24:07.699Z","comments":true,"path":"2018/04/11/JavaScript-OOP/","link":"","permalink":"Aaronzjp.cn/2018/04/11/JavaScript-OOP/","excerpt":"JavaScript 标准对象对象的类型在 JavaScript 中一切都是对象，但是 JavaScript 中的对象是有类型的，在 JavaScript 中使用 typeof 来获取对象的类型，返回的是类型的字符串 123456789typeof 123; // 'number'typeof NaN; // 'number'typeof 'str'; // 'string'typeof true; // 'boolean'typeof undefined; // 'undefined'typeof Math.abs; // 'function'typeof null; // 'object'typeof []; // 'object'typeof &#123;&#125;; // 'object' 感觉没啥卵用，根本区分不出来对象的类型。。。。","text":"JavaScript 标准对象对象的类型在 JavaScript 中一切都是对象，但是 JavaScript 中的对象是有类型的，在 JavaScript 中使用 typeof 来获取对象的类型，返回的是类型的字符串 123456789typeof 123; // 'number'typeof NaN; // 'number'typeof 'str'; // 'string'typeof true; // 'boolean'typeof undefined; // 'undefined'typeof Math.abs; // 'function'typeof null; // 'object'typeof []; // 'object'typeof &#123;&#125;; // 'object' 感觉没啥卵用，根本区分不出来对象的类型。。。。 包装对象在 JavaScript 中提供了包装对象，包装对象使用 new 创建 1234567891011var number = new Number(123);var string = new String('123');var boolean = new Boolean(true);console.log(typeof number);console.log(typeof string);console.log(typeof string);console.log('------------------------------')console.log(number === 123);console.log(string === '123');console.log(boolean === true); 包装后的对象，类型会变成 object 这个时候在使用 === 去判断是永远都不能相等的。 所以在类型判断和转换的时候注意以下几点 不要使用new Number()、new Boolean()、new String()创建包装对象； 用parseInt()或parseFloat()来转换任意类型到number； 用String()来转换任意类型到string，或者直接调用某个对象的toString()方法； 通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) {...}； typeof操作符可以判断出number、boolean、string、function和undefined； 判断Array要使用Array.isArray(arr)； 判断null请使用myVar === null； 判断某个全局变量是否存在用typeof window.myVar === &#39;undefined&#39;； 函数内部判断某个变量是否存在用typeof myVar === &#39;undefined&#39;。 其中 null 和 undefined 是没有 toString() 方法的。 number 对象调用 toString() 方法也需要如下这样 123var numberString = 123..toString(); // '123', 注意是两个点！var newNumberString = (123).toString(); // '123'var pointNumberString = 3.14.toString; // '3.14' 带有小数点的 后面使用一个点就可以了 Date在 JavaScript 中，Date 对象是用来表示日期和时间的。简单的使用方式如下： 123456789101112'use strict';var now = new Date();console.log(now); //完整时间console.log(now.getFullYear()); //年份console.log(now.getMonth()); //月份console.log(now.getDate()); //日期console.log(now.getDay()); //星期几console.log(now.getHours()); //小时console.log(now.getMinutes()); //分console.log(now.getSeconds()); //秒console.log(now.getMilliseconds()); //毫秒console.log(now.getTime()); // 时间戳 number 类型 需要注意的是通过该方法获取的时间是本机时间，所以有可能是不准确的，用户可以手动的设置为任意的时间。 创建定制日期的 Date 对象： 12var newDay = new Date(2020,5,20,21,13,14,1000); //一次是年，月，日，时，分，秒，毫秒console.log(newDay); 需要注意的是在 JavaScript 中月份是从 0 开始的。其他都是从一开始，但是月是从 0 开始的。 第二种指定日期的方式就是解析一个符合 ISO8601 格式的字符串： 1234var d = Date.parse('2015-06-24T19:49:22.875+08:00');d; console.log(d);// 1435146562875 解析时间字符串的时候月份是从 1 开始的，但是这个方法返回的不是一个 Date 对象，而是一个时间戳。时间戳可以直接通过 Date 方法转换成 Date 对象。 123var newDay = new Date(1435146562875);console.log(newDay);//Wed Jun 24 2015 19:49:22 GMT+0800 (CST) 时区Date 对象表示的时间是按照浏览器所在的本地时区显示的，但是也可以通过调整，显示调整后的 UTC 时间 123456var d = new Date(1435146562875);d.toLocaleString(); // 2015-6-24 19:49:22//显示的字符串与操作系统设定的格式有关d.toUTCString(); // Wed, 24 Jun 2015 11:49:22 GMT UTC时间与当前时间相差8小时，东八区时间 JSONJSON是JavaScript Object Notation的缩写，它是一种数据交换格式。 在 JSON 以前都是使用 XML 传递数据，但是现在基本都是使用 JSON 传递数据，因为 JSON 相对于 XML 来说更加方便，高效。 JSON 中有如下的几种类型： number：和JavaScript的 number 完全一致； boolean：就是JavaScript的 true 或 false ； string：就是JavaScript的 string ； null：就是JavaScript的 null ； array：就是JavaScript的 Array 表示方式—— [] ； object：就是JavaScript的 { ... } 表示方式。 JSON序列化把一个 JavaScript 对象序列化成 JSON 字符串： 1234567891011121314151617181920212223242526272829var Jay = &#123; name: \"Jay Chou\", age: 45, gender: \"Male\", height: \"58\", skills: [\"Sing\",\"Magic\",\"BasketBall\"]&#125;;var jsonString = JSON.stringify(Jay);console.log(jsonString);//&#123;\"name\":\"Jay Chou\",\"age\":45,\"gender\":\"Male\",\"height\":\"58\",\"skills\":[\"Sing\",\"Magic\",\"BasketBall\"]&#125;//如果需要带格式的输出，可以加上参数var newJsonString = JSON.stringify(Jay,null,\" \");console.log(newJsonString);/*&#123; \"name\": \"Jay Chou\", \"age\": 45, \"gender\": \"Male\", \"height\": \"58\", \"skills\": [ \"Sing\", \"Magic\", \"BasketBall\" ]&#125;*/ 该方法第二个参数可以筛选对象的键值，如果只需要输出制定的属性，可以传入需要保留的键值的数组： 123456789101112131415161718var Jay = &#123; name: \"Jay Chou\", age: 45, gender: \"Male\", height: \"58\", skills: [\"Sing\",\"Magic\",\"BasketBall\"]&#125;;var filterString = JSON.stringify(Jay,[\"name\",\"age\"],\" \");console.log(filterString);/*&#123;test.js:42 \"name\": \"Jay Chou\", \"age\": 45&#125;*/ 也可以传入函数来对数据进行处理： 12345678910111213141516171819202122function convert(key, value)&#123; if (typeof value === \"string\")&#123; return value.toUpperCase(); &#125; return value;&#125;var functionFilterString = JSON.stringify(Jay,convert,\" \");console.log(functionFilterString);/*&#123; \"name\": \"JAY CHOU\", \"age\": 45, \"gender\": \"MALE\", \"height\": \"58\", \"skills\": [ \"SING\", \"MAGIC\", \"BASKETBALL\" ]&#125;*/ 同时还可以在对象中实现 toJSON() 方法用来控制序列化的数据： 12345678910111213141516171819202122var Jay = &#123; name: \"Jay Chou\", age: 45, gender: \"Male\", height: \"58\", skills: [\"Sing\",\"Magic\",\"BasketBall\"], toJSON: function () &#123; return &#123; 'Name': this.name, 'Age': this.age &#125; &#125;&#125;;var jsonString = JSON.stringify(Jay);console.log(jsonString);/*&#123;\"Name\":\"Jay Chou\",\"Age\":45&#125;*/ 反序列化JSON 字符串的反序列化很简单，只需要调用 JSON.parse() 方法就可以将 JSON 格式的字符串解析成对象： 12345var jsonString = '&#123;\"name\": \"JAY CHOU\",\"age\": 45,\"gender\": \"MALE\",\"height\": \"58\",\"skills\": [\"SING\",\"MAGIC\",\"BASKETBALL\"]&#125;';var JAYCHOU = JSON.parse(jsonString);console.log(JAYCHOU);// Object &#123;name: \"JAY CHOU\", age: 45, gender: \"MALE\", height: \"58\", skills: Array(3)&#125; 面向对象编程面向对象的三大特点是：封装、继承、多态。同时面向对象也还有两个很很重要的基本概念就是 类 和 实例，这一点在其他的面向对象的编程语言中就很突出的体现了这一点。但是在 JavaScript 中是没有 类 和 实例 这个概念的。在 JavaScript 中是通过 原型(prototype) 来实现面向对象编程的。 创建对象通过字面量创建对象 123456789var Jay = &#123; name: 'jay chou', age: 68, gender: 'male', height: 168&#125;;console.log(Jay.name);// jay chou 创建直接的实例对象，并依次赋值属性 12345678var newJay = new Object();newJay.name = 'jay chou';newJay.age = 68;newJay.gender = 'male';newJay.height = 168;console.log(newJay.name);// jay chou 使用对象构造器创建对象 123456789101112131415function Person(name,age,gender,height) &#123; this.name = name; this.age = age; this.gender = gender; this.height = height; //在对象中添加方法。 this.sayhello = function () &#123; console.log('Hello i am jay chou'); &#125;&#125;var jay = new Person('jay chou',45,'male',168);console.log(jay.name);jay.sayhello();// jay chou//Hello i am jay chou 在构造器创建对象中添加方法也很简单，直接赋值方法到属性。通过其他的方式创建的对象同样也可以通过给属性赋值函数对象来对对象添加方法。但是，在构造器创建的方法，在每个对象中不是共享的同一个方法，是两个不同的方法： 12345678910111213function Cat(name) &#123; this.name = name; this.say = function() &#123; return 'Hello, ' + this.name + '!'; &#125;;&#125;var cat = new Cat('kitty');var withteCat = new Cat('jerry');console.log(cat.say === withteCat.say);// false 想要多个对象共享同一个方法，把方法赋值到构造函数的原型上： 12345678910111213function Cat(name) &#123; this.name = name;&#125;Cat.prototype.say = function() &#123; return 'Hello, ' + this.name + '!'; &#125;var cat = new Cat('kitty');var withteCat = new Cat('jerry');console.log(cat.say === withteCat.say);// true 需要注意的是使用构造函数创建对象的时候如果没有写 new 那么这个函数就是一个普通的函数，会返回一个 undefined 。为了区分构造函数和普通函数，构造函数名都以大写字母开头，普通构造函数使用小写字母开头。除了这样还可以通过创建一个函数在内部封装 new 的操作，来防止。 123456789101112131415161718function Person(name,age,gender,height) &#123; this.name = name; this.age = age; this.gender = gender; this.height = height;&#125;Person.prototype.sayhello = function () &#123; console.log('Hello i am jay chou'); &#125;function creatPerson(props) &#123; return new Person(props || &#123;&#125;);&#125;var doubi = creatPerson(\"doubi\",21,'male',168);console.log(doubi.name);// doubi 原型继承在 JavaScript 中的继承和其他面向对象语言的继承是不一样的，因为在 JavaScript 中没有类的概念。在 JavaScript 中继承是通过原型的继承方式来完成的。JavaScript 中有一个叫原型链的东西。继承关系会根据原型链不断向上查找，最终原型链都会指向 null 。 以下是通过中间对象来实现原型链 123456789101112131415161718192021222324252627282930313233343536'use strict';function Animal (props) &#123; this.name = props.name || 'Unnamed';&#125;;Animal.prototype.eat = function () &#123; console.log('我要吃东西了，你可以走开吗？');&#125;function Dog (props) &#123; Animal.call(this,props); this.species = props.species || 'dog';&#125;;function F() &#123;&#125;;//将 F 的原型指向 AnimalF.prototype = Animal.prototype;//把 Dog 的原型指向 新建的一个 F 对象， F对象的原型又指向了 AnimalDog.prototype = new F();//修复 Dog 原型的构造函数为 DogDog.prototype.constructor = Dog;Dog.prototype.eat = function () &#123; console.log('我是狗🐶我要吃骨头');&#125;var husky = new Dog(&#123;name:\"DD\",species: 'Husky'&#125;);husky.eat();console.log(husky.name);console.log(husky.species); 以上就是通过一个中间对象实现的原型继承，也可以把这些封装起来，重复使用 1234567891011121314151617181920212223242526272829303132333435// 继承函数function inherits(Child,Parent) &#123; var F = function()&#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child;&#125;;function Person(props)&#123; this.name = props.name || 'unnamed'; this.age = props.age || 0; this.gender = props.gender || male;&#125;;Person.prototype.sayHi = function ()&#123; console.log(\"Hi!\");&#125;;function Chinese(props)&#123; Person.call(this,props);&#125;;// 让 Chinese 继承 Personinherits(Chinese, Person);// 重写 Chinese 的 sayHi 函数Chinese.prototype.sayHi = function () &#123; console.log(\"你好啊！\");&#125;;var Aaron = new Chinese(&#123;name:'Aaron',age:25,gender:'male'&#125;);Aaron.sayHi();var Edison = new Person(&#123;name:'Edison',age:40,gender:'male'&#125;);Edison.sayHi(); 关于 JavaScript 中的继承还有很多其他的方式，这个后面的时候再去深入学习。 class继承在新的 ES6 的规范中引入了一个新的关键字 class 。class 让类的定义更加的简单，相比起上面的 Person 的实现，使用 class 可以这样来实现。 123456789101112class Person &#123; constructor(name) &#123; this.name = name; &#125; sayHi() &#123; console.log(\"Hi!\"); &#125;&#125;var Aaron = new Person(\"Aaron\");Aaron.sayHi();// Hi! 通过 class 定义的对象如果想生成一个派生对象就更简单了。 12345678910111213141516171819202122232425262728293031class Person &#123; constructor(name) &#123; this.name = name; &#125; sayHi() &#123; console.log(\"Hi!\"); &#125;&#125;var Aaron = new Person(\"Aaron\");Aaron.sayHi();class Chinese extends Person &#123; constructor (name,age) &#123; super(name); this.age = age; &#125; sayHiInChina () &#123; console.log(\"你好啊！我叫\"+ this.name + \"!\"); &#125;&#125;var Edison = new Chinese(\"Edison\");Edison.sayHi();Edison.sayHiInChina();/*Hi!Hi!你好啊！我叫Edison!*/","categories":[],"tags":[{"name":"JS学习","slug":"JS学习","permalink":"Aaronzjp.cn/tags/JS学习/"},{"name":"JS基础","slug":"JS基础","permalink":"Aaronzjp.cn/tags/JS基础/"}]},{"title":"JavaScript-函数","slug":"JavaScript-Function","date":"2018-03-12T06:16:24.000Z","updated":"2018-04-11T05:57:21.780Z","comments":true,"path":"2018/03/12/JavaScript-Function/","link":"","permalink":"Aaronzjp.cn/2018/03/12/JavaScript-Function/","excerpt":"JavaScript 函数定义函数在 JavaScript 中定义函数的方式如下： 12345678function sum(number1,number2) &#123; if ( typeof number1 === 'number' &amp;&amp; typeof number2 === 'number')&#123; return number1 + number2; &#125; else &#123; throw 'Not a number'; &#125;&#125;sum(100,5) JavaScript 如果函数没有 return 语句，但是也是会有返回值的。其返回的结果是 undefined。","text":"JavaScript 函数定义函数在 JavaScript 中定义函数的方式如下： 12345678function sum(number1,number2) &#123; if ( typeof number1 === 'number' &amp;&amp; typeof number2 === 'number')&#123; return number1 + number2; &#125; else &#123; throw 'Not a number'; &#125;&#125;sum(100,5) JavaScript 如果函数没有 return 语句，但是也是会有返回值的。其返回的结果是 undefined。 在 JavaScript 中函数其实也是一个对象，所以可以像如下方式定义函数。 12345678var minus = function(num1,num2) &#123; if ( typeof num1 === 'number' &amp;&amp; typeof num2 === 'number')&#123; return num1 - num2; &#125; else &#123; throw 'Not a number'; &#125;&#125;;minus(10,2) 这样的方式定义的其实是一个匿名的函数，然后将这个匿名函数赋值给了 minus 。在调用的时候直接通过 minus 调用。 调用函数JavaScript 中，函数调用时需要注意的是，JavaScript 中的函数参数是没有个数限制的，也就是说函数参数是可以传入任意个数的参数。所以在 JavaScript 中定义函数的时候一定要做参数的检查，不然很有可能会引发一些不必要的错误。 在函数内部还有一个默认的参数， arguments 。该默认函数指向了函数调用者传入的所有参数。 arguments 有点像 Array 但是并不是 Array 。 如下，判断这个加法函数，如果参数不满2个就抛出错误提示，参数必须满足两个以上。 1234567891011function sum(number1,number2) &#123; if (arguments.length &lt;= 1) &#123; throw 'This Sum function Must hava two arguments'; &#125; else &#123; if ( typeof number1 === 'number' &amp;&amp; typeof number2 === 'number')&#123; return number1 + number2; &#125; else &#123; throw 'Not a number'; &#125; &#125;&#125; arguments 用于可选参数到操作。 12345678910/ foo(a[, b], c)// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：function foo(a, b, c) &#123; if (arguments.length === 2) &#123; // 实际拿到的参数是a和b，c为undefined c = b; // 把b赋给c b = null; // b变为默认值 &#125; // ...&#125; 使用 arguments 来获取我们定义的参数以外的参数，需要自己去处理 arguments 很是麻烦。在新的 ES6 的标准中引入了一个 rest 参数，用来获取我们定义的参数外的额外参数。 123456789101112function test(number1,number2,...rest) &#123; console.log('number1 =' + number1); console.log('number2 =' + number2); console.log('Other arguments = ' + rest);&#125;test(10,2,67,32,4346,6564,76);//输出如下number1 =10number2 =2Other arguments = 67,32,4346,6564,76 需要注意的是 rest 参数只能写在函数参数的最后，而且前面需要用 ... 标示出来。如果调用函数的时候没有传入参数，或者没有传入多余的参数，那么 rest 则为一个空的数组。（空数组不等于 undefined ）。 变量作用域在 JavaScript 中使用 var 声明的变量其实是有自己的作用域的。如果在函数内部声明一个变量，则该变量只作用于函数内部。所以多个函数中有同名的变量，他们是不会相互影响的。 JavaScript 中函数是可以嵌套的。在函数嵌套的情况下，变量的作用域是从内而外的。也就是说内部函数是可以访问外部函数的变量的，但是外部函数则不可以访问内部的函数变量。如下： 123456789'use strict';function foo() &#123; var x = 1; function bar() &#123; var y = x + 1; // bar可以访问foo的变量x! &#125; var z = y + 1; // ReferenceError! foo不可以访问bar的变量y!&#125; 如果内部函数的变量和外部函数的变量重名，则内部函数中的重名变量会屏蔽外部函数中的重名变量。 123456789101112131415'use strict';function test()&#123; var x = 5; function inside()&#123; var x = 100; console.log(x); &#125; inside(); console.log(x);&#125;test()//输出// 100// 5 变量提升在 JavaScript 中有变量提升的这样一个特性。在函数运行前会先扫描整个函数体中的变量，然后将声明的变量提升到函数顶部。也就是说，可以先使用变量，在再后面声明变量，但是需要注意的虽然会提升变量，但是并不会提升变量的赋值。 123456789101112131415'use strict';function test()&#123; var number = 3; var result = number + numberX; console.log('赋值前numberX = '+numberX); var numberX = 10; console.log('赋值后numberX = '+numberX); console.log(result);&#125;test()//输出赋值前numberX = undefined赋值后numberX = 10NaN 在这里变量 numberX 是在使用后声明的，没有报错的提示。但是 result 却等于 NaN 这就是因为变量被提升后不会报错，但是变量的赋值并没有被提升。在计算 result 变量的时候 numberX 是 undefined 所以最终 result 就是 NaN。为了防止这样的情况出现，最常见的做法就是在函数内部首先就把所有的变量提前声明。 全局作用域没有定义在函数内部的变量就是全局变量。 12var global = \"This is JavaScript\";//在函数外声明的变量就是一个全局变量 实际上 JavaScript 中有一个默认的全局对象 window ，全局作用域的变量都是绑定在 window 上的。 1234567891011'use strict';var global = \"This is JavaScript\";function test()&#123; console.log(global); console.log(window.global);&#125;test();//输出// This is JavaScript// This is JavaScript 这里直接访问 global 和通过 window.global 访问都是一样的。同时通过变量的方式定义的函数也是一个全局变量，这样在顶层声明的函数也就是被绑定在 window 上的一个全局变量。 12345678'use strict';var global = \"This is JavaScript\";function test()&#123; console.log(global); console.log(window.global);&#125;test();window.test(); 名字空间在 JavaScript 中多个文件之间的全局变量同名是会有冲突的。为了防止这一冲突发生，可以将所有的变量和函数都绑定在一个全局变量中。如下： 1234567891011// 唯一的全局变量MYAPP:var MYAPP = &#123;&#125;;// 其他变量:MYAPP.name = 'myapp';MYAPP.version = 1.0;// 其他函数:MYAPP.foo = function () &#123; return 'foo';&#125;; 局部作用域在 JavaScript 中变量的作用域实际上是在函数内部的，在使用 for 循环等语句块中就无法定义具有局部作用域的变量。 1234567'use strict';function foo() &#123; for (var i=0; i&lt;100; i++) &#123; // &#125; i += 100; // 仍然可以引用变量i&#125; 但是在新的 ES6 的标准中引入了一个新的关键字 let ，用 let 替代 var 可以声明一个块级作用域的变量。 123456789'use strict';function foo() &#123; var sum = 0; for (let i=0; i&lt;100; i++) &#123; sum += i; &#125; // 这里会提示语法错误 i += 1;&#125; 常量JavaScript 中其实是没有常量的，所有通常使用大写变量名来标识这是一个常量，不能修改。但是在新的 ES6 的标准中就引入了 const 关键字用来定义常量，const 和 let 都具有块级作用域。 1234'use strict';const PI = 3.14;PI = 3; // 某些浏览器不报错，但是无效果！ 解构赋值在 ES6 中 JavaScript 引入了解构赋值，可以同时对一组变量进行赋值。我感觉这个和 Swift 中的 元组 有点像。具体怎么使用如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576'use strict';//数组的解构赋值var names = [\"Aaron\",\"Edison\",\"Jack\"];var [name1,name2,name3] = names;console.log(name1);console.log(name2);console.log(name3);console.log(\"\\n\");var [food1,food2,food3] = [\"toufu\",\"beef\",\"Orange\"];console.log(food1);console.log(food2);console.log(food3);console.log(\"\\n\");//解构赋值元素忽略var [,,newName3] = names;console.log(\"newName3 =\" + newName3);console.log(\"\\n\");//嵌套的数组的解构赋值var person = [\"Aaron\",[\"Edison\",\"male\"],[\"Lily\",\"female\"]];var [person1,[person2,gender2],[person3,gender3]] = person;console.log(person1);console.log(person2+\"-----\"+gender2);console.log(person3+\"-----\"+gender3);console.log(\"\\n\");//对象解构赋值var dog = &#123; colour: \"white and black\", breed: \"husky\",&#125;;var &#123;colour,breed&#125; = dog;console.log(\"husky's colour = \" + colour);console.log(\"husky's breed = \" + breed);console.log(\"\\n\");//重命名变量名var person = &#123; name: \"Aaron\", age: 18, gender: \"male\", numberID: 36633, phoneNumber: &#123; iPhone:\"18623832812\", phone:\"028-281371\" &#125;&#125;;var &#123;name:personName,age:personAge,gender:personGender,numberID:personNumberID&#125; = person;console.log(\"person's name = \" + personName);console.log(\"person's age = \" + personAge);console.log(\"person's gender = \" + personGender);console.log(\"person's numberID = \" + personNumberID);console.log(\"\\n\");//对象的嵌套解构赋值var &#123;name,age,gender,phoneNumber:&#123;iPhone,phone&#125;&#125; = person;console.log(\"iPhone = \" + iPhone);console.log(\"phone = \" + phone);console.log(\"\\n\");//已经声明变量的解构赋值var newAaron = &#123; newAaronName: \"Aaron\", newAaronAge: 18, newAaronGender: \"male\"&#125;var newAaronName,newAaronAge,newAaronGender;(&#123;newAaronName,newAaronAge,newAaronGender&#125; = newAaron);console.log(\"newAaronName = \" + newAaronName);console.log(\"newAaronAge = \" + newAaronAge);console.log(\"newAaronGender = \" + newAaronGender); 以上代码输出如下： 方法在 JavaScript 中绑定在对象上的函数被称为方法。 1234567891011121314151617181920'use strict';var person = &#123; getPersonName: function(number) &#123; if (number === 1) &#123; return \"Aaron\"; &#125; else &#123; return \"Edison\"; &#125; &#125;&#125;;var name1 = person.getPersonName(1);console.log(name1);var name2 = person.getPersonName(2);console.log(name2);//输出// Aaron// Edison 有时候在函数内部我们会使用到 this 关键字，这个关键字是有一些坑需要注意的。关于 JavaScript 中 this 的用法可以具体的查看阮一峰的一篇博客 JavaScript中 this 的用法 阮一峰老师的博客中介绍了 apply 的用法，但是有一个和 apply 类似的方法是没有介绍到的。 call ，call 方法和 apply 不同的是 apply 是将参数打包成数组传入该方法的，而 call 则是把参数按照顺序传入的。 装饰器由于 JavaScript 中所有对象都是动态的，即使是内置的函数也是动态的，所以我们可以使用 apply 来动态的修改原来函数方法。 123456789101112131415161718192021var person = &#123; getPersonName: function(number) &#123; if (number === 1) &#123; return \"Aaron\"; &#125; else &#123; return \"Edison\"; &#125; &#125;, getPersonAge: function () &#123; return 18; &#125;&#125;;function getNewAgeForPerson() &#123; return 25;&#125;;person.getPersonAge = getNewAgeForPerson;var newAge = person.getPersonAge();console.log(newAge);//输出// 25 高阶函数JavaScript 中函数是可以作为参数传个其他函数，这样的函数在 JavaScript 中被称为高阶函数。 123456789101112131415'use strict';function mathOperation(method,number1,number2) &#123; return method(number1,number2);&#125;function plus(number1,number2) &#123; return number1 + number2;&#125;var result = mathOperation(plus,10,100);console.log(result);//输出// 110 mapmap` 方法就是属于高阶函数，可以对数组中的每一个元素调用制定的方法： 1234567891011121314'use strict';var numbers = [1,-2,3,4,-5,6,-7,-8,9,-10];function absoluteValue(number) &#123; if (number &lt; 0) &#123; return -number; &#125; else &#123; return number; &#125;&#125;var newNumbers = numbers.map(absoluteValue);console.log(newNumbers); 使用 map 传入一个求绝对值的方法，将会返回这个数组元素所有的绝对值。 reducereduce() 接受一个函数作为参数，这个函数接收两个参数，会把数组中的元素一个一个的累计运算，具体如下。 123456789101112131415161718function accumulation(number1,number2) &#123; return number1 + number2;&#125;;function productNumbers(number1,number2) &#123; return number1 * number2;&#125;;var arr = [10,100,1000];var productNumber = arr.reduce(function productNumbers(number1,number2) &#123; return number1 * number2;&#125;);console.log(productNumber);var sumNumber = arr.reduce(accumulation);console.log(sumNumber);// 输出// 1000000// 1110 filterfilter() 同样也是接受一个函数作为参数，但是这个函数的返回值必须是 Boolean 类型的，然后根据该函数返回的值来确定是否保留该元素。 12345678910111213'use strict';var numbers = [-2,3,-43,123,43,-2321,-343,12321,-343];function filterNegativeNumber(x) &#123; return x &gt; 0;&#125;;var newNumbers = numbers.filter(filterNegativeNumber);console.log(newNumbers);//输出// [3, 123, 43, 12321] sortsort() 排序函数，该函数也是一个高阶函数，可以接受一个函数作为参数。在 JavaScript 中， sort() 默认的排序是将 Array 中所有的元素转换成 String 然后根据 ASCII 排序的。 123456'use strict';var numbers = [-2,3,-43,123,43,-2321];console.log(numbers.sort());// 输出// [-2, -2321, -43, 123, 3, 43] 如果想要实现自己的排序算法，就需要在 sort() 函数中传入自己的排序算法函数 123456789101112131415161718'use strict';var numbers = [-1,26,-12,23,32,43];function sortNumbers(x,y) &#123; if (x&lt;y) &#123; return -1; &#125; if (x&gt;y) &#123; return 1; &#125; return 0;&#125;console.log(numbers.sort(sortNumbers));// 输出// [-12, -1, 23, 26, 32, 43] 闭包JavaScrip 中闭包就是能够读取到其他函数内部变量的函数。在 JavaScript 中只有在函数内部的子函数才能访问到函数内的局部变量，所以可以理解成闭包就是定义在函数内部的函数。 使用闭包有很多需要注意的地方。 12345678910111213141516171819var numbers = [1,2,5,7];function count() &#123; var arr = []; for (var i=1; i&lt;=3; i++) &#123; arr.push(function () &#123; return i * i; &#125;); &#125; return arr;&#125;var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2];console.log(f1());console.log(f2());console.log(f3()); 就如同上面这个例子一样，其实结果都是16。这是因为在这个函数中返回的函数引用了变量 i 但是返回的函数并不是立刻执行的，是在后面才调用执行的，所以变量 i 已经变成了3后才执行。所以最终的结构是 16。上面的问题可以用下面的方式解决。 12345678910111213141516171819function count() &#123; var arr = []; for (var i=1; i&lt;=3; i++) &#123; arr.push((function(n)&#123; return function() &#123; return n * n; &#125; &#125;)(i)); &#125; return arr;&#125;var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2];console.log(f1());console.log(f2());console.log(f3()); 通过在返回的函数中再次传入一个函数，该函数用 n 去绑定循环的变量。这样变量 n 就不回睡着变量 i 的变化而变化了。 箭头函数在 ES6 的标准中新增加了一种函数叫箭头函数。 1x =&gt; x * x; 如上就是一个简单的箭头函数，上面的箭头函数转换成普通的函数如下： 123function (x) &#123; return x * x;&#125; 上面的箭头函数是省略后的箭头函数，在一个表达式的时候 {} 和 return 是可以省略的，但是在包含多个表达式的时候就不能省略了。 123456789var name = (firstName,lastName) =&gt; &#123; if (typeof(firstName) === 'string' &amp;&amp; typeof(lastName) === 'string') &#123; return 'Hello!' + lastName + \" \" + firstName + '欢迎来到 JavaScript 的世界'; &#125; else &#123; return '请输入正确的名字'; &#125;&#125;console.log(name(\"Aaron\",\"Zhang\")); 还有一点需要注意的是如果需要在箭头函数的当表达式中返回对象，就需要用 () 扩起来，不然会有语法冲突 12345//报错x =&gt; &#123;name:'Aaron'&#125;;//正确x =&gt; (&#123;name:'Aaron'&#125;); generator生成器，这个特性是在 ES6 引入的新的数据类型。 12345function* foo(x) &#123; yield x + 1; yield x + 2; return x + 3;&#125; generator 定义的方式是在 fuction 后加上 * 号，generator 和函数很像，不同的是 generator 可以使用 yield 来多次的返回值。 12345678910111213141516171819202122function* squareNumber(number,times) &#123; var i = 1; var temp = number; while (times &gt;= i) &#123; yield temp = temp * number; i++; &#125; return; &#125; var fiveSquare = squareNumber(5,10); console.log(fiveSquare.next()); console.log(fiveSquare.next()); console.log(fiveSquare.next()); console.log(fiveSquare.next()); console.log(fiveSquare.next()); console.log(fiveSquare.next()); console.log(fiveSquare.next()); console.log(fiveSquare.next()); console.log(fiveSquare.next()); console.log(fiveSquare.next()); console.log(fiveSquare.next()); 输出如下： 每次调用 next() 就会返回一个对象，{value: x, done: true/false} 直到 done 为 true 的时候说明这个 generator 执行结束，value 就是 return 返回的对象。","categories":[],"tags":[{"name":"JS学习","slug":"JS学习","permalink":"Aaronzjp.cn/tags/JS学习/"},{"name":"JS基础","slug":"JS基础","permalink":"Aaronzjp.cn/tags/JS基础/"}]},{"title":"JavaScript 基础","slug":"JavaScript-Basic","date":"2018-03-12T06:02:10.000Z","updated":"2018-11-24T09:34:17.658Z","comments":true,"path":"2018/03/12/JavaScript-Basic/","link":"","permalink":"Aaronzjp.cn/2018/03/12/JavaScript-Basic/","excerpt":"Java Script基础&lt;script&gt; 元素 向 HTML 页面中插入 JavaScirpt 的主要方法就是使用 &lt;script&gt; 元素。在使用&lt;script&gt; 元素嵌入 JavaScript 代码时，只须为&lt;script&gt; 指定 type 属性。然后，像下面这样把 JavaScript 代码直接放在元素内部即可： 12345&lt;script type=\"text/javascript\"&gt; function sayHi()&#123; alert(\"Hi!\"); &#125;&lt;/script&gt; 其实不写 type 类型也是可以的，因为现在大部分浏览器默认就是 text/javascript 类型。 通过&lt;script&gt; 元素来包含外部 Javascript 文件，需要用到 src 属性，该属性的值时指向一个外部 JavaScript 文件等链接，如下： 1&lt;script type=\"text/javascript\" src=\"example.js\"&gt;&lt;/script&gt;","text":"Java Script基础&lt;script&gt; 元素 向 HTML 页面中插入 JavaScirpt 的主要方法就是使用 &lt;script&gt; 元素。在使用&lt;script&gt; 元素嵌入 JavaScript 代码时，只须为&lt;script&gt; 指定 type 属性。然后，像下面这样把 JavaScript 代码直接放在元素内部即可： 12345&lt;script type=\"text/javascript\"&gt; function sayHi()&#123; alert(\"Hi!\"); &#125;&lt;/script&gt; 其实不写 type 类型也是可以的，因为现在大部分浏览器默认就是 text/javascript 类型。 通过&lt;script&gt; 元素来包含外部 Javascript 文件，需要用到 src 属性，该属性的值时指向一个外部 JavaScript 文件等链接，如下： 1&lt;script type=\"text/javascript\" src=\"example.js\"&gt;&lt;/script&gt; 数据类型NumberJavaScirpt 中不区分整数和浮点数，都是用Number表示。同时也可以用十六进制和八进制表示。十六进制使用0x作为前缀0-9和a-f表示。八进制则是0作为前缀0-8表示。同时也可以使用科学计数法来表示。以下是合法Number类型的表示： 123456123; // 整数1230.456; // 浮点数0.4561.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5-99; // 负数NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity 要注意的是 NaN 这个特殊的 Number 它和其他的所有的值都是不相等的，包括自己。唯一能判断 NaN 的就是 isNaN() 这个函数。 1isNaN(NaN); //ture 字符串JavaScript中字符串是用&#39; &#39; 或 &quot; &quot;表示，比如 &#39;abc&#39; ， &quot;xyz&quot; 都是字符串的表示。 Boolean布尔值，JavaScript中布尔值只有两种值，true 和 false ，要么是 ture ，要么就是 flalse ，可以直接通过 ture 和 false 表示，也可以通过布尔运算计算出来： 1234true; // 这是一个true值false; // 这是一个false值2 &gt; 1; // 这是一个true值2 &gt;= 3; // 这是一个false值 需要注意的是在 JavaScript 中相等比较运算符有两种： 一种是 == ，该比较运算符会自动将要比较的数据类型转换一致后比较，大多数时候比较结果没啥用 一种是 === ，这种不回自动转换数据类型，如果数据类型不一致就会返回 false 。 这两种比较运算符大多数使用 === 而不会去使用 == ，== 基本上没有什么卵用。 nullnull表示一个“空”的值，和 0 以及字符串 &#39; &#39; 不同，0是一个数值，&#39;&#39;表示长度为0的字符串，而null表示“空”。 undefinedundefined 表示值未定义，其实大多数情况下都是用的是 null 。undefined 仅仅是在判断函数参数是否传递的情况下使用。 ObjectObject 类型即对象，JavaScript 中的对象其实就是一组数据和功能的集合。对象可以通过 new 操作符后跟上要创建的对象类型名称来创建。 如下： 123var person = new Object();person.name = \"Aaron\";person.age = 24; 同时也可以通过字面量的方式来创建一个对象： 1234var person = &#123; name: \"Aaron\", age: 24&#125;; 在 JavaScript 中对象的键都是字符串类型，但是值可以是任意的数据类型，这些键就是对象的属性，可以通过点语法来访问会修改对象的属性。 ArrayJavaScript 中的数组同 OC 中的数组是一样的，是具有顺序排列的集合，集合中的每个值就是数组元素，数组也是通过索引访问，起始索引为0。不同的是 JavaScript 中的数组是可以存放不同元素类型的。 1[1, 2, 3.14, 'Hello', null, true]; 数组的创建也可以通过 Array() 函数来创建： 1new Array(\"Aaron\",\"Jack\",\"Edison\"); 变量JavaScript 中是区分大小写的，所以变量名大小写不一致，有可能在实际开发的时候就会产生错误。在 JavaScript 中变量名甚至可以是中文，但是最好还是不要这样做。JavaScript 中变量名规则不能用数字开头，同时也不能占用 JavaScript 中的关键字来作为变量名。 JavaScript 中使用 var 来声明一个变量，同一个变量只能使用 var 声明一次。同一个变量可以反复中赋值，且可以是不同类型的值。 123var test = 123;test = @\"123\";test = false; 在 JavaScript 中并不强制要求使用 var 声明变量，但是如果不用 var 声明的变量就是全局变量，在同一个页面加载不同的 JavaScript 文件，如果有相同的变量名，则会相互影响造成错误。 为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了strict模式，在strict模式下运行的JavaScript代码，强制通过var申明变量，未使用var申明变量就使用的，将导致运行错误。 启用strict模式的方法是在JavaScript代码的第一行写上： 1&apos;use strict&apos;; 这是一个字符串，不支持strict模式的浏览器会把它当做一个字符串语句执行，支持strict模式的浏览器将开启strict模式运行JavaScript。 字符串JavaScript 中使用 ‘’ 和 “” 来表示字符串，如果字符串中本身就包含了 ‘’ 和 “” 字符，则可以使用转义字符 \\ 来标示。转义字符可以转义很多字符，比如常见的 \\n 换行符 \\t 制表符等。同时也可以转义 ASCII 字符 和 Unicode 字符。 12var OK = 'i\\'m \"OK\"!';//i'm \"OK\"! 多行字符多行字符可以使用 \\n 来表示，同时新的 ES6 标准中新增加了一种多行字符的表示方法，使用反引号 `` 来表示： 1234`这句话是一个多行字符串` 模版字符串模版字符串就是字符串拼接。JavaScript 中使用 + 号来拼接字符串。 1234var name = \"Aaron\";var age = 18;var message = \"你好，我叫\" + name \"，我今年\" + age \"岁了。\" ;console.log(message); 在 ES6 中还新增了一种新的表示方法： 1234var name = \"Aaron\";var age = 18;var message = `你好，我叫$&#123;name&#125;，我今年$&#123;age&#125;岁了。` ;console.log(message); 注意点是这里使用的 `` 反引号。 操作字符串length.() 字符串的长度获取 12var test = \"Hello JavaScript\";test.length; 字符串也可以像数组一样，通过索引来获取单个的字符： 123var test = \"Hello JavaScript\";test[0]; //Htest[8]; //v 在 JavaScript 中字符串是不可变的，通过索引对字符串中的字符赋值不会报错，但是不会产生任何的效果。 toUpperCase() 字符串大写 12var test = \"Hello JavaScript\";test.toUpperCase(); //\"HELLO JAVASCRIPT\" toLowerCase() 字符串小写 12var test = \"Hello JavaScript\";test.toLowerCase(); //\"hello javascript\" indexOf() 获取指定字符串在字符串中的位置 123var test = \"Hello JavaScript\";test.indexOf(\"Java\"); // 6test.indexOf(\"JAVA\"); // -1 搜索不存在的字符串时会返回 -1 substring() 获取指定区间的字符串 123var test = \"Hello JavaScript\";test.substring(0,4); // Hell 从0开始到4 但是不包括4test.substring(3); // o JavaScript 只有一个区间的时候则从改索引位置到结束 数组JavaScript 中的 Array 和 Objective-C 中不同的是，可以包含任意的数据类型。 length.() 获取数组中元素个数 12var array = [1,4,\"4\",true];array.length; // 4 数组可以被重新赋值大小 12345var array = [1,4,\"4\",true];array.length = 7; // [1,4,\"4\",true,undefined,undefined,undefined,undefined]array.length = 2// [1,4] 通过索引修改数组中的元素 1234567var array = [1,4,\"4\",true];array[0] = 100;// [100,4,\"4\",true]//通过索引修改，赋值元素的时候，如果索引超出数组范围也是会修改数组的大小的array[6] = 200;// [100,4,\"4\",true,undefined,undefined,200] indexOf() 获取指定元素在数组中的位置 1234var array = [1,4,\"4\",true];array.indexOf(true); // 3array.indexOf(4); // 1array.indexOf(10) // -1 和字符串一样，如果找不到指定的元素所在位置则返回 -1 slice() 通过索引截取数组，并返回一个新的数组 (和字符串中的 substring 是一样的) 123456789101112var array = [1,4,\"4\",true];array.slice(0,3); // [1，4，\"4\"]; 和字符串是一样的，从0开始到3，但是不包括3array.slice(2);//[\"4\",true]array.slice();//[1,4,\"4\",true];//如果 slice 方法中不传递任何参数则会复制一个新的 array，切不相等，这两个arraycopyArray = array.slice();copyArray === array; // false push() / pop() 从数组末尾添加或删除元素 123456789var array = [1,4,\"4\",true];array.push(\"Aaron\",10,300);// [1,4,\"4\",true,\"Aaron\",10,300]//通过 push 从数组末尾添加元素,返回添加元素后到数组长度array.pop();//[1,4,\"4\",true,\"Aaron\",10]//通过 pop 删除数组中最后一个元素，返回被删除的元素//当数组为空的时候不会报错，而是返回 undefined unshift() / shift() 从数组头部添加或删除元素 123456789var array = [1,4,\"4\",true];array.unshift(\"Aaron\",10,300);// [\"Aaron\",10,300,1,4,\"4\",true]//通过 unshift 从数组头部添加元素,返回添加元素后到数组长度array.shift();//[\"Aaron\",10,300,1,4,\"4\"]//通过 pop 删除数组中最后一个元素，返回被删除的元素//当数组为空的时候不会报错，而是返回 undefined sort() 数组排序 1234567891011121314var array = [1,4,\"4\",true];array.sort();//[1,4,\"4\",true];//该方法会按照默认的顺序排序，由于数组中类型不一样，则无法排序，所以会是原来的样子var array = [1,4,3,2];array.sort();//[1,2,3,4];//按照默认的数字顺序排序var array = [\"C\",\"D\",\"F\",'B'];array.sort();//[\"B\", \"C\", \"D\", \"F\"]//按照字母的默认熟悉排序 如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下： 若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。 若 a 等于 b，则返回 0。 若 a 大于 b，则返回一个大于 0 的值。 123456789101112131415function sortNumber(a,b)&#123;return a - b&#125;var arr = new Array(6)arr[0] = \"10\"arr[1] = \"5\"arr[2] = \"40\"arr[3] = \"25\"arr[4] = \"1000\"arr[5] = \"1\"arr.sort(sortNumber);[\"1\", \"5\", \"10\", \"25\", \"40\", \"1000\"]; reverse() 反向排序数组中的元素 123var array = [1,2,3,4,5];array.reverse();// [5,4,3,2,1] splice() 替换数组中指定位置的元素 1234567891011var array = [1,2,3,4,5];array.splice(0,3,\"Aaron\",\"Edison\");//[\"Aaron\", \"Edison\", 4, 5] 替换从0到3点元素，不包括3array.splice(0,3);//[5] 如果不替换则会删除该区间的元素array.splice(0)// 如果只传开始位置，则会删除开始位置之后的所有元素var array = [1,2,3,4,5];array.splice(4,\"Aaron\",\"Edison\",\"Jack\");//[1, 2, 3, 4, \"Edison\", \"Jack\", 5] 如果只有开始位置，则从开始位置插入元素 concat() 数组拼接 123456var array1 = [1,2,3,4];var array2 = [\"Aaron\",\"Edison\",\"Jack\"];var newArray = array1.concat(array2);console.log(newArray);//[1, 2, 3, 4, \"Aaron\", \"Edison\", \"Jack\"]//该方法并不会修改原有的数组，而是会返回一个新的拼接完成的数组 该拼接方法还会自动拆分数组来拼接出新的数组 使用指定字符串连接数组的元素，并返回连接后的字符串 join() 12345var array2 = [\"Aaron\",\"Edison\",\"Jack\"];console.log(array2.join(\" - \"));//Aaron - Edison - Jack//如果 join() 不带任何参数，则默认使用 , 连接。 多维数组 123var array2 = [\"Aaron\",[1,2,3,4,5],true,false,[\"cat\",\"pig\"]];console.log(array2[4][0]);//cat JavaScript 中的多维数组和 Objectibe-C 中差不多。 对象JavaScript 中的对象是一种无序的集合数据类型，由键值对组成。我倒是觉得很像字典 Dictionary。 123456789101112131415var Aaron = &#123; name: \"Aaron\", age: \"18\", gender: \"male\", 'middle-school': \"unknown\"&#125;;console.log(Aaron.name);console.log(Aaron['name']);console.log(Aaron[\"age\"]);console.log(Aaron[\"middle-school\"]);// Aaron// Aaron// 18// unknown 如上就声明了一个 Aaron 对象，其中 name、age、gender、‘middle-school’ 都是 Aaron 的属性。对象的属性使用点语法 . 来访问。但是如果属性名中如果包含了特殊字符就需要使用 &#39;&#39; 括起来。该属性名不是一个有效的属性名，所以在访问的时候不能使用点语法访问，而是使用 [] 来访问。当然其他正常的属性也是可以通过使用 [] 来访问的。如果访问的属性是不存在的，不会报错，而是会返回 undefined 。 JavaScript 的对象是动态类型的，所有可以随意的添加和删除属性。 12345678910111213var Aaron = &#123; name: \"Aaron\", gender: \"male\", 'middle-school': \"unknown\"&#125;;//添加 age 属性Aaron.age = 18;// 删除 gender 属性delete Aaron.gender;console.log(Aaron);// Object &#123;name: \"Aaron\", middle-school: \"unknown\", age: 18&#125; 判断对象是否拥有某个属性。 123456789101112var Aaron = &#123; name: \"Aaron\", gender: \"male\", 'middle-school': \"unknown\"&#125;; var hasName = \"name\" in Aaron; var hasAge = \"age\" in Aaron; console.log(hasName); console.log(hasAge);// true// false 注意的是使用 in 方法判断属性也不一定是对象本身自己拥有的，也可能是通过继承的来的。 想要判断一个属性是否是自己所有的就要使用 hasOwnProperty() 方法。 123456789101112var Aaron = &#123; name: \"Aaron\", gender: \"male\", 'middle-school': \"unknown\"&#125;;var hasName = Aaron.hasOwnProperty(\"name\");var hasToString = Aaron.hasOwnProperty(\"toString\");console.log(hasToString);console.log(hasName);// false 该方法并不是自己本身的是通过继承的// true Map在最新的 ES6 规范中，JavaScript 引入了一个新的数据类型 Map 。 Map 是一组键值对的结构，有很快的查找速度。 1234var friends = new Map([['Aaron','male'],['Lily','female'],['Edison','male']]);console.log(friends.get(\"Lily\"));// female 初始化 Map 可以像上面一样直接使用二维数组的字面量生成，也可以通过以下方法初始化一个空的 Map 。 12345678910111213141516var friends = new Map();//添加新的 key-valuefriends.set('Aaron','male');friends.set('Lily','female');console.log(friends);//获取对应 key 的 value。如果没有对应的则回返回 undefinedvar gender = friends.get('Aaron');console.log(gender);//判断是否存在对应 key 的数据var hasEdison = friends.has('Edison');console.log(hasEdison);friends.delete('Aaron');console.log(friends); Map 和字典差不多，一个 key 只能有一个对应的 value 所以多次重复对同一个 key 赋值，value 将会是最后赋值的那个值。 Set和 Map 一个样 Set 也是在 ES6 点规范中加入的。和 Map 累死，也是一组 key 的集合，但是不会存储 value。 Set 在 Objective-C 中也叫集合，和 Objective-C 中一样，Set 中的数据是不能重复的。 Set 的创建可以通过 Array 创建或者直接创建一个空的 Set 。 12var newSet = new Set();var setOfArray = new Set([\"Aaron\",\"Edison\",\"Jack\",\"Jay\"]); 在创建 Set 的时候，重复的元素会被自动的去重复。 Set 中添加删除元素 12345678910111213141516171819var testSet = new Set();testSet.add(\"Aaron\");testSet.add(\"Edison\");testSet.add(\"Aaron\");for (valueOfSet of testSet) &#123; console.log(valueOfSet);&#125;console.log(\"----------------\");testSet.delete(\"Aaron\");for (valueOfSet of testSet) &#123; console.log(valueOfSet);&#125;//输出AaronEdison----------------Edison iterable在 JavaScript 中遍历 Array 可以使用下标循环，但是 Map 和 Set 则不能使用下标。为了解决这个问题在新的 ES6 的标准中引入了新的 iterable 类型。具有 iterable 类型的集合都可以通过 for...of 来遍历。 123456789101112131415var array = [1,3,5,7,9];var set = new Set([2,4,6,8,10]);var map = new Map([[1,'A'],[2,'B'],[3,'C'],[4,'D'],[5,'E']]);for (var item of array) &#123; console.log(item);&#125;for (var item of set) &#123; console.log(item);&#125;for (var item of map) &#123; console.log(item);&#125; 输出如下： for...of 和 for...in 的区别 for...in 实际上是遍历的对象的属性名称，Array 其实也是一个对象，所以当给 Array 添加了其他属性后，使用 for...in 也会遍历出我们为 Array 手动添加的属性。 123456789101112var array = [1,3,5,7,9];array.name = \"numbers\";for (var number in array) &#123; console.log(number);&#125;console.log(\"------------\");for (var item of array) &#123; console.log(item);&#125; 输出如下： 另外在 iterable 模式下还内置了一个遍历方法，该方法接收一个函数参数，在每次迭代的时候都会回调该函数。 1234567891011var array = [1,3,5,7,9];array.forEach(function (element,index,array) &#123; console.log('元素：'+element+ ' 索引：' + index + ' 数组：' +array);&#125;);// 元素：1 索引：0 数组：1,3,5,7,9// 元素：3 索引：1 数组：1,3,5,7,9// 元素：5 索引：2 数组：1,3,5,7,9// 元素：7 索引：3 数组：1,3,5,7,9// 元素：9 索引：4 数组：1,3,5,7,9 for...each 中传入的函数参数是可以忽略的，如果有多余的参数，或者不需要的数据，可以选择在传入的这个函数参数中直接忽略。","categories":[],"tags":[{"name":"JS学习","slug":"JS学习","permalink":"Aaronzjp.cn/tags/JS学习/"},{"name":"JS基础","slug":"JS基础","permalink":"Aaronzjp.cn/tags/JS基础/"}]},{"title":"《HTTP权威指南》读书笔记之 - HTTP报文","slug":"HTTP-Protocol","date":"2017-12-05T23:40:35.000Z","updated":"2018-11-24T09:33:05.728Z","comments":true,"path":"2017/12/06/HTTP-Protocol/","link":"","permalink":"Aaronzjp.cn/2017/12/06/HTTP-Protocol/","excerpt":"​ HTTP 协议最初设计目的是用来接收和发布 HTML 网页的，因为其数据传输的可靠性后来被广泛的使用，HTTP 是一种可靠的数据传输协议，该协议位于 TCP/IP 协议族中的应用层。目前 HTTP 已经不只是用来传输简单的网页了。我们在网络上浏览的所有的资源都是存储在 Web 服务器中的，这些资源通过 HTTP 协议被传输到我们的设备中让我们使用。这些使用 HTTP 协议传输数据的服务器就被称为 HTTP 服务器。","text":"​ HTTP 协议最初设计目的是用来接收和发布 HTML 网页的，因为其数据传输的可靠性后来被广泛的使用，HTTP 是一种可靠的数据传输协议，该协议位于 TCP/IP 协议族中的应用层。目前 HTTP 已经不只是用来传输简单的网页了。我们在网络上浏览的所有的资源都是存储在 Web 服务器中的，这些资源通过 HTTP 协议被传输到我们的设备中让我们使用。这些使用 HTTP 协议传输数据的服务器就被称为 HTTP 服务器。 ​ HTTP 客户端向 Web 服务器发出请求后，Web服务器通过处理将我们请求的数据通过 HTTP 传送到客户端。从客户端发出的报文叫 请求报文 ，服务器响应客户端的请求的报文叫 响应报文 。 报文的语法​ HTTP 报文被分为两类分别是 请求报文（request message） 和 响应报文（response message） 。请求报文即客户端向服务器发起的请求，响应报文是服务器为响应客户端请求的报文。HTTP报文有其固定的语法格式。 请求报文格式： 123&lt;method&gt; &lt;request-URL&gt; &lt;version&gt; //起始行&lt;headers&gt; //首部&lt;entity-body&gt; //主体 响应报文格式： 123&lt;version&gt; &lt;status&gt; &lt;reason-phrase&gt; //起始行&lt;headers&gt; //首部&lt;entity-body&gt; 主体 HTTP报文的组成起始行起始行 是使用空格分隔的 ASCII 文本，在请求报文的起始行也叫 请求行 ，在响应报文中的起始行就叫 响应行 请求行的组成如下： 1&lt;method（方法）&gt; &lt;request-URL（请求链接）&gt; &lt;version（客户端HTTP协议版本）&gt; 响应行的组成如下： 1&lt;version（服务器HTTP协议版本）&gt; &lt;status-code（状态码）&gt; &lt;reason-phrase（原因短语）&gt; 方法​ 在请求报文中就会用到方法，请求的起始行就是以方法开始的，方法可以告知服务器需要做些什么。在我们平常的开发中一般常用的方法主要用 GET 和 POST 两种方法。 GET： GET 请求是将数据拼接在 URL 之后发起的明文数据请求，也就是说该请求可以很明显的在 URL 中看到请求时发送给服务器的数据，而且 GET 请求时提交的数据是有长度限制的。所以 GET 请求一般用来单纯的从服务器取回数据，或者提交一些无关紧要的数据给服务器。其实当浏览网站的时候，我们在网址栏输入的网址就是一种 GET 请求，通过该请求从服务器取回网页数据，然后通过浏览器解析渲染然后显示在浏览器窗口。 ​ 关于 GET 请求的特性： GET 请求可被缓存 GET 请求保留在浏览器历史记录中 GET 请求可被收藏为书签 GET 请求不应在处理敏感数据时使用 GET 请求有长度限制 GET 请求只应当用于取回数据 POST： POST 请求是将数据放在请求体中发出的请求，相对于 GET 请求来说更加安全，且 PSOT 请求提交的数据是没有长度限制的。POST 相对于 GET 请求更加适合用来向服务器提交数据。 关于 POST 请求的特性： POST 请求不会被缓存 POST 请求不会保留在浏览器历史记录中 POST 不能被收藏为书签 POST 请求对数据长度没有要求 以下还有一些其他的请求方法： 请求链接​ 这里的请求链接是 URL 中路径部分，是不包含服务器的域名或者 IP 地址的。 HTTP协议版本​ 当前客户端或服务器使用的协议版本，HTTP 协议版本和我们平时的软件版本是不一样的，HTTP 协议版本号是前后两个分别进行对比。如：HTTP/2.22 版本要高于 HTTP/2.3 版本。在客户端和服务器通信的时候告知当前支持的最高 HTTP 协议版本，是为了方便了解对方的能力和报文格式，避免版本不一样时出现新版本使用新的特性时在旧版本上得不到更好的兼容和处理。 状态码与原因短语​ 响应报文中的状态码为接收响应报文的客户端提供了对处理请求响应结果的快捷处理方式，在平常的开发工作中就是通过响应报文中的状态码来判断请求是否成果或者其他各种情况的原因短语则是对当前响应报文的一个状态描述，也可以理解为是状态码的可读性语言描述。其中常用的状态码及原因短语如下： 200 - OK（请求成功） 301 - Moved Permanently （资源被永久转移到其它URL） 404 - Not Found （请求的资源不存在） 500 - Internal Server Error （内部服务器错误） 状态码，并不是没有规律的，目前状态码被分为以下五大类： 分类 分类描述 100～199 信息，服务器收到请求，需要请求者继续执行操作 200～299 成功，操作被成功接收并处理 300～399 重定向，需要进一步的操作以完成请求 400～499 客户端错误，请求包含语法错误或无法完成请求 500～599 服务器错误，服务器在处理请求的过程中发生了错误 更多关于状态码和原因短语细节 首部​ 首部 是由 键：值 的格式构成的，通过行来分隔开，每行结尾都通过一个回车符和一个换行符来表示终止，该符号可以写作 CRLF 。首部主要作为是用来传递一些附属信息，以及有关于内容实体的一些附属信息的。首部的字段有的是通用的有的则是在特定报文中使用的。 ​ 首部目前被分为如下的五个类型： 通用首部 请求首部 响应首部 实体首部 扩展首部 具体的常用首部用以下图来展示，该图并没有完整的列出 HTTP 首部的所有字段。更多关于 HTTP 首部字段 其中在实体首部中 Content-Type 字段是用来区分实体数据媒体类型的，使用的是 MIME。 MIME（Multipurpose Internet Mail Extensions）多用途互联网邮件扩展，最初设计 MIME 的目的是用来在电子邮件中处理不同邮件系统中文件的兼容问题，因为在电子邮件系统中使用的非常稳定，所有在 HTTP 中也使用了该方法来区分 HTTP 中的数据类型。 MIME 类型是一种文本标记，表示了数据的主要类型和子类型。常用的 MIME 类型如下： text/plain（纯文本） text/html（HTML文档） application/xhtml+xml（XHTML文档） image/gif（GIF图像） image/jpeg（JPEG图像）【PHP中为：image/pjpeg】 image/png（PNG图像）【PHP中为：image/x-png】 video/mpeg（MPEG动画） application/json 更多关于MIME 主体主体 和起始行和首部不一样的是主体部分除了可以包含文本外还可以包含二进制数据，主体部分是可选的，在很多时候 HTTP 报文是没有主体部分的 HTTP连接​ 上面已经说了 HTTP 协议是处于 TCP/IP 协议族中的应用层，所以 HTTP 的连接是通过 TCP 来连接的。TCP/IP 是全球计算机及网络设备都在使用的一种常用的分组交换网络分层协议集。TCP 为 HTTP 提供了稳定可靠的数据传输，TCP 传输的数据是有序的，且无差错的。 ​ HTTP 在传送数据发送报文的时候是以流的形式传送的，通过打开一条 TCP 连接按序传送。TCP 在收到数据流的时候会把数据分隔成一段一段的数据块，把数据块进一步封装上目的 IP 地址、源 IP 地址、目的端口号、源端口号、序列号、数据完整校验等信息后将数据块按序发出。 关于 TCP 的知识：TCP/IP ​ HTTP 报文的发送会经过 HTTP、TCP、IP、网络接口，其中现在的 HTTP 则是在 HTTP 和 TCP 层之间加入了安全层，用 TLS 或者 SSL 密码加密层。如下图所示： HTTP性能的考虑TCP连接的握手延时​ 在频繁的 HTTP 请求下很多时候就要考虑到网络请求的性能问题。比如我公司一个项目中需要持续从服务器获取一个人的位置，项目中使用的是 HTTP 连接来做的，每隔3秒就会发送一个请求去获取数据。其实这样是很耗费性能的。 ​ HTTP 底层是 TCP ，所有 HTTP 报文的发送最终都是通过 TCP 来处理的。在每次发送 HTTP 报文的时候就会建立一条新的 TCP 连接。每次从客户端到服务器建立一个 TCP 连接就要经历三次握手，三次握手中就需要传送验证信息。如果连接只用来发送少量的请求，以及频繁的发送请求就会造成 HTTP 性能的降低。 延迟确认​ 在网络中，数据的传送是无法确保完整可靠的传送的。数据在传送的过程中可能会造成数据丢失。所以在 TCP 中实现了自己的一个确认机制来确保数据完成可靠的传输。 ​ 在每个 TCP 段中都有一个用于数据排序的序列号，和用户数据完整性校验。每个段的接受者收到这个数据段的时候就会向发送者回送一个确认信息，告诉发送者已经收到数据，如果发送者没有在指定的窗口时间内收到确认信息就认为数据丢失会损毁，并重新发送这个 TCP 段。在 TCP 中这个确认信息是允许被捎带在相同方向的其他数据分组中一并发送的，这样可以有效的利用网路。TCP 为了增加捎带确认的可能性，TCP 实现了一个延迟确认的算法。 ​ 延迟确认算法是将确认数据放在缓冲区，在特定的时间内如果有同向的数据发送就会把确认数据一并发送出去，如果在这个时间段内没有则会单独的发送出去。TCP 的延迟确认是可以进行修改和关闭的，但是这样会失去数据传输的完整性和可靠性。 TCP慢启动​ 在 TCP 中为了控制网络的传输性能防止网络拥塞，TCP 还有一个特性就是 TCP 慢启动。TCP 在最初会限制连接的最大速度，但是会随着数据传输的成功的数量逐渐提高传输速度。这样做是为了防止一次传输大量的的数据造成网络的过载和拥塞。 Nagle算法与TCP_NODELAY​ 在 TCP 中有一个数据流接口，可以将任意大小的数据放入 TCP 栈中。但是 TCP 段中都至少装载了40个字节的标记和首部，所以如果 TCP 发送大量的数据很小的分组就会影响性能的严重下降。为了防止这一问题的出现就有了 Nagle 算法。RFC 896“IP/TCP 互连网络中的拥塞控制”对此算法进行了描述。 ​ Nagle 算法鼓励发送全尺寸(LAN 上最大尺寸的分组大约是 1500 字节，在因特网上是几百字节)的段。只有当其他分组都被确认后，Nagle 算法才允许发送非全尺寸的分组。如果其他分组在传输中，就会将部分数据缓存起来，当传输的数据被发送后，或者缓存中积累了足够一个全尺寸分组数据时才会将缓存的数据发送出去。 ​ 该算法可能会造成数据延迟发送，因为小的 HTTP 报文可能无法填满一个分组，所以会产生延时，等待传输中的数据发送完毕后才会发送缓存的数据。Nagle 算法加上延迟确认机制就会造成数据的延迟发送。该算法可以通过在 TCP 中设置 TCP_NODELAY 来禁用 Nagle 算法以此提高性能。但最好是确保会向 TCP 写入大块的数据，这样就不会产生每次发送一堆小分组同样也会造成性能的问题。 TIME_WAIT累积与端口耗尽​ 当某个TCP端点关闭TCP连接时，会在内存中维护一个小的控制块，用来记录所关闭的连接的IP地址和端口号。这个信息通常只能存在一个小时间段。这个算法可以防止在短时间内创建、关闭具有相同IP和端口号的连接。 ​ TIME_WAIT的作用：允许老的重复分组在网络中消失，防止最后ACK的丢失，可靠地实现TCP全双工通信的终止。即使没有遇到端口耗尽问题，也要特别小心有大量连接处于打开状态的情况，在有大量打开连接或控制块的情况下，有些操作系统的速度会严重减缓。 持久连接​ 在很多时候我们都 HTTP 请求都是指向的同一个站点，比如在 APP 中几乎所有的 HTTP 请求都是指向的通过服务器的站点。所以在不停的对同一个站点进行请求对时候为了避免不停的创建 TCP 连接 HTTP 是允许在请求结束后依然保持 TCP 连接的打开状态。 HTTP/1.0与keep-alive 连接​ HTTP/1.0 中通过在首部中添加 Connection: Keep-Alive 字段来实现和服务器之间保持 TCP 连接打开状态。客户端在请求报文中的首部添加 Connection: Keep-Alive 字段请求服务器将该连接保持在打开状态，如果服务器愿意保持连接的打开状态就会在响应首部包含同样的 Connection: Keep-Alive 字段，相反响应首部中不包含该字段，服务器则认为服务器不支持 keep-alive 持久连接，会在请求结束后关闭连接。 ​ 同时还可以在 Keep-Alive 首部的字段中设置相应的 keep-alive 选项，如下： 12Connection: Keep-Alive Keep-Alive: max=5, timeout=120 max：最大持久连接数 timeout：打开状态最大闲置时间 keep-alive 持久连接是有弊端的，在客户端和服务器之间如果存在多个代理的时候持久连接就不好用了。 HTTP/1.1 持久连接​ 在 HTTP/1.1 中逐渐停止对 keep-alive 连接的支持，用持久连接（persistent connection）将其取代。持久连接可以说是 keep-alive 连接的优化升级版。 ​ 与 HTTP/1.0+ 的 keep-alive 连接不同，HTTP/1.1 持久连接在默认情况下是激活的。除非特别指明，否则 HTTP/1.1 假定所有连接都是持久的。要在事务处理结束之后将连接关闭，HTTP/1.1 应用程序必须向报文中显式地添加一个 Connection:close 首部。","categories":[],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"Aaronzjp.cn/tags/HTTP/"}]},{"title":"《HTTP权威指南》读书笔记之 - URL与资源","slug":"HTTP-URL-and-Resource","date":"2017-12-02T13:31:46.000Z","updated":"2018-11-24T09:33:14.631Z","comments":true,"path":"2017/12/02/HTTP-URL-and-Resource/","link":"","permalink":"Aaronzjp.cn/2017/12/02/HTTP-URL-and-Resource/","excerpt":"​ 如今我们随时随地都在通过各种设备上网，我们通过网络听歌，查看图片，浏览网页。那我们所访问的这些东西，音乐，图片，网页是从哪来的呢？放在什么地方呢？我们通过什么样的方式使用手中的设备去访问的这些资源呢？ ​ 其实我们所访问的这些资源都是存储在世界各地的 Web 服务器的，我们通过 URL 在网络上定位和访问这些资源。我们最常见的 URL 就是我们在上网时打开浏览器后在地址栏输入的网址，这个就是 URL。URL 是 URI 的子集。","text":"​ 如今我们随时随地都在通过各种设备上网，我们通过网络听歌，查看图片，浏览网页。那我们所访问的这些东西，音乐，图片，网页是从哪来的呢？放在什么地方呢？我们通过什么样的方式使用手中的设备去访问的这些资源呢？ ​ 其实我们所访问的这些资源都是存储在世界各地的 Web 服务器的，我们通过 URL 在网络上定位和访问这些资源。我们最常见的 URL 就是我们在上网时打开浏览器后在地址栏输入的网址，这个就是 URL。URL 是 URI 的子集。 URI​ URI 统一资源标识符（Uniform Resource Identifier），是一用来标识互联网资源的字符串，这种标识用来对网络中的资源通过特定的协议来进行资源定位辨认资源的。URI 下面又分为 URL 、URN 。 URL​ URL 统一资源定位符 （Uniform Resource Locator），是我们平常使用最多的。URL 用来定位网络中资源的位置，当我们访问网页的时候在浏览器中输入的一串字符就是 URL 。URL 分为三个部分。 URL 方案（scheme）。通过方案程序可以知道通过什么的协议方式去访问资源，在访问网页的时候使用的方案一般是 HTTP 和 HTTPS。除了这些还有 FTP、mailto、rtsp、rtspu、file 等方案。 URL 第二部分则是服务器的位置，通过这部分程序可以知道要访问的资源在哪个 Web 服务器上。比如（www.aaronzjp.cn） URL 第三部分则具体标明了资源所在 Web 服务器的路径，通过该路径就可以定位资源的具体位置。 当我们在浏览器中输入网址后浏览器从服务器读取网页数据显示出来的整个过程如下： 通过输入的网址确定访问资源所需要的方案 通过 URL 的第二部分解析出主机名 通过 DNS 服务器将主机名转换成服务器的 通过 URL 解析出服务器端口号，如果没有端口号则是默认的 80 端口 通过服务器的 IP 地址和端口号浏览器与服务器建立 TCP 连接 通过 URL 的第三部分确定要访问的资源所在服务器的位置 向服务器发送一条 HTTP 请求报文 服务器收到浏览器请求的数据后，经过处理服务器发送一条响应报文 浏览器收到响应报文获取到数据后关闭 TCP 连接并将数据展示在浏览器中 URL 并不是一组没有规律的字符串，URL 是有明确语法规则的字符串，大多数的 URL 都遵循如下的语法： 1&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt; scheme：方案 user：用户名 password：密码 host：服务器域名或 IP 地址 port：服务器端口号 path：访问资源的具体路径 params：访问参数 query：查询条件 frag：访问片段，其中访问片段是不会被发送给浏览器的仅在客户端使用，可以通过片段定位资源的某一部分 一般来说 URL 只能使用英文字母，数字和标点符号组成，不能使用其他的文字和符号。其中有一部分被保留的字符如下： 但是在 URL 中难免会有汉字的出现，在有汉字的情况下就必须使用经过编码后的 URL。但是在网络标准中是没有具体规定编码规则的，所有不同的程序（浏览器）有不同的属于自己的一套编码规则。通过在网上搜索后发现阮一峰老师的这篇博客很好的解释了在不同浏览器下分别使用了什么样的编码规则。具体参考：关于URL编码 URN​ URN 统一资源名称（Uniform Resource Name）URN 目前的使用范围有限所以没有去详细的更加深入的去了解。书中对于 URN 的描述如下： URI 的第二种形式就是统一资源名(URN)。URN 是作为特定内容的唯一名称使用的，与目前的资源所在地无关。使用这些与位置无关的 URN，就可以将资源四处搬移。通过 URN，还可以用同一个名字通过多种网络访问协议来访问资源。比如，不论因特网标准文档 RFC 2141 位于何处(甚至可以将其复制到多个地方)，都可以用下列 URN 来命名它: urn:ietf:rfc:2141 URN 仍然处于试验阶段，还未大范围使用。为了更有效地工作，URN 需要一个支撑架构来解析资源的位置。而此类架构的缺乏也延缓了其被采用的进度。但 URN确实为未来发展作出了一些令人兴奋的承诺。 我们平常生活中书后面的 ISBN 是属于 URN 的一种。 参考资料： URI-维基百科 URL-维基百科 URN-维基百科","categories":[],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"Aaronzjp.cn/tags/HTTP/"},{"name":"URL","slug":"URL","permalink":"Aaronzjp.cn/tags/URL/"}]},{"title":"What's new in iOS11","slug":"Whats-new-in-iOS11","date":"2017-10-12T03:06:03.000Z","updated":"2018-11-24T09:37:07.221Z","comments":true,"path":"2017/10/12/Whats-new-in-iOS11/","link":"","permalink":"Aaronzjp.cn/2017/10/12/Whats-new-in-iOS11/","excerpt":"iOS 11正式发布后也一直没有去整理这些东西，现在才整理一点点出来。下面就是在iOS11中新加入的一些东西，可能不是很全面，但是后续会有补充吧。","text":"iOS 11正式发布后也一直没有去整理这些东西，现在才整理一点点出来。下面就是在iOS11中新加入的一些东西，可能不是很全面，但是后续会有补充吧。 what’s new in iOS 11Drag and Drop目前在 iPad 设备中的功能，可以通过拖动UI上的东西到其他App 目前支持的控件有 TableView CollectionView TextView TextField WebView 同时还整合了 UIPasteConfiguration File Manager文件管理系统，可以浏览文件管理系统中云上的文件以及本地文件。其中可以通过相关的API去过滤文件，以便过滤到App不支持的文件类型 UIDocumentBrowserViewController 部分的UI增强改善1. 添加了大的标题栏，Large Titles 通过控制器的一个属性，prefersLargeTitle 来决定大标题是否显示 显示模式largeTitleDisplayMode 决定显示的模式，一般只在树桩导航结构中的根试图中显示 2. SearchBar被整合进了UINavigationBar中，以前只能是作为TableView的 headerView 来处理的，现在可以直接将其赋值给 NavigationItem 切作为 NavigationBar 中的一个整体 3. safeAreaInsets在 iOS 11 中添加了安全区域的概念，其作用大概是为了更好的确保我们要显示的 View 能正确的出现在屏幕中，因为 iPhone X 的屏幕的特殊性，safeArea 这个东西应该更多是为了更好的适配 iPhone X 的屏幕的显示。 safeAreaLayoutGuide 安全区域中 AutoLayout 中的属性，可以通过添加约束的方式来确保 UI 显示在安全区域的范围内 func safeAreaInsetsDidChange() 安全区域发生改变时的回调方法，在我的实验中安全区域在 viewDidLoad 中是为0的 滑动操作iOS11 中在 TableView 中对滑动操作进行了增强。以前 TableView 中滑动操作只是默认的支持删除。现在滑动操作可以更加灵活的自定义其他的功能 123456789class UISwipeActionsConfiguration &#123; init(actions: [UIContextualAction])var performsFirstActionWithFullSwipe: Bool &#125; class UIContextualAction &#123;init(style: Style, title: String?, handler: UIContextualActionHandler) &#125; TableView分割线 可以自定义分割线的距离 Swift 4 和 开发框架的Swift 4 中加入了对原生类型的归档支持，只需要遵守 Codable 协议即可，同时还支持 JSON 以及 Property List Key Paths 键值路径，以前的键值路径都是绝对的，这样就会导致如果写错了路径就会报错，但是在 Swift4 中新增了相对的键值路径 12345let copresenterNameKeyPath = \\Presenter.copresenter.nameeliza[keyPath: copresenterNameKeyPath] // “Josh”eliza[keyPath: .copresenter.name] 同时还新增了基于 block 的 KVO。通过 block 来完成 KVO 代码更加简洁 AutoLayoutAutoLayout新增了对 ScrollView 更好的支持，ScrollView 因为是处于两种坐标的模式 Frame 和内容坐标模式 Content，这样在 AutoLayout中并不是很好处理。现在新增了 contentLayoutGuide frameLayoutGuide 两个属性，已方便在 ScrollView 中的布局 Dynamic TypeUIFontMetrics 动态类型。 Sizing your text 字体自适应，在 iOS 7 中引入的功能，可以通过系统通用中设置的字体大小那改变 App 中的字体，iOS 11之前只能支持默认的字体，但是在 iOS 11中可以使用自定义的字体 12345let bodyMetrics = UIFontMetrics(forTextStyle: .body)let standardFont = ... // any font you want, for standard type sizelet font = bodyMetrics.scaledFont(for: standardFont) AutoLayout在自动布局上控件间的距离也会随着字体大小的变化而自动调整 Password AutoFill密码自动填充 Asset CatalogsAsset 支持添加颜色，并为颜色命名，同时支持广域色彩 图片资源支持 PDF 以及 矢量图。tabBar 在 iOS 11 中可以大图标，如果在 Asset 中使用 PDF 图片资源，并勾选支持矢量图那么 tabBar 则默认支持显示大图标。如果没有则需要自行去设置 Variable Refresh Rate屏幕刷新率大获取，可以针对自己的 App 类型调整合适的","categories":[],"tags":[{"name":"WWDC2017","slug":"WWDC2017","permalink":"Aaronzjp.cn/tags/WWDC2017/"}]},{"title":"ReactiveCocoa框架概览","slug":"ReactiveCocoa-Framework-Overview","date":"2017-09-06T13:25:22.000Z","updated":"2018-11-17T06:42:23.292Z","comments":true,"path":"2017/09/06/ReactiveCocoa-Framework-Overview/","link":"","permalink":"Aaronzjp.cn/2017/09/06/ReactiveCocoa-Framework-Overview/","excerpt":"框架概览 本文档翻译自 ReactiveCocoa ( ReactiveObjC ) 中的 Framework Overview 文档，主要是用来帮助了解 ReactiveCocoa 这个框架的。 该文档主要包含了 ReactiveCocoa 框架中底层不同组件的相关介绍，并介绍了他们是如何一起工作，和划分工作的。这是学习这个新模块和找到更多相关知识文档的起点。 例如帮助我们理解怎么使用 RAC，可以查看这个使用文档 以及设计概览。 Stream (流)流，在框架中使用 RACStream 这个抽象类表示，是一系列的对象值。 这些值是可以立刻获取到的，或者在将来可以获取使用的，但是必须要按顺序检索。在流中不使用或者等待第一个值的情况下是没有办法跳过直接获取检索第二个值的。","text":"框架概览 本文档翻译自 ReactiveCocoa ( ReactiveObjC ) 中的 Framework Overview 文档，主要是用来帮助了解 ReactiveCocoa 这个框架的。 该文档主要包含了 ReactiveCocoa 框架中底层不同组件的相关介绍，并介绍了他们是如何一起工作，和划分工作的。这是学习这个新模块和找到更多相关知识文档的起点。 例如帮助我们理解怎么使用 RAC，可以查看这个使用文档 以及设计概览。 Stream (流)流，在框架中使用 RACStream 这个抽象类表示，是一系列的对象值。 这些值是可以立刻获取到的，或者在将来可以获取使用的，但是必须要按顺序检索。在流中不使用或者等待第一个值的情况下是没有办法跳过直接获取检索第二个值的。 流就是 monads)（不知道怎么翻译），除此之外，这是使得复杂的操作可以建立在一些基本的操作上（特别是类似于 -bind:），RACStream 也实现了来自于 Haskell 的 Monoid 和 MonadZip 的 typeclasses 思想。 RACStream 本身并不是特别的有用。大多数情况下 Stream 都是被当作信号( signals )和序列( sequences )来处理的。 Signals (信号)信号是由 RACSignal 这个类表示的，是一个推驱动式( push-driven )的流。 信号通常来说就是即将发送的数据。当工作被执行或者数据被接收的时候，值通过信号发送出去，这会将值推送给所有的订阅者。用户必须要订阅信号才能访问信号中的数据。 信号可以发送三种不同类型的事件给订阅者： next 事件在流中提供一个新的值。RACStream 类中的方法只对此类事件进行操作，与 Cocoa 中的集合类型不同的是，它对一个包含 nil 的信号是完全有效的。 error 事件标示着在信号完成之前发生了错误。该事件可能会包含一个 NSError 对象，该对象标示出哪里出了错误。错误事件必须特别处理，因为它们不包含在流的值中。 completed 事件标示出信号成功的执行完毕，并且不会添加更多的新的值到流中。完成事件也必须要得到特别处理，同样的它也不被包含在流的值中。 一个信号的生命周期是由任意个数量的 next 事件，紧接着跟随一个 error 或者 completed (但是不会是同时出现的) 事件组成的。 Subscription (订阅者)订阅者是一个通过信号等待事件的任何对象。在 RAC 中，订阅者可以是遵守了 RACSubscriber 协议的任何对象。 订阅者可以通过 -subscribeNext:error:completed: 方法创建，或者响应的便利方法。大多数 RACStream 和 RACSignal 操作对象都创建了订阅，但是这些订阅中间大多是实现的细节。 订阅者持有其订阅的信号，并在信号完成或者发生错误时自动进行处理。当然订阅者也可以手动进行处理。 Subjects (热信号)热信号( Subjects ) 由 RACSubject 这个类表示，这是一个可以手动控制的信号。 热信号可以被认为是 Signal( 信号 ) 的一个可变的变体，就像是 NSMutableArray 和 NSArray 的关系一样。它们用来将非 RAC 的代码桥接到 ReactiveCocoa 中是非常有用的。 例如，可以替代在应用中处理逻辑回调的 block ，block 可以很简单的发送事件到 subject 作为替代。然后 subject 可以作为一个 RACSignal 返回，隐藏在回调中的实现细节。 一些 subject 也可以提供额外的处理方式。特别是 RACReplaySubject 可以用来为将来的订阅者缓冲事件，比如在网络请求完成之前，一些事情需要准备好处理结束。 Commands (命令)Commands(命令) 表现于 RACCommand 这个类，用于创建和订阅信号中的响应和动作。这让用户与 App 交互的时候可以很容易的执行一些其他的操作和效果。 通常一个动作的触发命令是由 UI 驱动的，就像按钮被点击的时候一样。Commands(命令) 还可以基于信号自动的禁用一些操作，而这个禁用状态可以通过禁用与该命令相关联的任何控件来表示在UI中。 在OS X上，RAC 将 rac_command 属性添加到 NSButton 中，用于自动设置这些行为。 Connections (连接)Connections(连接) 表现于 RACMulticastConnection 类，用于在多个订阅者之间共享订阅。 Signals 在默认情况下是冷信号，也就是说只有在每次添加订阅的时候才会发送事件。这种行为是可取的，因为这意味着数据是刚刚重新计算的对于每个订阅者来说，但是如果是在信号有副作用以及昂贵的操作的时候就会有问题( 比如发送网络请求 )。 可以通过 RACSignal 中的 -publish: 或者 -multicast: 方法创建一个 Connections(连接)，并且保证只创建了一个订阅者，无论被订阅了多少次。一次连接后，被连接的信号被告知为热信号，而且底层订阅保持活跃直到所有的订阅者被处理清除。 Sequences (序列)Sequences(序列)，表现于 RACSequence 类，是一个拉驱动式( pull-driven )的流。 Sequences(序列) 是一种集合类型，类似于 NSArray 。与 NSArray 不同的是 Sequences 中的值默认是懒加载的( 即在被需要的时候才加载 )，如果只是使用 Sequences 的一部分，可能会对性能有潜在的提升。就像 Cocoa 中的集合类型一样，Sequences 是不能包含 nil 的。 Sequences 类似于 Clojure 的序列(特别是lazy-seq)，或者 Haskell 中的 List 类型。 RAC 将 -rac_sequence: 方法添加到大多数 Cocoa 的集合类中，允许它们作为Sequences 使用。 DisposablesDisposables 类用于取消和清理资源。 Disposables 通常用来取消信号的订阅。当订阅被清除取消，与其相关的订阅者就不会在信号中收到以后的事件。此外，任何与订阅相关的工作(后台处理、网络请求等)都将会被取消，因为不再需要结果。 更多关于取消的信息，可以查看 RAC 的设计概览。 Schedulers (调度器)Schedulers (调度器) 表现于 RACScheduler 类，Schedulers (调度器) 是一个串行执行队列，用于执行工作或交付结果的信号。 Schedulers (调度器) 类似于 GCD 队列，但是 Schedulers (调度器) 支持取消操作( 例如：disposables )，并且总是连续执行。除了 +immediateScheduler: 方法外，Schedulers (调度器) 不提供同步执行。这有助于避免死锁，而且鼓励使用信号操作来替代 block 。 同时 Schedulers (调度器) 也类似于 NSOperationQueue，但是 Schedulers (调度器) 不允许任务被重新排列或者相互依赖。 数据类型RAC 提供了一些其他类，方便地表示流中的值: RACTuple 是一个轻量级的常量集合，可以包含 nil ( 由 RACTupleNil 表示 )。它通常用于表示多个流的组合值。 RACUnit 是一个单例空值，当没有有意义的值存在流中时，它被当作流中的值。 RACEvent 将任何信号事件表示为单个值。它主要通过 -materialize: 方法应用于 RACSignal。","categories":[],"tags":[{"name":"Reactive Cocoa","slug":"Reactive-Cocoa","permalink":"Aaronzjp.cn/tags/Reactive-Cocoa/"},{"name":"响应式编程","slug":"响应式编程","permalink":"Aaronzjp.cn/tags/响应式编程/"}]},{"title":"ReactiveCocoa 和 MVVM 的简单使用","slug":"ReactiveCocoa-and-MVVM","date":"2017-08-28T05:14:55.000Z","updated":"2018-11-24T09:35:38.961Z","comments":true,"path":"2017/08/28/ReactiveCocoa-and-MVVM/","link":"","permalink":"Aaronzjp.cn/2017/08/28/ReactiveCocoa-and-MVVM/","excerpt":"MVVM在 iOS 中最开始的时候以及我们一开始学习的时候就是使用的 MVC 的模式来进行iOS App 开发的。MVC 的模式总的来说就是分为三个部分 Model(数据模型)、View(界面，视图)、Controller(控制器)。 在 MVC 中他们的通信方式如下图所示，该图来自斯坦福公开课中的 PDF 文件。","text":"MVVM在 iOS 中最开始的时候以及我们一开始学习的时候就是使用的 MVC 的模式来进行iOS App 开发的。MVC 的模式总的来说就是分为三个部分 Model(数据模型)、View(界面，视图)、Controller(控制器)。 在 MVC 中他们的通信方式如下图所示，该图来自斯坦福公开课中的 PDF 文件。 如图所示，在 iOS 开发中 MVC 的模式之间的通信方式如图所示，在该模式中 Model 和 View 之间是无法相互通信的，都是通过 Controller 来完成 Model 和 VIew 之前的通信。如此一来 Controller 中的东西就会十分多，Controller 类就会十分的复杂和大量的代码。所以后来就出现了 MVVM 的模式。 MVVM 它分别是由 Model View View-Model 三个部分组成的。 Model：Model 在 MVVM 模式中没有太大的变化，主要还是数据的模型。可能也会在其中封装一部分的关于数据处理和业务逻辑的一些代码。 View：很明显就是说视图，在 iOS 中视图不单单是视图类的代码，其中也包括了 storyboard、xib等视图，同时也包括 Controller 在内。 View-Model：View-Model 在这里看起来应该是前面两种的组合，其实并不是。这里的 View-Model 其实是负责视图显示需要数据的处理的一个类，可以包括数据的请求，数据的处理等。View-Model 中的数据主要提供给 View 用来展示和显示。 MVVM 其结构图如下所示： 图片来自维基百科，在 iOS 中图上的 View 也应该包括 Controller。其中 View-Model 是介于 View(Controller) 和 Model 之间的。在 MVVM 模式中数据的获取和数据的获取以及数据的处理都是在 View-Model 中来完成的，其中 View-Model 再通过 Model 将数据转化成一个一个的 Model 用来供视图展示和显示出来。其实 MVVM 模型就是一个 MVC 经过优化后的模式。它将原来需要在 View(Controller) 中需要处理的数据单独提取到 View-Model 中来处理，这样 View(Controller) 只要负责显示即可，让 View(Controller) 更加的轻量化。 MVVM与ReactiveCocoaView-ModelView-Model 是和 Controller 在一起的，但是 View-Model 和 Controller 是相互独立的两个东西，View-Model 基本上是负责处理数据的获取和过滤的。Controller 通过 View-Model 获取数据来使用。 在例子中，有这样一个 UITableView 用来展示一些车辆审验的信息，这里结合了 ReactiveCocoa 来做控制数据请求后的数据流动。请求获取数据后，通过在 Controller 对信号订阅从信号管道中获取到数据。我看到有的人是在请求到的数据通过只读属性暴露在外的，但是我觉得既然这里使用了 ReactiveCocoa 来做处理，所以我还是把数据通过信号管道的方式来使用请求到的数据好一点。另外 View-Model 这个类在设计的时候因为对数据种类这点没考虑到所以这个类设计得不是很好，这里也就先不细化的说了。主要记录一下 MVVM + ReactiveCocoa 的简单的使用的一个范例。 CarCheckViewModel.h 1234567891011121314151617181920#import &lt;Foundation/Foundation.h&gt;#import &lt;ReactiveObjC.h&gt;#import &quot;CarCheckModel.h&quot;//数据种类typedef NS_ENUM(NSUInteger, CarCheckDataType) &#123; Plan = 0, History&#125;;@interface CarCheckViewModel : NSObject@property (nonatomic,strong,readonly) RACCommand *getCarCheckListCommand;//加载数据- (void)loadDataWithType:(CarCheckDataType)type;//加载更多数据- (void)loadMoreDataWithType:(CarCheckDataType)type;//刷新数据- (void)refreshDataWithType:(CarCheckDataType)type;@end CarCheckViewModel.m 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#import &quot;CarCheckViewModel.h&quot;#import &quot;CarCheckAPIManager.h&quot;#import &quot;AccountManager.h&quot;#import &quot;CarCheckModel.h&quot;@interface CarCheckViewModel()@property (nonatomic,strong,readwrite) RACCommand *getCarCheckListCommand;//Model数组@property (nonatomic,strong,readwrite) NSArray&lt;CarCheckModel *&gt; *carCheckList;@end@implementation CarCheckViewModel- (instancetype)init &#123; if (self = [super init]) &#123; if (!_getCarCheckListCommand) &#123; _getCarCheckListCommand = [[RACCommand alloc]initWithSignalBlock:^RACSignal * _Nonnull(id _Nullable input) &#123; return [self getCarCheckListSignalWithParameter:input]; &#125;]; &#125; &#125; return self;&#125;- (void)loadDataWithType:(CarCheckDataType)type &#123; NSDictionary *parameter = @&#123;@&quot;number&quot;:[[AccountManager sharedInstance]getStoredNumber],@&quot;first&quot;:@(0),@&quot;type&quot;:@(type)&#125;; [self.getCarCheckListCommand execute:parameter];&#125;- (void)loadMoreDataWithType:(CarCheckDataType)type &#123; NSDictionary *parameter = @&#123;@&quot;number&quot;:[[AccountManager sharedInstance]getStoredNumber],@&quot;first&quot;:@(_carCheckList.count),@&quot;type&quot;:@(type)&#125;; [self.getCarCheckListCommand execute:parameter];&#125;- (void)refreshDataWithType:(CarCheckDataType)type &#123; [self loadDataWithType:type];&#125;- (RACSignal *)getCarCheckListSignalWithParameter:(NSDictionary *) parameter &#123; RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [[[CarCheckAPIManager alloc]init]loadDataWithParams:parameter success:^(id data) &#123; [subscriber sendNext:data]; [subscriber sendCompleted]; &#125; failure:^(id data) &#123; [subscriber sendError:data]; [subscriber sendCompleted]; &#125;]; return nil; &#125;]; return [signal map:^id _Nullable(id _Nullable value) &#123; NSMutableArray *dicArray = value[@&quot;resultInfos&quot;]; _carCheckList = [[dicArray.rac_sequence map:^id _Nullable(id _Nullable value) &#123; return [[CarCheckModel alloc]initWithDictionary:value]; &#125;] array]; return _carCheckList; &#125;];&#125;@end Model他的 Model 类如下，该模型类是使用 JSONExport 自动生成的： CarCheckModel.h 1234567891011121314#import &lt;UIKit/UIKit.h&gt;@interface CarCheckModel : NSObject@property (nonatomic, strong) NSString * inspectionTime;@property (nonatomic, strong) NSString * plateNumber;@property (nonatomic, strong) NSString * remark;@property (nonatomic, assign) NSInteger type;@property (nonatomic, strong) NSString * waiteTime;-(instancetype)initWithDictionary:(NSDictionary *)dictionary;-(NSDictionary *)toDictionary;@end CarCheckModel.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#import &quot;CarCheckModel.h&quot;NSString *const kCarCheckModelInspectionTime = @&quot;inspectionTime&quot;;NSString *const kCarCheckModelPlateNumber = @&quot;plateNumber&quot;;NSString *const kCarCheckModelRemark = @&quot;remark&quot;;NSString *const kCarCheckModelType = @&quot;type&quot;;NSString *const kCarCheckModelWaiteTime = @&quot;waiteTime&quot;;@interface CarCheckModel ()@end@implementation CarCheckModel/** * Instantiate the instance using the passed dictionary values to set the properties values */-(instancetype)initWithDictionary:(NSDictionary *)dictionary&#123; self = [super init]; if(![dictionary[kCarCheckModelInspectionTime] isKindOfClass:[NSNull class]])&#123; self.inspectionTime = dictionary[kCarCheckModelInspectionTime]; &#125; if(![dictionary[kCarCheckModelPlateNumber] isKindOfClass:[NSNull class]])&#123; self.plateNumber = dictionary[kCarCheckModelPlateNumber]; &#125; if(![dictionary[kCarCheckModelRemark] isKindOfClass:[NSNull class]])&#123; self.remark = dictionary[kCarCheckModelRemark]; &#125; if(![dictionary[kCarCheckModelType] isKindOfClass:[NSNull class]])&#123; self.type = [dictionary[kCarCheckModelType] integerValue]; &#125; if(![dictionary[kCarCheckModelWaiteTime] isKindOfClass:[NSNull class]])&#123; self.waiteTime = dictionary[kCarCheckModelWaiteTime]; &#125; return self;&#125;/** * Returns all the available property values in the form of NSDictionary object where the key is the approperiate json key and the value is the value of the corresponding property */-(NSDictionary *)toDictionary&#123; NSMutableDictionary * dictionary = [NSMutableDictionary dictionary]; if(self.inspectionTime != nil)&#123; dictionary[kCarCheckModelInspectionTime] = self.inspectionTime; &#125; if(self.plateNumber != nil)&#123; dictionary[kCarCheckModelPlateNumber] = self.plateNumber; &#125; if(self.remark != nil)&#123; dictionary[kCarCheckModelRemark] = self.remark; &#125; dictionary[kCarCheckModelType] = @(self.type); if(self.waiteTime != nil)&#123; dictionary[kCarCheckModelWaiteTime] = self.waiteTime; &#125; return dictionary;&#125;/** * Implementation of NSCoding encoding method *//** * Returns all the available property values in the form of NSDictionary object where the key is the approperiate json key and the value is the value of the corresponding property */- (void)encodeWithCoder:(NSCoder *)aCoder&#123; if(self.inspectionTime != nil)&#123; [aCoder encodeObject:self.inspectionTime forKey:kCarCheckModelInspectionTime]; &#125; if(self.plateNumber != nil)&#123; [aCoder encodeObject:self.plateNumber forKey:kCarCheckModelPlateNumber]; &#125; if(self.remark != nil)&#123; [aCoder encodeObject:self.remark forKey:kCarCheckModelRemark]; &#125; [aCoder encodeObject:@(self.type) forKey:kCarCheckModelType]; if(self.waiteTime != nil)&#123; [aCoder encodeObject:self.waiteTime forKey:kCarCheckModelWaiteTime]; &#125;&#125;/** * Implementation of NSCoding initWithCoder: method */- (instancetype)initWithCoder:(NSCoder *)aDecoder&#123; self = [super init]; self.inspectionTime = [aDecoder decodeObjectForKey:kCarCheckModelInspectionTime]; self.plateNumber = [aDecoder decodeObjectForKey:kCarCheckModelPlateNumber]; self.remark = [aDecoder decodeObjectForKey:kCarCheckModelRemark]; self.type = [[aDecoder decodeObjectForKey:kCarCheckModelType] integerValue]; self.waiteTime = [aDecoder decodeObjectForKey:kCarCheckModelWaiteTime]; return self;&#125;/** * Implementation of NSCopying copyWithZone: method */- (instancetype)copyWithZone:(NSZone *)zone&#123; CarCheckModel *copy = [CarCheckModel new]; copy.inspectionTime = [self.inspectionTime copy]; copy.plateNumber = [self.plateNumber copy]; copy.remark = [self.remark copy]; copy.type = self.type; copy.waiteTime = [self.waiteTime copy]; return copy;&#125;@end 该类主要是数据模型的作用，用来存储和使用数据，以及对数据进行一些业务逻辑的处理的作用。 View(Controller)通过这样的方式后在 View 中主要做的事就很简单了，只需要把数据和 View 绑定起来并展示出来就可以。在这个类中涉及了项目中很多其他的类，所以不要在意其他的，重要的是看清思路，MVVM 大概就是这么个结构来做处理的。当然在这个页面中只是用来展示东西，没有了其他更多的操作。具体应用到项目中的时候，可能还要结合 ReactiveCocoa 来做一些其他的功能，比如登陆界面，也可以使用 MVVM + ReactiveCocoa 来做，使用 ReactiveCocoa 来监控用户的交互判断用户名和密码来决定是否可以登陆和是否登陆成功等。 CarCheckViewController.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#import &quot;CarCheckViewController.h&quot;#import &quot;CarCheckTableViewCell.h&quot;#import &quot;CarCheckViewModel.h&quot;#import &quot;AccountManager.h&quot;#import &quot;HLYHUD.h&quot;#import &quot;TaskVCHeaderView.h&quot;#import &quot;MJRefresh.h&quot;@interface CarCheckViewController () &lt;UITableViewDataSource,UITableViewDelegate&gt;@property (nonatomic,strong) UITableView *planTableView;@property (nonatomic,strong) UITableView *historyTableView;@property (nonatomic,strong) CarCheckViewModel *planViewModel;@property (nonatomic,strong) CarCheckViewModel *historyViewModel;@property (nonatomic,strong) NSArray&lt;CarCheckModel *&gt; *planDataSource;@property (nonatomic,strong) NSArray&lt;CarCheckModel *&gt; *historyDataSource;@property (nonatomic,strong) TaskVCHeaderView *segmentView;@property (nonatomic,strong) UIScrollView *scrollView;@property (nonatomic,assign) NSInteger currentPageIndex;@end@implementation CarCheckViewController- (CarCheckViewModel *)planViewModel &#123; if (!_planViewModel) &#123; _planViewModel = [[CarCheckViewModel alloc]init]; [_planViewModel.getCarCheckListCommand.executionSignals.switchToLatest subscribeNext:^(id _Nullable x) &#123; _planDataSource = x; [_planTableView.mj_header endRefreshing]; [_planTableView.mj_footer endRefreshing]; [_planTableView reloadData]; &#125;]; [_planViewModel.getCarCheckListCommand.errors subscribeNext:^(id _Nullable x) &#123; [HLYHUD hideHUDForView:_planTableView]; [_planTableView.mj_header endRefreshing]; [_planTableView.mj_footer endRefreshing]; [HLYHUD showHUDWithMessage:x[@&quot;message&quot;] addToView:_planTableView]; &#125;]; [_planViewModel.getCarCheckListCommand.executing subscribeNext:^(NSNumber * _Nullable x) &#123; if ([x boolValue]) &#123; [HLYHUD showLoadingHudAddToView:self.view]; &#125; else &#123; [HLYHUD hideHUDForView:self.view]; &#125; &#125;]; &#125; return _planViewModel;&#125;- (CarCheckViewModel *)historyViewModel &#123; if (!_historyViewModel) &#123; _historyViewModel = [[CarCheckViewModel alloc]init]; [_historyViewModel.getCarCheckListCommand.executionSignals.switchToLatest subscribeNext:^(id _Nullable x) &#123; _historyDataSource = x; [_historyTableView.mj_header endRefreshing]; [_historyTableView.mj_footer endRefreshing]; [_historyTableView reloadData]; &#125;]; [_historyViewModel.getCarCheckListCommand.errors subscribeNext:^(id _Nullable x) &#123; [HLYHUD hideHUDForView:_historyTableView]; [_historyTableView.mj_header endRefreshing]; [_historyTableView.mj_footer endRefreshing]; [HLYHUD showHUDWithMessage:x[@&quot;message&quot;] addToView:_historyTableView]; &#125;]; [_historyViewModel.getCarCheckListCommand.executing subscribeNext:^(NSNumber * _Nullable x) &#123; if ([x boolValue]) &#123; [HLYHUD showLoadingHudAddToView:self.view]; &#125; else &#123; [HLYHUD hideHUDForView:self.view]; &#125; &#125;]; &#125; return _historyViewModel;&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor]; self.title = @&quot;车辆审验&quot;; _currentPageIndex = 100; _segmentView = [[TaskVCHeaderView alloc]initWithFrame:CGRectMake(0, 0, kScreenWidth, 44)]; _segmentView.titleArray = @[@&quot;计划执行&quot;,@&quot;历史记录&quot;]; __weak CarCheckViewController *weakSelf =self; _segmentView.changeVCBlock = ^(NSInteger index) &#123; if (index == _currentPageIndex) &#123; return; &#125; else &#123; _currentPageIndex = index; if (index == 100) &#123; [weakSelf.scrollView setContentOffset:CGPointMake(0, 0) animated:YES]; [weakSelf.planViewModel loadDataWithType:Plan]; &#125; else &#123; [weakSelf.scrollView setContentOffset:CGPointMake(CGRectGetWidth(weakSelf.view.bounds), 0) animated:YES]; [weakSelf.historyViewModel loadDataWithType:History]; &#125; &#125; &#125;; [self.view addSubview:_segmentView]; _scrollView = [[UIScrollView alloc]initWithFrame:CGRectMake(0, 44, CGRectGetWidth(self.view.bounds) * 2, CGRectGetHeight(self.view.bounds) - 44)]; [self.view addSubview:_scrollView]; _planTableView = [[UITableView alloc]initWithFrame:CGRectMake(0, 0, self.view.bounds.size.width, self.view.bounds.size.height - 44) style:UITableViewStylePlain]; _planTableView.dataSource = self; _planTableView.delegate = self; _planTableView.rowHeight = UITableViewAutomaticDimension; _planTableView.estimatedRowHeight = 100; _planTableView.tableFooterView = [UIView new]; _planTableView.mj_header = [MJRefreshNormalHeader headerWithRefreshingBlock:^&#123; [_planViewModel refreshDataWithType:Plan]; &#125;]; _planTableView.mj_footer = [MJRefreshBackNormalFooter footerWithRefreshingBlock:^&#123; [_planViewModel loadMoreDataWithType:Plan]; &#125;]; [_scrollView addSubview:_planTableView]; _historyTableView = [[UITableView alloc]initWithFrame:CGRectMake(CGRectGetWidth(self.view.bounds), 0, self.view.bounds.size.width, self.view.bounds.size.height - 44) style:UITableViewStylePlain]; _historyTableView.dataSource = self; _historyTableView.delegate = self; _historyTableView.rowHeight = UITableViewAutomaticDimension; _historyTableView.estimatedRowHeight = 100; _historyTableView.tableFooterView = [UIView new]; _historyTableView.mj_header = [MJRefreshNormalHeader headerWithRefreshingBlock:^&#123; [_historyViewModel refreshDataWithType:History]; &#125;]; _historyTableView.mj_footer = [MJRefreshBackNormalFooter footerWithRefreshingBlock:^&#123; [_historyViewModel loadMoreDataWithType:History]; &#125;]; [_scrollView addSubview:_historyTableView]; [self.planViewModel loadDataWithType:Plan];&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; &#125;- (NSInteger) tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123; if (tableView == _historyTableView) &#123; return _historyDataSource.count; &#125; else &#123; return _planDataSource.count; &#125;&#125;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; static NSString *identifier = @&quot;CheckCarCell&quot;; CarCheckTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:identifier]; if (!cell) &#123; cell = [[CarCheckTableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:identifier]; &#125; CarCheckModel *carCheck; if (tableView == _historyTableView) &#123; carCheck = _historyDataSource[indexPath.row]; &#125; else &#123; carCheck = _planDataSource[indexPath.row]; &#125; [cell fillDataWithModel:carCheck]; return cell;&#125;@end","categories":[],"tags":[{"name":"Reactive Cocoa","slug":"Reactive-Cocoa","permalink":"Aaronzjp.cn/tags/Reactive-Cocoa/"},{"name":"MVVM","slug":"MVVM","permalink":"Aaronzjp.cn/tags/MVVM/"}]},{"title":"ReactiveCocoa的基本使用","slug":"Use-ReactiveCocoa","date":"2017-08-03T01:59:47.000Z","updated":"2018-04-27T09:26:24.317Z","comments":true,"path":"2017/08/03/Use-ReactiveCocoa/","link":"","permalink":"Aaronzjp.cn/2017/08/03/Use-ReactiveCocoa/","excerpt":"什么是ReactiveCocoa？最近因为公司的一个项目因为是用 ReactiveCocoa 结合 MVVM 来写的，所以在我接手的时候我也打算继续使用这种模式，因为我觉得这种模式还是有一定的好处的，通过 ReactiveCocoa 的使用强化了项目中围绕数据变化所做的改变。所以最近还是学习一下 ReactiveCocoa 的一些基本的使用。 ReactiveCocoa（其简称为RAC）是由Github工程师们开发的一个应用于iOS和OS X开发的函数响应式编程新框架。ReactiveCocoa 的灵感来源于 函数式响应式编程。ReactiveCocoa 的优点是可以很轻松的处理状态以及状态之间依赖过多的问题，同时也是一种很好的消息传递的机制。通过对 RACSignal (信号) 的使用，可以很好的处理事件流，以及事件的监控，状态改变的处理。","text":"什么是ReactiveCocoa？最近因为公司的一个项目因为是用 ReactiveCocoa 结合 MVVM 来写的，所以在我接手的时候我也打算继续使用这种模式，因为我觉得这种模式还是有一定的好处的，通过 ReactiveCocoa 的使用强化了项目中围绕数据变化所做的改变。所以最近还是学习一下 ReactiveCocoa 的一些基本的使用。 ReactiveCocoa（其简称为RAC）是由Github工程师们开发的一个应用于iOS和OS X开发的函数响应式编程新框架。ReactiveCocoa 的灵感来源于 函数式响应式编程。ReactiveCocoa 的优点是可以很轻松的处理状态以及状态之间依赖过多的问题，同时也是一种很好的消息传递的机制。通过对 RACSignal (信号) 的使用，可以很好的处理事件流，以及事件的监控，状态改变的处理。 ReactiveCocoa与传统iOS开发的比较在传统的代码中如果我们要去检测 TextFiled 中输入的变换可能需要像下面这样使用： 12345[self.usernameTextField addTarget:self action:@selector(usernameTextFieldChanged) forControlEvents:UIControlEventEditingChanged:];- (void)passwordTextFieldChanged:(UITextField *)sender &#123; NSLog(@“%@”,sender.text);&#125; 但是在 ReactiveCocoa 中我们就可以很巧妙的用极少的代码在 Block 中去处理 TextFiled 的输入状态的变化，代码如下： 123[self.usernameTextField.rac_textSignal subscribeNext:^(NSString * _Nullable x) &#123; NSLog(@&quot;%@&quot;,x);&#125;]; 是不是很简便，但是这只是简单的处理，所以看不出来特别大的优势，如果是稍微复杂一点的，ReactiveCocoa 的优势就可以很明显的展示出来了。 ReactiveCocoa的简单使用信号创建大部分情况下 ReactiveCocoa 框架中 UIKit 控件都已经添加了信号，供我们订阅信号进行处理。但是在有些时候我们也需要自己去创建信号。创建信号方式如下： 123456789101112// 1.创建信号RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;// 3.发送信号[subscriber sendNext:@&quot;ws&quot;];// 4.取消信号，如果信号想要被取消，就必须返回一个RACDisposable// 信号什么时候被取消：1.自动取消，当一个信号的订阅者被销毁的时候机会自动取消订阅，2.手动取消，//block什么时候调用：一旦一个信号被取消订阅就会调用//block作用：当信号被取消时用于清空一些资源return [RACDisposable disposableWithBlock:^&#123;NSLog(@&quot;取消订阅&quot;);&#125;];&#125;]; 信号订阅信号订阅，通过信号订阅我们可以做到实时观察需要的数据以及状态。比如要观察处理 UITextField 的输入： 123[self.usernameTextField.rac_textSignal subscribeNext:^(NSString * _Nullable x) &#123; NSLog(@&quot;%@&quot;,x);&#125;]; 上面的代码当 usernameTextField 在输入时，输入的文字改变就会触发 block 中代码的执行。 ReactiveCocoa 的信号会向信号的订阅者发送已订阅的事件流。其中发送的事件分为三种类型：next、error 和 completed。RACSignal 提供了多种方法用来订阅不同的事件类型。可以接受一个或多个 block 作为参数，当事件流传递到当前事件的时候，就会执行 block 中的代码。ReactiveCocoa 框架使用 Category 为大部分的标准的 UIKit 控件都添加了信号，通过这些已经添加的信号我们进行订阅，可以完成大部分常见的操作。同时我们也可以针对自己的控件自己定义信号。 信号可以被订阅，也可以被主动的取消订阅，取消订阅的方式如下： 1234567// 只要订阅信号就会返回一个取消订阅信号的类RACDisposable *disposable = [signal subscribeNext:^(id x) &#123;// block的调用时刻：只要信号内部发出数据就会调用这个blockNSLog(@&quot;======%@&quot;, x);&#125;];// 取消订阅[disposable dispose]; 信号过滤ReactiveCocoa还具有对事件流进行过滤的操作。比如下面这样，我们只需要在控制台打印字符串长度超过3的情况。 123456[[self.usernameTextField.rac_textSignal filter:^BOOL(NSString * _Nullable value) &#123; NSString *text = value; return text.length &gt; 3;&#125;] subscribeNext:^(NSString * _Nullable x) &#123; NSLog(@&quot;%@&quot;,x);&#125;]; 现在再 TextField 中输入，只有当字符串长度超过3点时候才会在控制台打印出来。 信号的处理在 ReactiveCocoa 中还可以对当前原始信号进行处理后在进入到事件流中。如下： 1234567[[[self.usernameTextField.rac_textSignal map:^id _Nullable(NSString * _Nullable value) &#123; return @(value.length);&#125;] filter:^BOOL(id _Nullable value) &#123; return [value integerValue] &gt; 3;&#125;] subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;%@&quot;,x);&#125;]; 上面的代码中我们就将 NSString 类型的 Vlue 进行了处理，当它传到下一步时就成了NSNumber 类型了。当然也可以对这里的 Value 做其他操作，传到下一步的时候就是其他类型的数据了。 信号合成在某些时候，我们可能需要多种信号都满足某个条件后再进行下一步的操作和执行。比如做一个登陆的时候，当账号和密码都满足的时候才可以进行下一步的处理。这个时候我们就可以使用信号合并，将账号验证的信号和密码验证的信号合并后来出来。 12345678910111213141516171819202122232425262728//账户验证的信号RACSignal *validUserNameSignal = [self.usernameTextField.rac_textSignal map:^id _Nullable(NSString * _Nullable value) &#123; return @([self isValidUsername:value]);&#125;];//密码验证的信号RACSignal *validPassWordSignal = [self.passwordTextField.rac_textSignal map:^id _Nullable(NSString * _Nullable value) &#123; return @([self isValidPassword:value]); &#125;]; //信号合并，完成登陆按钮的可点击RACSignal *mergeSignal = [RACSignal combineLatest:@[validUserNameSignal,validPassWordSignal] reduce:^id (NSNumber *userNameValid, NSNumber *passWordValid)&#123; return @([userNameValid boolValue] &amp;&amp; [passWordValid boolValue]);&#125;];//再次订阅合并的信号处理登陆按钮的响应[mergeSignal subscribeNext:^(id _Nullable x) &#123; self.signInButton.enabled = [x boolValue];&#125;];//账户和密码的验证方式- (BOOL)isValidUsername:(NSString *)username &#123; return username.length &gt; 3;&#125;- (BOOL)isValidPassword:(NSString *)password &#123; return password.length &gt; 3;&#125; 上面这段代码就使用信号合并，合并后的信号携带了一个 Bool 值，当每次其中一个发送新的信号时 reduce 中的block 就会执行返回的这个 Bool 值就会作为一个新的合成的这个信号发送出去，最终通过订阅这个合并后的信号携带的 Bool 值来判断登陆按钮是否可以被点击。 注意：RACSignal合成方法可以合成任意数量的信号，而reduce block的入参和源信号一一对应。ReactiveCocoa有一个巧妙的工具类RACBlockTrampoline，用以内部处理reduce block的可变入参列表。 信号中的信号有时候在信号中，我们可能还需要去创建一个新的信号，用来处理事件，但是这种信号中的信号，就是一个信号中又包含了另外一个信号。要怎么去处理呢？ ​ 可以通过在信号中去订阅这个内部的信号来获取里面信号的结果，但是这样做来说订阅嵌套会让代码很混乱，所以 ReactiveCocoa 为这样的情况提供了一个解决的方式。 使用 flattenMap 就可以过滤获取到内部的信号，在传到下一个事件的时候就传递的是内部的信号了。 12345678910111213141516171819[[[self.signInButton rac_signalForControlEvents:UIControlEventTouchUpInside] flattenMap:^__kindof RACSignal * _Nullable(__kindof UIControl * _Nullable value) &#123; return [self loginSignal];&#125;]subscribeNext:^(id _Nullable x) &#123; BOOL isLoginSucces = [x boolValue]; self.signInFailureText.hidden = isLoginSucces; [self performSegueWithIdentifier:@&quot;signInSuccess&quot; sender:self];&#125;];- (RACSignal *)loginSignal &#123; return [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [self.signInService signInWithUsername:self.usernameTextField.text password:self.passwordTextField.text complete:^(BOOL success) &#123; [subscriber sendNext:@(success)]; [subscriber sendCompleted]; &#125;]; return [RACDisposable disposableWithBlock:^&#123; NSLog(@&quot;信号订阅被取消&quot;); &#125;]; &#125;];&#125; 上面这段代码在处理按钮点击的信号中调用 [self loginSignal] 方法返回了一个新的信号，这就造成了信号中的信号，在下面的信号传递中获取到的 x 就获取到的是一个信号，而不是想要登陆的信号。所以这里用 flattenMap 去获取信号中的信号，以方便在接下来的信号传递中能方便的获取到信号中登陆信号中传递的值。 注入效果注入效果，主要的作用的是在信号发出的时候做出一些处理。注入效果有这样三种 -doNext: 、-doError: 、 -doCompleted: ，注入效果没有返回值，它只是在其对应的操作之前执行 block 中的代码。如下，在 -subscribeNext: 前作一些其他处理就可以使用 -doNext: 的注入效果： 123456789[[[[self.signInButton rac_signalForControlEvents:UIControlEventTouchUpInside] doNext:^(__kindof UIControl * _Nullable x) &#123; self.signInButton.enabled = NO;&#125;]flattenMap:^__kindof RACSignal * _Nullable(__kindof UIControl * _Nullable value) &#123; return [self loginSignal];&#125;]subscribeNext:^(id _Nullable x) &#123; BOOL isLoginSucces = [x boolValue]; self.signInFailureText.hidden = isLoginSucces; [self performSegueWithIdentifier:@&quot;signInSuccess&quot; sender:self];&#125;]; 这里就是在按钮被点击的时候在 -doNext: 的注入效果中将登陆按钮设置为不可用。 其余两个注入效果也是一样的，分别是在 -subscribeError: 和 -subscribeCompleted: 执行之前执行 block 中的代码，但是如果添加了注入效果，但是后面没有进行 -subscribeNext: 、 -subscribeError: 和 -subscribeCompleted: 操作的话注入效果是不会执行的。","categories":[],"tags":[{"name":"Reactive Cocoa","slug":"Reactive-Cocoa","permalink":"Aaronzjp.cn/tags/Reactive-Cocoa/"}]},{"title":"ReactiveCocoa 基础教程 2-2（译）","slug":"ReactiveCocoa-Tutorial-2-2","date":"2017-06-20T14:32:12.000Z","updated":"2018-11-24T09:35:58.686Z","comments":true,"path":"2017/06/20/ReactiveCocoa-Tutorial-2-2/","link":"","permalink":"Aaronzjp.cn/2017/06/20/ReactiveCocoa-Tutorial-2-2/","excerpt":"本文是翻译自国外网站的文章，其实这篇文章有很多的现成的翻译，但是看了过后感觉我自己很难理解别人的翻译方式，所以用自己的方式翻译了一遍，顺便也是加深一下印象。原文地址 ReactiveCocoa 这个框架允许将响应式编程技术应用到你的 iOS App 项目中。在上一个章节教程中介绍了如何使用事件流以及信号去替换标准的事件操作，以及事件处理逻辑。同时也介绍了如何改变信号中传递的数据，以及分割信号，合并信号。 在这一部分将要介绍 ReactiveCocoa 中更多高级的用法： 另外的两个事件类型 error 和 complete 节流(Throttling) 线程 持续性(Continuations) 更多 是时候开始了！","text":"本文是翻译自国外网站的文章，其实这篇文章有很多的现成的翻译，但是看了过后感觉我自己很难理解别人的翻译方式，所以用自己的方式翻译了一遍，顺便也是加深一下印象。原文地址 ReactiveCocoa 这个框架允许将响应式编程技术应用到你的 iOS App 项目中。在上一个章节教程中介绍了如何使用事件流以及信号去替换标准的事件操作，以及事件处理逻辑。同时也介绍了如何改变信号中传递的数据，以及分割信号，合并信号。 在这一部分将要介绍 ReactiveCocoa 中更多高级的用法： 另外的两个事件类型 error 和 complete 节流(Throttling) 线程 持续性(Continuations) 更多 是时候开始了！ Twitter 即时搜索在这个教程中，你将要开发一个叫 Twitter 即时搜索的 App (基于 Google 的即时搜索功能)，这是一个搜索 Twitter 的 App，它可以在你输入搜索的时候实时的更新搜索结果。 在这个开始项目中包含了基本的用户界面和一些很乏味的代码，你需要下载这个开始项目。就想第一章教程一样，你需要使用 CocoaPods 来安装 ReactiveCocoa 这个到你的项目中。这个开始项目中已经包含了必要的 Podfile 文件了，所以直接打开 terminal 窗口执行 pod install 命令即可。详细的就不翻译了，相信 Pod 大家还是会使用的。 编译运行项目，接下来你就可以看到如下界面： 使用一点时间先熟悉译者这个项目的代码。这是一个普通的 SplitViewController App。左边的视图是一个叫 RWSearchFormViewController 的控制器，这里面这些极少的控件都是通过 Storyboard 添加的，还有这个搜索输入框是连接到代码中一个 Outlet 的。右边的视图是一个叫 RWSearchResultsViewController 的控制器，现在这部分仅仅只是一个基于 UITableViewController 的子类。 如果你打开了 RWSearchFormViewController.m 文件，你可以看到在 viewDidLoad 方法中获得了结果视图控制器，并把其赋值给了 reasultsViewController 这个私有属性。在这个应用中，大多数的逻辑都将放在 RWSearchFormViewController 这个文件中，将通过这个属性，提供搜索结果给 RWSearchResultsViewController。 验证搜索文本首先第一件事就是要去验证搜索文本的字符长度，确保长度大于2。这应该是一个很好的复习，如果你完成了这个教程的第一部分。 在 RWSearchFormViewController.m 文件中添加如下的代码到 viewDidLoad 方法中： 123- (BOOL)isValidSearchText:(NSString *)text &#123; return text.length &gt; 2;&#125; 这就简单的确保了用来搜索的字符串长度大于两个字符。你可能会想，像那样简单的逻辑为什么要单独的使用一个方法？ 当前的逻辑确实很简单，但是如果以后会有很复杂的需求呢？像上面例子这样，你以后就只需要修改这一个地方。此外，上面的代码使您的代码更具表达性，并说明了为什么要检查字符串的长度。我们一直跟着这样好的代码练习，好吗？ 还是在当前的文件中，我们倒入 ReactiveCocoa: 1#import &lt;ReactiveCocoa.h&gt; 接着添加如下的代码到 viewDidLoad 方法结尾： 12345678[[self.searchText.rac_textSignal map:^id(NSString *text) &#123; return [self isValidSearchText:text] ? [UIColor whiteColor] : [UIColor yellowColor]; &#125;] subscribeNext:^(UIColor *color) &#123; self.searchText.backgroundColor = color; &#125;]; 你还在惊讶上面那些都是什么鬼？上面代码做了哪些事情： 添加了一个信号到搜索输入框 根据信号判断输入是否有效，并将其转换为背景色 在 subscribeNext: block 中将背景色应用到搜索输入框的 backgroundColor 属性上 编译运行程序，观察文本输入框是如何改变背景色的，在输入的搜索字符太短的时候。 这个简单的响应式事件流管道看起来就想下面插图这样： rac_textSignal 信号在当前输入框每次发生改变的时候都会发送 next 事件。在 map 这一步中将信号中的数据转换成了颜色，当 subscribeNext: 执行的时候就会把这个值应用到输入框的背景色上。 当然你肯定记得这是来自教程的第一部分，对吗？如果不是那么你可以在这里停下来，好好理解练习一下。 在给 Twitter 添加搜索逻辑之前，这里还有一些有趣的话题要讨论。 流式编程代码格式当你深入的研究 ReactiveCocoa 的代码格式的时候，一般的习惯是每一个新的操作都会新起一行，每个步骤都会垂直的对齐。 在下面的这个图片上，你可以看到按照上面的格式在比较负责的例子中代码是怎么对齐的： 这可以让你很容易清晰的看到流式编程的每一步操作，同时也尽量的减少了别个 block 中的代码量。任何一个超过两行的代码都应该单独的抽出来写到一个方法中去。 不幸的是 Xcode 并不支持这样的编程风格，所以你发现你会和它的自动缩进逻辑作斗争。 内存管理考虑到刚刚添加的代码到 TwitterInstant 项目中，你肯定很好奇你创建的事件流是怎么被保留的？因为它没有被分配个任何变量，也没有赋值给任何属性，也不会增加它的引用计数，所以会被销毁？ ReactiveCocoa 设计的目的之一就是为了允许这样的编程风格，随处可见的匿名事件流。在你写的所有的响应式编程的代码中，这个应该看起来更加直观吧。 为了支持这样的模式，ReactiveCocoa 保留并保持了自己的全局信号集合列表。如果事件流有一个或多个订阅者，那么这个信号是活跃的。如果所有的订阅者都被移除了，那么这个信号也会被回收释放。更多关于 ReactiveCocoa 如何管理队列的，请查看 ReactiveCocoa 的官方文档，内存管理部分。 最后一个问题：如何取消信号订阅？在 complete 或者 error 事件之后，订阅者会被自动移除(你接下来将会学习更多关于这部分)。手动取消订阅可以通过 RACDisposable。 在 RACSignal 的订阅信号的方法中都会返回一个 RACDisposable 的实例对象，通过这个实例对象的 dispose 方法可以手动的取消订阅。这里有一个快速创建的例子，在当前的事件流中使用： 123456789101112131415RACSignal *backgroundColorSignal = [self.searchText.rac_textSignal map:^id(NSString *text) &#123; return [self isValidSearchText:text] ? [UIColor whiteColor] : [UIColor yellowColor]; &#125;]; RACDisposable *subscription = [backgroundColorSignal subscribeNext:^(UIColor *color) &#123; self.searchText.backgroundColor = color; &#125;];// at some point in the future ...[subscription dispose]; 这样的操作可能不是经常使用，但有必要知道。 提示：所以如果你创建了一个事件流，但是没有订阅者，那么这个事件流事件将永远不会执行，包括副作用 doNext: block 中的代码 避免循环引用虽然 ReactiveCocoa 在内部做了很多聪明的处理，让你不用担心信号管道的内存管理的问题。但是有一个很重要的与内存管理相关的问题需要考虑。 如果你看一下刚刚添加的响应式代码： 12345678[[self.searchText.rac_textSignal map:^id(NSString *text) &#123; return [self isValidSearchText:text] ? [UIColor whiteColor] : [UIColor yellowColor]; &#125;] subscribeNext:^(UIColor *color) &#123; self.searchText.backgroundColor = color; &#125;]; 在 subscribeNext: 的 block 代码中使用了 self 去获得了文本输入框的引用。block 捕获并持有了闭包范围的值，所以在 self 和信号之间相互出强应用，造成了循环引用。这个的重要程度取决于 self 对象的生命周期。如果它的生命周期是和应用的生命周期是一样的那么其实也没有什么可以担心的。但是在复杂的应用中这样的情况是很少出现的。 为了避免这样的潜在的循环引用，在苹果的官方文档中如何使用block一节推荐使用弱引用的方式去捕获 self 。在当前的代码中你可以这样实现： 12345678910__weak RWSearchFormViewController *bself = self; // Capture the weak reference[[self.searchText.rac_textSignal map:^id(NSString *text) &#123; return [self isValidSearchText:text] ? [UIColor whiteColor] : [UIColor yellowColor]; &#125;] subscribeNext:^(UIColor *color) &#123; bself.searchText.backgroundColor = color; &#125;]; 在上面的代码中 bself 是已经被 __weak 标记设置为弱引用的 self 。注意，现在 subscribeNext: 的 block 中就使用了 bself 变量。这个看起来一点也不优雅！ 在 ReactiveCocoa 的框架中包含了一些小技巧，你可以用来替换上面的代码。像下面这样先在顶部导入文件: 1#import &quot;RACEXTScope.h&quot; 然后像下面这样替换之前的代码： 12345678910@weakify(self)[[self.searchText.rac_textSignal map:^id(NSString *text) &#123; return [self isValidSearchText:text] ? [UIColor whiteColor] : [UIColor yellowColor]; &#125;] subscribeNext:^(UIColor *color) &#123; @strongify(self) self.searchText.backgroundColor = color; &#125;]; 像上面的 @weakify 和 @strongify 声明被定义在 Extended Objective-C 库中，他们也被包含在了 ReactiveCocoa 的库中。@weakify 宏定义允许你创建一个弱引用的影子变量(如果你需要多个弱引用变量，你可以传递多个参数进去)。@strongify 宏定义允许你创建一个之前传递给 @weakify 变量的强引用。 提示：如果你对 @weakify 和 @strongify 实际做了什么感兴趣，你可以在 Xcode 菜单中选中 Product -&gt; Perform Action -&gt; Preprocess 在 RWSearchForViewController 文件中。这将预先处理 RWSearchForViewController 视图控制器，展开其中所有的宏，并允许你查看最终结果。 还有一点要非常小心，当你在 block 中使用实例变量的时候，block 也会捕获并强引用 self 。你可以打开一个编译器设置，用来提醒你代码中存在这样的问题。在 Xcode 项目设置中找到 building setting 选项，搜索 retain 找到如下图所示的地方并设置为 Yes： 从上面的理论中你也了解了更多的知识，现在是时候开始真正有趣的部分了，向项目中添加真正的功能吧！ 提示：关注了上一篇教程的读者可能已经注意到可以使用 RAC 宏在 subscribeNext: 代码块中消除上面存在的隐患。如果你发现了这里，那就修改一下吧，顺便奖励给自己一颗闪亮的金星✨ Twitter接入请求你将要通过 Social Framework 框架使 TwitterInstant 应用来搜索 Tweets。以及 Accounts Framework 来授权访问 Twitter。更多关于 Social Framework 框架的概述以及教程，可以去这里查看 iOS6 中的教程 相关的部分。 在你添加这些代码之前，你需要在你的模拟器或者 iPad 上登录你的 Twitter 账号。打开设置选择 Twitter 菜单，然后登录账号吧，如下所示： 在初始开始项目中已经导入了相关的框架，所以你只需要在 RWSearchFormViewController.m 文件中导入头文件即可： 12#import &lt;Accounts/Accounts.h&gt;#import &lt;Social/Social.h&gt; 在头文件的导入下面添加如下枚举和常量，代码： 1234567typedef NS_ENUM(NSInteger, RWTwitterInstantError) &#123; RWTwitterInstantErrorAccessDenied, RWTwitterInstantErrorNoTwitterAccounts, RWTwitterInstantErrorInvalidResponse&#125;;static NSString * const RWTwitterInstantDomain = @&quot;TwitterInstant&quot;; 你将使用这个去识别错误。 接下来在 @interface 中声明如下属性: 12@property (strong, nonatomic) ACAccountStore *accountStore;@property (strong, nonatomic) ACAccountType *twitterAccountType; ACAccountsStore 类为设备提供了可以连接各个社交媒体的账户访问权限，ACAccountType 类表示特定的账户类型。 接下来在同一个文件中的 viewDidLoad: 方法下添加如下的代码： 123self.accountStore = [[ACAccountStore alloc] init];self.twitterAccountType = [self.accountStore accountTypeWithAccountTypeIdentifier:ACAccountTypeIdentifierTwitter]; 这一步创建了账户的存储和 Twitter 账户的标识符。 当 App 访问社交媒体账户的时候，用户会看到弹出的一个窗口。这是一个异步的操作，因此是可以很好的用来包装成信号的候选者，以便用来很好的响应！ 接下来在同样的文件中添加如下方法： 123456789101112131415161718192021222324252627- (RACSignal *)requestAccessToTwitterSignal &#123; // 1 - define an error NSError *accessError = [NSError errorWithDomain:RWTwitterInstantDomain code:RWTwitterInstantErrorAccessDenied userInfo:nil]; // 2 - create the signal @weakify(self) return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; // 3 - request access to twitter @strongify(self) [self.accountStore requestAccessToAccountsWithType:self.twitterAccountType options:nil completion:^(BOOL granted, NSError *error) &#123; // 4 - handle the response if (!granted) &#123; [subscriber sendError:accessError]; &#125; else &#123; [subscriber sendNext:nil]; [subscriber sendCompleted]; &#125; &#125;]; return nil; &#125;];&#125; 这个方法主要做了以下几个操作： 定义了一个错误对象，用于用户拒绝访问。 根据教程的第一部分可以知道，createSignal 这个方法返回一个 RACSignal 实例。 从账户存储系统中访问 Twitter 账号，在这个时候用户会看到一个提示，请求用户允许 App 访问 Twitter 账户。 在用户允许或者拒绝访问后，信号会发送事件。如果用户允许访问，就会发送 next 事件，跟着会发送 complete 事件。如果用户拒绝访问，就会发送一个 error 事件。 如果你回忆一下本教程的第一篇文章，信号是可以发送三种不同类型的事件的： Next 事件 Complete 事件 Error 事件 在信号的生命周期中，如果信号在发送了一个或多个 next 事件紧接着发送另一个 complete 事件或者 error 事件，在这之后信号就不会发送任何事件了。 最后，为了使用刚刚创建的信号，在 viewDidLoad: 方法中加入如下的代码： 123456[[self requestAccessToTwitterSignal] subscribeNext:^(id x) &#123; NSLog(@&quot;Access granted&quot;); &#125; error:^(NSError *error) &#123; NSLog(@&quot;An error occurred: %@&quot;, error); &#125;]; 如果你编译运行程序，你会马上看到如下图的提示： 如果点击 OK，就会执行 subscribeNext: 中 block 的代码，在控制台输出。如果点击 Don’t Allow，那么就会执行错误中的 block ，在控制台输出。 Account Framework 会存储你做的决定。为了测试各种情况，你需要重置模拟器。在模拟器的菜单栏选择 iOS Simulator -&gt; Reset Contents and Settings… 选项。这有点麻烦，因为你又要输入一次你的 Twitter 账号。 信号链一旦用户允许访问他们的Twitter帐户，应用程序就需要不断地监视对搜索文本字段的更改，以便查询Twitter。 应用需要等待请求访问 Twitter 账户的信号发送完成事件，然后订阅文本输入框的信号。这样的顺序链出现在不同的信号中是很常见的问题，但是在 ReactiveCocoa 中可以很优雅的处理。 使用下面的代码在 viewDidLoad: 方法中替换当前的事件流管道： 12345678910[[[self requestAccessToTwitterSignal] then:^RACSignal *&#123; @strongify(self) return self.searchText.rac_textSignal; &#125;] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;, x); &#125; error:^(NSError *error) &#123; NSLog(@&quot;An error occurred: %@&quot;, error); &#125;]; then 方法将等到 complete 事件发送，接着订阅信号会返回一个 block。这将有效的控制信号的传递。 提示：你在上面的事件流管道中已经定义了 weakself 了，所以在这里不需要再次使用 @weakify(self) 定义。 Then 方法会通过 error 事件的传递，所以最终 subscribeNext:error: 方法中的 block 仍然能收到初始化访问请求那一步的错误消息。 当你编译并运行程序后，在输入框输入文本，你应该能看到类似如下的输出： 1234562014-01-04 08:16:11.444 TwitterInstant[39118:a0b] m2014-01-04 08:16:12.276 TwitterInstant[39118:a0b] ma2014-01-04 08:16:12.413 TwitterInstant[39118:a0b] mag2014-01-04 08:16:12.548 TwitterInstant[39118:a0b] magi2014-01-04 08:16:12.628 TwitterInstant[39118:a0b] magic2014-01-04 08:16:13.172 TwitterInstant[39118:a0b] magic! 接下来在事件流管道中添加 filter 操作，用来移除无效的搜索字符串。在这个例子中字符串必须由大于三个的支付组成: 1234567891011121314[[[[self requestAccessToTwitterSignal] then:^RACSignal *&#123; @strongify(self) return self.searchText.rac_textSignal; &#125;] filter:^BOOL(NSString *text) &#123; @strongify(self) return [self isValidSearchText:text]; &#125;] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;, x); &#125; error:^(NSError *error) &#123; NSLog(@&quot;An error occurred: %@&quot;, error); &#125;]; 编译后再次运行，观察添加了过滤器后的输出: 1232014-01-04 08:16:12.548 TwitterInstant[39118:a0b] magi2014-01-04 08:16:12.628 TwitterInstant[39118:a0b] magic2014-01-04 08:16:13.172 TwitterInstant[39118:a0b] magic! 当前事件流管道流程如下图所示： 应用的事件流管道开始于 requestAccessToTwitterSignal 接着切换到 rac_textSignal 。同时 next 事件通过过滤器最终到达了订阅者的 block 中。你也可以看到第一步中发出的任何的 error 都会被同样的 subscribeNext:error: 接收到，并执行 block 中的代码。 现在你又了一个发送搜索文本的信号，是时候用这个来搜索 Twitter 了。你玩得开心吗?你应该这样做，因为现在你真的有所收获。 搜索 TwitterSocial Framework 库是一个可以访问 Twitter 搜索的 API 的选择。然后就像你预计的那样，Social Framework 框架并不是响应式的！下一步就是在信号中封装一个 API 的请求。你现在应该掌握这个过程的窍门了! 在 RWSearchFormViewController.m 文件中加入如下的代码： 12345678910- (SLRequest *)requestforTwitterSearchWithText:(NSString *)text &#123; NSURL *url = [NSURL URLWithString:@&quot;https://api.twitter.com/1.1/search/tweets.json&quot;]; NSDictionary *params = @&#123;@&quot;q&quot; : text&#125;; SLRequest *request = [SLRequest requestForServiceType:SLServiceTypeTwitter requestMethod:SLRequestMethodGET URL:url parameters:params]; return request;&#125; 这里根据 Twitter 的 v1.1 REST API 创建了一个请求，上面的代码中使用 q 作为请求参数的 key 来包含搜索的字符串。你可以在 Twitter API docs 中阅读更多关于搜索的 API ，还可以传入其他的参数。 接下来基于这个请求创建一个事件流管道。在同样的文件中添加如下的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950- (RACSignal *)signalForSearchWithText:(NSString *)text &#123; // 1 - define the errors NSError *noAccountsError = [NSError errorWithDomain:RWTwitterInstantDomain code:RWTwitterInstantErrorNoTwitterAccounts userInfo:nil]; NSError *invalidResponseError = [NSError errorWithDomain:RWTwitterInstantDomain code:RWTwitterInstantErrorInvalidResponse userInfo:nil]; // 2 - create the signal block @weakify(self) return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; @strongify(self); // 3 - create the request SLRequest *request = [self requestforTwitterSearchWithText:text]; // 4 - supply a twitter account NSArray *twitterAccounts = [self.accountStore accountsWithAccountType:self.twitterAccountType]; if (twitterAccounts.count == 0) &#123; [subscriber sendError:noAccountsError]; &#125; else &#123; [request setAccount:[twitterAccounts lastObject]]; // 5 - perform the request [request performRequestWithHandler: ^(NSData *responseData, NSHTTPURLResponse *urlResponse, NSError *error) &#123; if (urlResponse.statusCode == 200) &#123; // 6 - on success, parse the response NSDictionary *timelineData = [NSJSONSerialization JSONObjectWithData:responseData options:NSJSONReadingAllowFragments error:nil]; [subscriber sendNext:timelineData]; [subscriber sendCompleted]; &#125; else &#123; // 7 - send an error on failure [subscriber sendError:invalidResponseError]; &#125; &#125;]; &#125; return nil; &#125;];&#125; 分析一下上面的每一步操作： 最初你需要定义两个不同的错误实例，一个代表用户没有添加任何的 Twitter 账号在该设备上，另一个代表发送请求查询自身的错误。 像之前一样创建一个信号 使用你在上一个环节中添加的方法，根据搜索的字符串创建一个请求。 在设备存储的账户中找到一个有效的 Twitter 账户，如果没有就发送一个错误事件 执行请求 在请求成功( HTTP 响应代码200)的情况下，解析返回的 JSON 数据使用 next 事件发出，紧接着发送 complete 事件。 如果请求响应失败，就发送一个 error 事件。 现在就来使用这个新的信号吧！ 在本教程的第一部分你已经学习了如何使用 flattenMap 将每个 next 事件映射成一个新的信号，然后订阅该信号。现在又要使用一次。在 viewDidLoad: 方法最后的事件流管道中加上 flattenMap 步骤： 编译并运行，然后输入一些文本到搜索输入框。一旦文本超过三个字符你就会看到 Twitter 的搜索结果出现在日志打印窗口。 下面是一部分请求到的数据片段： 123456789101112131415161718192014-01-05 07:42:27.697 TwitterInstant[40308:5403] &#123; \"search_metadata\" = &#123; \"completed_in\" = \"0.019\"; count = 15; \"max_id\" = 419735546840117248; \"max_id_str\" = 419735546840117248; \"next_results\" = \"?max_id=419734921599787007&amp;q=asd&amp;include_entities=1\"; query = asd; \"refresh_url\" = \"?since_id=419735546840117248&amp;q=asd&amp;include_entities=1\"; \"since_id\" = 0; \"since_id_str\" = 0; &#125;; statuses = ( &#123; contributors = \"&lt;null&gt;\"; coordinates = \"&lt;null&gt;\"; \"created_at\" = \"Sun Jan 05 07:42:07 +0000 2014\"; entities = &#123; hashtags = ... signalForSearchText: 方法也会发送 error 事件，subscribeNext:error: 方法会收到 error 事件并执行 block。如果你相信我的话，你可以自己测试一下！ 在模拟器打开设置，选择 Twitter 账户，然后删除。 如果你再次运行程序，选择运行访问 Twitter 账户，但是因为这里没有有效的的账户，所以结果就是 signalForSearchText 方法会发送一个错误事件，控制台输出如下： 122014-01-05 07:52:11.705 TwitterInstant[41374:1403] An error occurred: Error Domain=TwitterInstant Code=1 &quot;The operation couldn’t be completed. (TwitterInstant error 1.)&quot; Code = 1 意味着这是一个 RWTwitterInstantErrorNoTwitterAccounts 错误。在生产环境中的应用，你应该打开错误代码，做一些比记录结果更有意义的事情。 这说明了关于错误事件的一个很重要点;一旦发出 error 事件。就会直接进入到处理错误的 block 中。这是一个异常的处理流程。 提示：尝试去处理 Twitter 请求错误的其他处理流程。这里有一个快速的提示，当更改请求的参数无效的时候！ 线程当然你也很渴望将搜索 Twitter 的 JSON 结果连接显示到 UI 上，但是在这之前你还有最后一件事要做。要找出这是什么，你需要进行一番探索！ 在 subscribeNext:error: 这一步中加上断点，如下图所示： 再运行程序，获取访问权限后在文本输入框输入文字，当断点执行的时候，你能看到如下图所示的东西： 注意，在调试器上的代码不是在主线程中执行的，在截图中 Thread 1 是主线程。需要记住的是，UI的更新是只能在主线程进行的。所以如果你想要在 UI 上显示搜索到的 tweets 就必须切换到主线程去。 这说明了 ReactiveCocoa 框架很重要的一点。发送信号的操作是在异步线程中执行的，你可以试下在其他的事件流管道中打上断点查看，你可能会惊讶的发现它在更多的线程中执行。 所以，怎么来更新 UI 呢？典型的方法是使用操作队列，但是ReactiveCocoa对这个问题有一个更简单的解决方案。更新事件流管道中的代码，在 flattenMap: 之后加上 deliverOn: 方法，如下所示： 12345678910111213141516171819[[[[[[self requestAccessToTwitterSignal] then:^RACSignal *&#123; @strongify(self) return self.searchText.rac_textSignal; &#125;] filter:^BOOL(NSString *text) &#123; @strongify(self) return [self isValidSearchText:text]; &#125;] flattenMap:^RACStream *(NSString *text) &#123; @strongify(self) return [self signalForSearchWithText:text]; &#125;] deliverOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;, x); &#125; error:^(NSError *error) &#123; NSLog(@&quot;An error occurred: %@&quot;, error); &#125;]; 现在再次编译运行程序，在输入框输入文本，断点运行的时候查看断点运行的地方，现在 subscribeNext:error: block 就是在主线程执行的了： 什么？只需要这样简单的操作就能把事件流管道放到不同的线程上？这真的是太棒了！ 现在你可以安全的更新 UI 了！ 提示：如果你查看 RACScheduler 类，你会看到有很多选项可以给线程设置不用的优先级，或者给事件流管道添加延迟执行。 是时候来看看这些 tweets 了！ 更新 UI如果你已经打开了 RWSearchResultsViewController.h 文件，你会看到已经有一个 displayTweets: 方法了，这个方法会将提供 tweets 的数组在右边的视图控制器中展示出来。这实现起来很简单，只需要实现标准的 UITableView 的 dataSource 即可。在 displayTweets: 方法中有一个参数，是一个包含了 RWTweet 实例对象的数组。你也可以找到 RWTweet 模型对象，这在一开始的初始项目中就提供了。 当数据传递到 subscibeNext:error: 这一步的时候，当前数据是一个字典( NSDictionary )，是在 signalForSearchWithText: 方法中通过解析 JSON 数据得来的。所以怎么查看字典中的内容？ 如果你查看了 Twitter 官方 API 文档 你会看到一个请求响应的例子。这里的字典就是这样的格式，在字典里有一个 statuses 的 key 。那是一个包含了 tweets 的数字，内部也是一个 字典( NSDictionary )实例。 如果你查看了 RWTweet 类，它已经有一个 tweetWithStatus: 方法用来从字典( NSDictionary )格式化取出数据。所以你要做的就是去遍历数组，并为每一个 tweet 创建一个实例化的 RWTweet 对象。 不管怎么样你都是不会去这样做的，这里有更好的东西去做这样的事。 这篇文章是关于 ReactiveCocoa 和响应式编程的。当你把数据转换到另一种格式的时候，使用 API 的时候是有更加优雅的方法的。您将使用 LinqToObjectiveC 来完成这部分。 如何添加这个框架我就不翻译了，就是使用 cocoaPods 添加。 接下来打开 RWSearchFormViewController.m 文件，添加如下的代码： NSArray+LinqExtensions.h 头文件是来自 LinqToObjectiveC 框架，这个框架在 NSArray 中添加了一些方法，用来转换，排序索引，分组，过滤数据。 现在就来使用这些 API，更新当前的事件流管道的代码，在 viewDidLoad: 方法中： 1234567891011121314151617181920212223[[[[[[self requestAccessToTwitterSignal] then:^RACSignal *&#123; @strongify(self) return self.searchText.rac_textSignal; &#125;] filter:^BOOL(NSString *text) &#123; @strongify(self) return [self isValidSearchText:text]; &#125;] flattenMap:^RACStream *(NSString *text) &#123; @strongify(self) return [self signalForSearchWithText:text]; &#125;] deliverOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(NSDictionary *jsonSearchResult) &#123; NSArray *statuses = jsonSearchResult[@&quot;statuses&quot;]; NSArray *tweets = [statuses linq_select:^id(id tweet) &#123; return [RWTweet tweetWithStatus:tweet]; &#125;]; [self.resultsViewController displayTweets:tweets]; &#125; error:^(NSError *error) &#123; NSLog(@&quot;An error occurred: %@&quot;, error); &#125;]; 在上面的代码中，通过在 subscribeNext: 的 block 中获得了装有 tweets 的数字。linq_select 方法通过在每个数组元素上执行 block 中的代码，来转换NSDictionary实例的数组，从而产生一个RWTweet实例数组。 数据转换成功后，tweet 就被发送到结果视图控制器。 编译并运行程序，试着搜索一下，结果如下图： 提示：ReactiveCocoa 和 LinqToObjectiveC 有着相似的灵感来源。虽然ReactiveCocoa是模仿微软的 Reactive Extensions 库，LinqToObjectiveC 是模仿他们的语言集成查询 API，或者LINQ，特别是 LINQ to Objects。 异步加载图片你可能已经注意到了每个 tweets 左边都有一个空白，那个空间是用来显示 Twitter 用户头像的。 在 RWTweet 内中已经有一个叫 profileImageUrl 的 URL 属性了，用来请求图片。为了使表视图平滑地滚动，您需要确保从给定 URL 获取图像的代码不会在主线程上执行。这可以通过使用 Grand Central Dispatch 或 NSOperationQueue 实现。但是为什么不使用ReactiveCocoa呢? 打开 RWSearchResultsViewController.m 文件，添加如下的代码： 1234567891011121314-(RACSignal *)signalForLoadingImage:(NSString *)imageUrl &#123; RACScheduler *scheduler = [RACScheduler schedulerWithPriority:RACSchedulerPriorityBackground]; return [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:imageUrl]]; UIImage *image = [UIImage imageWithData:data]; [subscriber sendNext:image]; [subscriber sendCompleted]; return nil; &#125;] subscribeOn:scheduler]; &#125; 现在你应该对这个模式很熟悉了！ 上面的代码中第一步是获得了一个异步后台线程，因为你希望这个信号在主线程以外执行。接下来创建了一个下载图片数据的信号，当有订阅者的时候创建图片。最后使用 subscribeOn: 方法让信号在异步线程中执行！ 魔法！ 现在在同样文件的 tableView:cellForRowAtIndex: 方法中，添加如下的代码： 1234567cell.twitterAvatarView.image = nil;[[[self signalForLoadingImage:tweet.profileImageUrl] deliverOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(UIImage *image) &#123; cell.twitterAvatarView.image = image; &#125;]; 上面代码的第一步就是先将之前 cell 中的图片设置为 nil ，因为 cell 会被重用，可能会重用之前的数据。接下来创建了一个信号去请求图片数据。在事件流管道的 deliverOn: 这一步骤中你以前也用到过，将 next 事件封装切换到主线程，然后在 subscribeNext: 的 block 中可以安全的执行。 很好，很简单的例子！ 编译运行，现在就可以看到用户的头像了。 节流阀你可能注意到了，你每次输入新的字符，Twitter 搜索每次都会执行。如果是输入很快(或者一直按着删除键)，这回导致程序每秒执行几次搜索操作。这样的效果并不是很理想，主要有以下两个原因：第一，你每一次输入都会请求搜索 API，然后丢掉了大部分的搜索结果。第二，每次搜索文字变化都要去更新结果，这样让会用很分心！ 一个更好的方法是只在搜索文本在短时间内保持不变的情况下执行搜索，比如500毫秒。 打开 RWSearchFormViewController.m 文件，在事件流管道中添加一个 throttle 步骤到 filter 后面，更新后到代码如下： 123456789101112131415161718192021222324[[[[[[[self requestAccessToTwitterSignal] then:^RACSignal *&#123; @strongify(self) return self.searchText.rac_textSignal; &#125;] filter:^BOOL(NSString *text) &#123; @strongify(self) return [self isValidSearchText:text]; &#125;] throttle:0.5] flattenMap:^RACStream *(NSString *text) &#123; @strongify(self) return [self signalForSearchWithText:text]; &#125;] deliverOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(NSDictionary *jsonSearchResult) &#123; NSArray *statuses = jsonSearchResult[@&quot;statuses&quot;]; NSArray *tweets = [statuses linq_select:^id(id tweet) &#123; return [RWTweet tweetWithStatus:tweet]; &#125;]; [self.resultsViewController displayTweets:tweets]; &#125; error:^(NSError *error) &#123; NSLog(@&quot;An error occurred: %@&quot;, error); &#125;]; 节流阀操作是，如果在给定的时间内没有收到下一个 next 事件，就会把这个 next 事件发送到下一步中，这是真的很简单！ 构建并运行，以确认搜索结果只有在您停止输入500毫秒时才会更新。感觉好多了，不是吗?你的用户也会这么想。最后一步，你的Twitter即时应用程序完成了。拍拍自己的背，跳个开心的舞。 如果你在教程中的某个地方丢掉了一些东西，你可以下载最终完成的项目，或者从 GitHub 获取项目。 总结在你去喝一杯胜利杯咖啡之前，你应该欣赏一下应用程序最终的流程图: 这些相对复杂的事件流，通过 ReactiveCocoa 使用信号被简洁的表达了出来。相当的漂亮！你能想象如果这个项目不使用响应式编程会有多复杂吗？在这样的应用中看这样的数据流是有多复杂吗？听起来就很复杂，但是现在你不用再像之前那样去做了！ 现在你知道 ReactiveCocoa 是多么的令人惊叹了吧！ 还有最后一点，ReactiveCocoa 让我们可以使用 Model、View、ViewModel，或者 MVVM 的设计模式。这样可以更好的分离出应用程序逻辑和视图逻辑。","categories":[],"tags":[{"name":"Reactive Cocoa","slug":"Reactive-Cocoa","permalink":"Aaronzjp.cn/tags/Reactive-Cocoa/"},{"name":"响应式编程","slug":"响应式编程","permalink":"Aaronzjp.cn/tags/响应式编程/"}]},{"title":"ReactiveCocoa 基础教程 2-1（译）","slug":"ReactiveCocoa-Tutorial-2-1","date":"2017-05-22T12:31:22.000Z","updated":"2018-11-24T09:35:52.594Z","comments":true,"path":"2017/05/22/ReactiveCocoa-Tutorial-2-1/","link":"","permalink":"Aaronzjp.cn/2017/05/22/ReactiveCocoa-Tutorial-2-1/","excerpt":"本文是翻译自国外网站的文章，其实这篇文章有很多的现成的翻译，但是看了过后感觉我自己很难理解别人的翻译方式，所以用自己的方式翻译了一遍，顺便也是加深一下印象。原文地址 作为一个iOS开发，几乎编写的每一行代码都是在处理事件的响应。比如按钮的点击，接收的网络消息，属性的改变(Key Value Observing)，或者用户改变了当前的位置，都是很好的例子。然而这些事件以不同的编码方式散布在各个地方，比如动作触发，代理(delegates)，KVO，回调或者其他的。ReactiveCocoa 则定义了一套完整的处理这些事件的标准接口，因此可以使用它很容易的处理事件链接，过滤，组合等。 听起来很困惑？很有趣？….吹牛逼？继续看下去。 ReactiveCocoa 结合了以下几种编程风格： 函数式编程，利用高阶函数，即其他函数作为函数的参数或返回值。 响应式编程，着重于数据流以及数据变化和传值。 通过这些原因，你应该知道 ReactiveCocoa 被称作为响应式函数编程框架。","text":"本文是翻译自国外网站的文章，其实这篇文章有很多的现成的翻译，但是看了过后感觉我自己很难理解别人的翻译方式，所以用自己的方式翻译了一遍，顺便也是加深一下印象。原文地址 作为一个iOS开发，几乎编写的每一行代码都是在处理事件的响应。比如按钮的点击，接收的网络消息，属性的改变(Key Value Observing)，或者用户改变了当前的位置，都是很好的例子。然而这些事件以不同的编码方式散布在各个地方，比如动作触发，代理(delegates)，KVO，回调或者其他的。ReactiveCocoa 则定义了一套完整的处理这些事件的标准接口，因此可以使用它很容易的处理事件链接，过滤，组合等。 听起来很困惑？很有趣？….吹牛逼？继续看下去。 ReactiveCocoa 结合了以下几种编程风格： 函数式编程，利用高阶函数，即其他函数作为函数的参数或返回值。 响应式编程，着重于数据流以及数据变化和传值。 通过这些原因，你应该知道 ReactiveCocoa 被称作为响应式函数编程框架。 读到这里你可能很迷惑，但是请放心，解惑是本教程的目的。虽然编程范例也是一个很吸引人的话题，但是下面的教程主要关注实用价值。将通过一个实例对 ReactiveCocoa 进行讲解。 响应式编程游乐场在这个 ReactiveCocoa 教程，你将通过一个简单的示例应用程序来了解响应式编程。下载开始项目。然后进行编译运行，确保所有的设置都正确。 响应式编程游乐场 是一个非常简单的示例程序。在当前页面会显示一个用户登录的界面，当成功登录后就会出现一个非常可爱的猫咪图片的界面。 哇～～！真的很可爱。😄 现在花一点时间看一下开始项目的整个代码。这是一个很简单的项目，应该不会花费你太多的时间。 打开 RWViewController.m 文件，快速的看一下，找出登录按钮可以点击的条件？登录失败标签显示/隐藏的规则？在这个简单的项目中你可能只需要一两分钟就能回答上面的问题。但是对于一个更加复杂的项目你看到相同类型的代码可能就会花上更多的时间。 在使用 ReactiveCocoa 后应用中代码的意图和思路将会变得非常清晰。现在就开始吧！ 添加 ReactiveCocoa 框架开始项目中没有添加 ReactiveCocoa 的框架，需要自己去添加。这里就懒得写了，基本上就是使用 CocoaPod 添加 ReactiveCocoa 的框架到项目中。 开始吧就像一开始介绍的一样，ReactiveCocoa 中针对 App 中各种不同的事件流提供了一个标准的事件流处理接口。在 ReactiveCocoa 中这些事件流被称为信号，由一个 RACSignal 的类处理。 在这个初始化的项目中打开 RWViewController.m 文件，并且倒入 ReactiveCocoa 的头文件。 1#import &lt;ReactiveCocoa/ReactiveCocoa.h&gt; 先不要急着去修改项目中的代码，玩一下，了解下这个框架。在 viewDidLoad 方法下添加如下代码： 123[self.usernameTextField.rac_textSignal subscribeNext:^(NSString * _Nullable x) &#123; NSLog(@&quot;%@&quot;,x);&#125;]; 运行程序在 username 的输入框中输入文字，注意下控制台的输出打印： 12345678910111213142013-12-24 14:48:50.359 RWReactivePlayground[9193:a0b] i2013-12-24 14:48:50.436 RWReactivePlayground[9193:a0b] is2013-12-24 14:48:50.541 RWReactivePlayground[9193:a0b] is 2013-12-24 14:48:50.695 RWReactivePlayground[9193:a0b] is t2013-12-24 14:48:50.831 RWReactivePlayground[9193:a0b] is th2013-12-24 14:48:50.878 RWReactivePlayground[9193:a0b] is thi2013-12-24 14:48:50.901 RWReactivePlayground[9193:a0b] is this2013-12-24 14:48:51.009 RWReactivePlayground[9193:a0b] is this 2013-12-24 14:48:51.142 RWReactivePlayground[9193:a0b] is this m2013-12-24 14:48:51.236 RWReactivePlayground[9193:a0b] is this ma2013-12-24 14:48:51.335 RWReactivePlayground[9193:a0b] is this mag2013-12-24 14:48:51.439 RWReactivePlayground[9193:a0b] is this magi2013-12-24 14:48:51.535 RWReactivePlayground[9193:a0b] is this magic2013-12-24 14:48:51.774 RWReactivePlayground[9193:a0b] is this magic? 可以看到，每次输入框文字改变的时候代码中的 block 都会执行一次。没有通过 target-action，也没用通过代理，仅仅是使用信号和代码，就能完美的运行。 ReactiveCocoa 信号( RACsignal 类)发送事件流到它的这些订阅者。需要知道的是有三种类型的事件流：next，error 和 completed。信号可以在发送错误事件和完成事件之前发送若干个事件。在这部分的教程中会把重点放在事件(next)上。在第二部分中会主要讲解错误事件(error)和完成事件(completed)。 在 RACSignal 中有几个方法可以用来订阅不同类型的事件。每个方法都会带有一个或者多个 block 回调，当时间发生的时候就会执行你在 block 中的代码。在这个例子中 subscribeNext： 中的 block 在每次 next 事件触发的时候都会执行一次。 ReactiveCocoa 框架使用分类(category)的方式在 UIKit 的空间中添加了信号，可以通过这些信号直接订阅事件。在 UITextField 中文本信号就是 rac_textsignal 属性。 理论讲的已经差不多了，现在就开始来实际操作吧。 在 ReactiveCocoa 中有大量的方法可以用来控制各种事件流。比如，你只需要在 username 字符长度大于3的时候才做操作，可以通过 filter 方法来过滤 username 字符不足3的操作。把下面的代码加到 viewDidLoad 的方法中： 12345678[[self.usernameTextField.rac_textSignal filter:^BOOL(id value) &#123; NSString *text = value; return text.length &gt; 3;&#125;]subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;, x);&#125;]; 运行程序，在 username 输入框中输入文字，你会发现只会在字符长度大于3的时候才会执行 next 中 block 的回调代码。 12345678910112013-12-26 08:17:51.335 RWReactivePlayground[9654:a0b] is t2013-12-26 08:17:51.478 RWReactivePlayground[9654:a0b] is th2013-12-26 08:17:51.526 RWReactivePlayground[9654:a0b] is thi2013-12-26 08:17:51.548 RWReactivePlayground[9654:a0b] is this2013-12-26 08:17:51.676 RWReactivePlayground[9654:a0b] is this 2013-12-26 08:17:51.798 RWReactivePlayground[9654:a0b] is this m2013-12-26 08:17:51.926 RWReactivePlayground[9654:a0b] is this ma2013-12-26 08:17:51.987 RWReactivePlayground[9654:a0b] is this mag2013-12-26 08:17:52.141 RWReactivePlayground[9654:a0b] is this magi2013-12-26 08:17:52.229 RWReactivePlayground[9654:a0b] is this magic2013-12-26 08:17:52.486 RWReactivePlayground[9654:a0b] is this magic? 在这里其实就创建了一个简单的数据流管道，这就是响应式编程的本质，通过数据流来驱动事件。 数据流整个处理过程如下图： 从上面的图可以看出 rac_textSignal 是事件的源头。数据流进入到 filter 方法后，该方法只允许字符串长度大于3的数据继续通过事件流管道传递到下一步，最后事件流进入到 subscribeNext:方法，事件触发 block 回调执行。 值得注意的是 filter: 这个方法返回的也是一个 RACSignal 实例对象。可以通过以下代码来拆分事件流的几个步骤： 123456789101112RACSignal *usernameSourceSignal = self.usernameTextField.rac_textSignal;RACSignal *filteredUsername = [usernameSourceSignal filter:^BOOL(id value) &#123; NSString *text = value; return text.length &gt; 3; &#125;];[filteredUsername subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;, x);&#125;]; 因为对 RACSignal 实例对象对操作都会返回一个 RACSignal 的是你对象，这样的编程被称作流式接口( fluent interface )。这样的特性可以允许连续的构造一个事件流而不用通过本地变量去分割每一部分的操作。 简单转换如果刚刚你把麻袋分割成了多个 RACSignal 的操作，现在将代码回复成流式语法 12345678[[self.usernameTextField.rac_textSignal filter:^BOOL(id value) &#123; NSString *text = value; // implicit cast return text.length &gt; 3; &#125;] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;, x);&#125;]; 在上面的代码中 id 类型最终被转换成了 NSString 类型，这样看起来并不是很优雅，在这里幸运的是这里这个 block 的这个参数总是 NSString 类型，所以可以直接修改参数的类型： 1234567[[self.usernameTextField.rac_textSignal filter:^BOOL(NSString *text) &#123; return text.length &gt; 3; &#125;] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;, x);&#125;]; 编译运行，确保这次和之前运行结果是一样的。 什么是事件(Event)到目前为止只是介绍了几种不同类型的事件，但是都没有详细介绍事件的结构。有趣的是事件其实可以包含任何类型的值。 为了说明这一点，我们将在事件流中添加这些操作，把下面的代码添加到 viewDidLoad: 方法中。 12345678910[[[self.usernameTextField.rac_textSignal map:^id(NSString *text) &#123; return @(text.length); &#125;] filter:^BOOL(NSNumber *length) &#123; return [length integerValue] &gt; 3; &#125;]subscribeNext:^(id x) &#123;NSLog(@&quot;%@&quot;, x);&#125;]; 编译后并运行，在输入框中输入文本，此时控制台打印的就是文本内容的长度而不是文本内容了。 1234567892013-12-26 12:06:54.566 RWReactivePlayground[10079:a0b] 42013-12-26 12:06:54.725 RWReactivePlayground[10079:a0b] 52013-12-26 12:06:54.853 RWReactivePlayground[10079:a0b] 62013-12-26 12:06:55.061 RWReactivePlayground[10079:a0b] 72013-12-26 12:06:55.197 RWReactivePlayground[10079:a0b] 82013-12-26 12:06:55.300 RWReactivePlayground[10079:a0b] 92013-12-26 12:06:55.462 RWReactivePlayground[10079:a0b] 102013-12-26 12:06:55.558 RWReactivePlayground[10079:a0b] 112013-12-26 12:06:55.646 RWReactivePlayground[10079:a0b] 12 新添加的 map: 方法中的 block 对事件流中的数据进行了转换。对接收到的每一个事件都通过 block 回调进行处理，并作为返回值通过 next: 事件传递出去。在上面的代码中，将 NSString 类型的数据转换成了数据字符串的长度以 NSNumber 的类型返回。 可以通过下面的这个图理解下是如何运作的 就像你看到的一样，在 map 操作之后所有的环节接收到的数据都被转换成了 NSNumber 对象，你可以使用 map 把接收到的数据转换成你想要的任意类型，但是必须是一个对象。 注意：在上面的例子中使用 text.length 属性获取到的其实是一个 NSUInteger 类型数据，这是一个基本数据类型，为了能作为事件流的内容发送出去，数据就必须是一个对象。这里是通过 Objective-C 的装箱语法将其转换成 NSNumber 类型的。 有了时间结束，现在对 ReactiveCocoa 框架也有了一些了解，但是需要学习的东西还有很多，你可以把刚刚在项目中修改的代码全部清除掉，下面正式开始使用 ReactiveCocoa 对这个示例项目进行更新了。 创建验证信号首先需要创建一对信号，用来验证 username 和 password 的输入是否有效。将下面的代码添加到 RWViewController.m 文件的 viewDidLoad: 方法中。 1234567891011RACSignal *validUsernameSignal = [self.usernameTextField.rac_textSignal map:^id(NSString *text) &#123; return @([self isValidUsername:text]); &#125;];RACSignal *validPasswordSignal = [self.passwordTextField.rac_textSignal map:^id(NSString *text) &#123; return @([self isValidPassword:text]); &#125;]; 从上面的代码中可以看到通过使用 map 操作对事件流中的数据进行了转换，最终输出被转换成了封装成为 NSNumber 类型的 BOOL值。 接下来继续转换事件流中的数据，用来判断文本输入框使用什么样的背景色。基本上可以直接订阅该信号，然后使用结果来更新文本输入框的背景色，这是一个可选的方案： 1234567[[validPasswordSignal map:^id(NSNumber *passwordValid) &#123; return [passwordValid boolValue] ? [UIColor clearColor] : [UIColor yellowColor]; &#125;] subscribeNext:^(UIColor *color) &#123; self.passwordTextField.backgroundColor = color; &#125;]; (不要急着在项目中加上这段代码，后面会有更加优雅的方式来实现！) 概念上来说直接将这个信号的数据输出用作与文本输入框的背景色属性是没有问题的 ，然而这样的实现其实是很糟糕的。 幸运的是 ReactiveCocoa 提供了一个很实用的宏，可以优雅的来实现这一点，把下面的这段代码添加到 viewDidLoad: 方法中： 1234567891011RAC(self.passwordTextField, backgroundColor) = [validPasswordSignal map:^id(NSNumber *passwordValid) &#123; return [passwordValid boolValue] ? [UIColor clearColor] : [UIColor yellowColor]; &#125;];RAC(self.usernameTextField, backgroundColor) = [validUsernameSignal map:^id(NSNumber *passwordValid) &#123; return [passwordValid boolValue] ? [UIColor clearColor] : [UIColor yellowColor]; &#125;]; RAC 宏允许将事件的输出数据作为对象属性的值，需要传入两个参数，第一个是需要被改变属性值的对象，第二个是属性名称。每当信号发出新的事件的时候，事件流中的数据都会被设置为被绑定属性的值。 这是非常优雅的实现方式，你觉得呢？ 在编译运行前需要做最后一步，找到 updateUIState 方法中包含的以下代码从项目中移除。 12self.usernameTextField.backgroundColor = self.usernameIsValid ? [UIColor clearColor] : [UIColor yellowColor];self.passwordTextField.backgroundColor = self.passwordIsValid ? [UIColor clearColor] : [UIColor yellowColor]; 去掉原来非响应式编程的代码。 编译运行代码，你会看到当输入有效的时候文本输入框是没有背景色的，当输入无效的时候则是有背景色的。 用图形解释更加有效，所以用下面的图形来说明一下当前的逻辑。在下图你可以看到两个获取文本信号的管道，先把他们映射为检验有效性的布尔值，然后再映射为与文本输入框的底色属性绑定的UIColor。 你是否对单独创建validPasswordSignal和validUsernameSignal信号感到很疑惑？为什么不直接为文本输入框创建一个连续流畅的管道呢？亲爱的读者耐心点，这疯狂举动背后的真正目的将立马揭晓！ 信号合并在当前的 App 中，登录按钮只有在用户名和密码都输入有效的时候才能点击，时候采用这样的响应式风格了。 在当前的代码中已经有了判断用户名和密码输入是否有效的信号了，validUsernameSignal and validPasswordSignal。现在需要做的就是合并这两个信号以确定什么时候登录按钮是可点击的。 在 viewDidLoad: 的方法下加入如下的代码： 123RACSignal *signUpActiveSignal = [RACSignal combineLatest:@[validUsernameSignal, validPasswordSignal]reduce:^id(NSNumber *usernameValid, NSNumber *passwordValid) &#123; return @([usernameValid boolValue] &amp;&amp; [passwordValid boolValue]);&#125;]; 在上面的代码中使用 combineLatest:reduce: 方法将 validUsernameSignal 和 validPasswordSignal 两个信号合并成为了一个信号。每当这两个信号中任意一个信号收到事件的时候 reduce 中的 block 就会执行一次，block 中返回的数据就会作为合并信号的下一个数据流发送出去。 注意：RACSignal 的信号合并方法可以合并人意数量的信号，reduce 中 block 的参数分别对应每个相应的信号源。ReactiveCocoa 中有一个巧妙的工具类 RACBlockTrampoline ，用来在内部处理 reduce block 中可变参数列表。实际上 ReactuveCocoa 中还有很多类似这样的巧妙的设计，所以还有很多值得学习的。 现在就有了一个很合适的信号，用来处理登录按钮是否可点击的状态。把如下的代码添加到 viewDidLoad: 方法中： 123[signUpActiveSignal subscribeNext:^(NSNumber *signupActive) &#123; self.signInButton.enabled = [signupActive boolValue]; &#125;]; 在编译运行代码之前。是时候把之前的代码去掉了，将下面这两个属性从文件顶部删除： 12@property (nonatomic) BOOL passwordIsValid;@property (nonatomic) BOOL usernameIsValid; 再把去掉 viewDidLoad: 方法最上面的这两段代码： 1234567// handle text changes for both text fields[self.usernameTextField addTarget:self action:@selector(usernameTextFieldChanged) forControlEvents:UIControlEventEditingChanged];[self.passwordTextField addTarget:self action:@selector(passwordTextFieldChanged) forControlEvents:UIControlEventEditingChanged]; 同时去掉 pdateUIState, usernameTextFieldChanged 和 passwordTextFieldChanged 方法。哇，在刚刚删除了一大堆非响应式编程的代码，这样清晰多了。你会感谢你这样做的。 最后，也要去除 viewDidLoad: 方法中的 updateUIState 方法的调用。 如果成功运行后，检查一下，在用户名和密码输入有效的情况下登录按钮一定是可以点击的。就像以前一样。 下面是整个项目中的逻辑顺序图： 在上面的插图中体现了两个非常重要的概念，这两个概念可以帮助你使用 ReactiveCocoa 完成更多功能强大的任务。 拆分 信号可以用多个订阅者，同时也可以作为后续多个信号管道中的后续环节的来源。在上面的示意图中用来验证密码和用户名的信号就被单独拆分成为了两个，并用于两个不同的地方。 合并 多个信号可以组合为全新的信号。在这个例子中，两个布尔值信号被组合到了一起。但不局限于此，实际上你可以组合任意值类型的信号。 这些改动让应用不再需要保留用以记录两个文本输入框是否有效的私有属性。这是你选用响应式编程的其中一个关键区别——你不再需要使用实例变量去记录这些瞬时状态。 响应式登录在当前的项目中用来管理输入框和按钮的状态都是用了信号管道的方式，但是登录按钮的点击事件还是使用的 action 机制去处理的。所以接下来就要去替换项目中登录按钮点击事件的代码。 登录按钮的 Touch Up Inside 事件中的 signInButtonTouched 方法在 RWViewController.m 中是与 Storyboard 绑定的，所以现在第一步就是去 Storyboard 中断开事件与代码的连接。 打开Main.storyboard，按着ctrl同时点击登录按钮，唤起outlet / action关联视图并点击x删除关联。如果找不到在怎么地方，那么下图已经为你标记出来了。 你已经见到了如何使用 ReactiveCocoa 框架在 UIKit 中使用信号来了。已经使用 rac_textSignal 用来处理了文本变化时信号的处理以及事件的响应。现在需要使用另外一个方法向 UIKit 中的控件添加信号管道，rac_signalForControlEvents。 回到 RWViewController.m 文件中，添加下面的代码到 viewDidLoad: 方法中： 12345[[self.signInButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) &#123; NSLog(@&quot;button clicked&quot;); &#125;]; 在上面的代码中为 UIButton 的 UIControlEventTouchUpInside 事件创建了信号，并且添加了订阅者，在事件发生的时候就打印一些日志。 编译并运行代码，确认是否会打印正确的日志消息，在这之前需要用户名和密码都要有效，因为登录按钮只会在用户名和密码都有效的时候才能够被点击。 你应该能看到在 Xcode 的控制台中会输出如下的日志： 123452013-12-28 08:05:10.816 RWReactivePlayground[18203:a0b] button clicked2013-12-28 08:05:11.675 RWReactivePlayground[18203:a0b] button clicked2013-12-28 08:05:12.605 RWReactivePlayground[18203:a0b] button clicked2013-12-28 08:05:12.766 RWReactivePlayground[18203:a0b] button clicked2013-12-28 08:05:12.917 RWReactivePlayground[18203:a0b] button clicked 现在按钮的点击事件已经有信号了，下一步就是它和登录过程绑定起来了。那么问题来了，但是你不用担心，这也是好事。打开 RWDummySignInService.h 文件，找到如下的接口： 123456789typedef void (^RWSignInResponse)(BOOL);@interface RWDummySignInService : NSObject- (void)signInWithUsername:(NSString *)username password:(NSString *)password complete:(RWSignInResponse)completeBlock;@end 这个接口有登录名，密码和完成回调 block 三个参数。这个 block 回调用于登录成功或者登录失败的处理。你可以用这个接口直接在 subscribeNext: 方法中处理登录按钮的点击事件。在这样的异步的基于事件的处理中对于 ReactiveCocoa 来说简直就是小菜一碟。 注意：在教程中为了简单起见使用了虚拟的网络接口，这样就不会对外部的接口有任何的依赖。但是这里遇到了一个很实际的问题就是如何使用信号来表示 API 的信号。 创建信号幸运的是现有的异步 API 很简单的就能调整为信号。首先在 RWViewController.m 文件中移除当前的 signInButtonTouched: 方法。已经不需要这部分代码了，因为会有使用响应式编程方式的代码替代它 在 RWViewController.m 文件中添加如下的方法: 123456789101112-(RACSignal *)signInSignal &#123; return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [self.signInService signInWithUsername:self.usernameTextField.text password:self.passwordTextField.text complete:^(BOOL success) &#123; [subscriber sendNext:@(success)]; [subscriber sendCompleted]; &#125;]; return nil; &#125;];&#125; 在上面的代码中使用用户名和密码创建了一个信号，现在就来分析下这个方法的组成部分。 在上面的代码中使用 RACSignal 类中的方法 createSignal: 创建了一个信号。代码中的 block 是这个信号中唯一的参数。当信号被订阅的时候，这个 block 中的代码就会立即执行。 在这个 block 中传入了一个信号的订阅者实例，它遵守 RACSubscriber 协议，实例中包含了发送事件的方法。当然也可以发送任意数量的事件到信号管道中，也可以通过发送 error 事件或者 complete 事件来终止信号。在这个例子中 subscriber 实例发送了表示登录成功的 next 事件，接着发送了 complete 事件。 这个 block 返回的是一个 RACDisposable 对象，它允许您执行任何清理工作，当订阅被取消或丢弃时，可能需要进行清理工作。此信号没有任何清理要求，因此返回nil。 就像你所看到的一样，把一个异步API包装到信号中去是非常简单的！ 现在去使用一下这个新的信号。更新在上一部分你添加到 viewDidLoad 末端的代码如下： 12345678[[[self.signInButton rac_signalForControlEvents:UIControlEventTouchUpInside] map:^id(id x) &#123; return [self signInSignal]; &#125;] subscribeNext:^(id x) &#123; NSLog(@&quot;Sign in result: %@&quot;, x); &#125;]; 上面的代码使用之前使用过的 map 方法将按钮点击信号转换为登录信号。然后订阅者简单地打印了结果。 如果编译运行并点击登录事件，你就会在 Xcode 的控制台看到上面代码的运行结果……跟你想象中的大相径庭！ 122014-01-08 21:00:25.919 RWReactivePlayground[33818:a0b] Sign in result: &lt;RACDynamicSignal: 0xa068a00&gt; name: +createSignal: subscribeNext的 block 的确已经接收了一个信号，但是并不是登录信号的结果！ 是时候分析一下这个管道看看里面纠结发生了什么： 当按钮被点击的时候，rac_signalForControlEvents 信号会发出一个事件流( UIButton 作为事件的缘数据)，接下来在 map 这一步中创建并返回了一个登录信号，这就意味着在接下来的信号管道中接收到的还是一个 RACSignal 信号。这就是在 subscribeNext: 这一步中观察到的。 想上面这样的情况被称作信号中的信号，就是在信号的内部包含了另一个信号。想获得这个信号中的信号其实可以在 subscribeNext: 这一步的 block 中去订阅这个信号。然而这样的嵌套会显得很混乱！幸运的是这是很常见的情况，ReactiveCocoa 已经为这样的情况有所准备了。 信号中的信号要解决这个问题是相当简单的，像下面代码这样把 map 这一步骤替换成 flattenMap ： 12345678[[[self.signInButton rac_signalForControlEvents:UIControlEventTouchUpInside] flattenMap:^id(id x) &#123; return [self signInSignal]; &#125;] subscribeNext:^(id x) &#123; NSLog(@&quot;Sign in result: %@&quot;, x); &#125;]; 就是之前一样登录按钮的点击事件还是以一个信号发出，但是 flattenMap 会将内部信号的事件发送给了外部信号。 编译运行后注意控制台，应该就能看成登录是否成功的信号了。 122013-12-28 18:20:08.156 RWReactivePlayground[22993:a0b] Sign in result: 02013-12-28 18:25:50.927 RWReactivePlayground[22993:a0b] Sign in result: 1 简直激动！ 现在这个信号管道已经能够如你所想的运行了，最后一步就是在登录成功的信号中添加所需要的代码： 123456789101112[[[self.signInButton rac_signalForControlEvents:UIControlEventTouchUpInside] flattenMap:^id(id x) &#123; return [self signInSignal]; &#125;] subscribeNext:^(NSNumber *signedIn) &#123; BOOL success = [signedIn boolValue]; self.signInFailureText.hidden = success; if (success) &#123; [self performSegueWithIdentifier:@&quot;signInSuccess&quot; sender:self]; &#125; &#125;]; 通过 subscribeNext: 的 block 获取到了登录结构的信号，根据结果决定是否显示 signInFailureText 这个控件，成功且跳转到 segue 指定的页面。 编译运行一下，现在就能再一次看到猫咪了。喵！ 你注意到了在当前的 App 中有一个影响用户体验的问题了吗？当在登录进行验证的时候登录按钮应该是不可点击的，这样可以防止用户重复的登录多次。而且如果第一次登录失败后，当用户再次尝试登录的时候应该隐藏之前的错误提示。 但是怎么才能把这个逻辑加入到现有的事件流管道中呢？改变登录按钮是否可点击的状态，以及过滤或者其他的概念根本就这扯不上关系。其实这就是一种副作用，在执行事件流管道中的事件之气，去做一些其他的处理，但同时也不会改变事件流本身。 添加副作用替换当前登录按钮的事件流中的代码，如下： 1234567891011121314151617[[[[self.signInButton rac_signalForControlEvents:UIControlEventTouchUpInside] doNext:^(id x) &#123; self.signInButton.enabled = NO; self.signInFailureText.hidden = YES; &#125;] flattenMap:^id(id x) &#123; return [self signInSignal]; &#125;] subscribeNext:^(NSNumber *signedIn) &#123; self.signInButton.enabled = YES; BOOL success = [signedIn boolValue]; self.signInFailureText.hidden = success; if (success) &#123; [self performSegueWithIdentifier:@&quot;signInSuccess&quot; sender:self]; &#125; &#125;]; 就像你看到的一样，在事件流中加入了 doNext: 步骤，该步骤会在事件流管道中的事件到来之前执行。需要注意的是 doNext: 是没有返回值的，因为他只是添加额外的副作用操作，并不需要改变事件本身。 在 doNext: 的 block 中将登录按钮设置为不可点击，并隐藏登录失败的文本。当事件触发了 subscribeNext: 中的 block 时再根据事件结果决定是否显示登录失败提示。 下面是添加了副作用后的事件流管道流程图： 再次编译运行代码，现在登录按钮的状态就如预期的那样了。 现在这个项目就算完成了，项目中的代码已经完全使用响应式编程的方式重构了。 如果你还不是很明白，你可以下载已经完成的项目（包含了框架引用），你也可以从GitHub上获取代码，那里有对应教程中每一步操作的提交记录。 提示：在异步操作中禁用按钮也是很常见的情况。ReactiveCocoa 同样也有相应的解决方法。RACCommand 包含了这个概念，它可以激活一个信号用来处理按钮的状态的处理。你可以去使用这个类去试试。 总结希望本教程为您提供了一个良好的基础，可以帮助您在自己的项目中使用 ReactiveCocoa 。要习惯这些概念需要一些练习，但就像任何语言或程序一样，一旦你掌握了它的窍门，它就真的很简单了。在 ReactiveCocoa 中它的核心概念就是信号，这只不过是一连串的事件。还有什么比这更简单的呢? 在使用了 ReactiveCocoa 后，我发信一个很有趣的事，就是一个同样的问题有很多解决的方式。可以尝试用自己的想法去改造下这个程序。但是需要考虑的事，ReactiveCocoa 框架的主要目的是让代码变得更干净，更清晰，让我们更容易理解。就我来说如果能让语法变得更加流畅，逻辑清晰，整个事件流程被事件流信号很好的表达出来。 在本系列教程的第二部分中，您将了解更高级的主题，例如错误处理，以及如何管理在不同线程上执行的代码。","categories":[],"tags":[{"name":"Reactive Cocoa","slug":"Reactive-Cocoa","permalink":"Aaronzjp.cn/tags/Reactive-Cocoa/"},{"name":"响应式编程","slug":"响应式编程","permalink":"Aaronzjp.cn/tags/响应式编程/"}]},{"title":"Swift-枚举","slug":"Swift-Enum","date":"2017-04-20T07:01:27.000Z","updated":"2017-08-01T07:06:31.000Z","comments":true,"path":"2017/04/20/Swift-Enum/","link":"","permalink":"Aaronzjp.cn/2017/04/20/Swift-Enum/","excerpt":"在 Swift 中枚举是一等类型。 Swift 中枚举是一个很强大的类型，在 C 语言中枚举会为一组整型值分配相关联的名称。但是在 Swift 中不是必须的，如果给枚举成员赋值(在 Swift 中又叫原始值)，则该值的类型可以是字符、字符串、整型、或者是一个浮点数。除了这些以为 Swift 中的枚举还可以指定任意类型的关联值到枚举成员中，还可以添加计算属性，实例方法，还可以定义构造函数，还可以遵守协议。","text":"在 Swift 中枚举是一等类型。 Swift 中枚举是一个很强大的类型，在 C 语言中枚举会为一组整型值分配相关联的名称。但是在 Swift 中不是必须的，如果给枚举成员赋值(在 Swift 中又叫原始值)，则该值的类型可以是字符、字符串、整型、或者是一个浮点数。除了这些以为 Swift 中的枚举还可以指定任意类型的关联值到枚举成员中，还可以添加计算属性，实例方法，还可以定义构造函数，还可以遵守协议。 枚举的定义枚举的定义如下： 123456789enum SomeFood &#123; case water case milk case bread&#125;//多个成员也可以使用逗号隔开的方式定义enum SomeFood &#123; case water, milk, bread&#125; 枚举中定义的值是这个枚举的成员值(成员)，可以用 case 来添加成员，其中这与 C 和 Obj-c 不同的是这里的枚举值不回被隐藏的赋值为整型，因为 Swift 中枚举的成员值本身就是完备的值，这些成员值的类型是已经被定义好的枚举的类型。 枚举其实就像是定义了一个全新的类型，就像 Swift 中其他的类型一样。如果枚举类型可以根据上下文推导出来，那么赋值一个枚举值的时候可以省略枚举类型。 123var food = SomeFood.bread//在初次的food = .milk 使用 switch 匹配枚举值 123456789var food = SomeFood.milkswitch food &#123;case .water: print(\"this is water\")case .milk: print(\"this is milk\")case .bread: print(\"this is bread\")&#125; 关联值在 Swift 中，枚举成员还可以添加任意类型的枚举关联值，但是在同一个枚举类型变量中，只能同时存在一个枚举成员的关联值。如下： 123456enum HttpStatus &#123; case errorCode(Int) case errorMessage(String)&#125;var code = HttpStatus.errorCode(5) 这些枚举值的关联值还可以通过变量/常量进行值绑定的方式提出来单独使用： 123456switch code &#123;case .errorCode(let code): print(\"\\(code)\")case .errorMessage(let message): print(message)&#125; 原始值在 Swift 中枚举除了关联值以为，枚举还可以有原始值(默认值)，原始值的类型必须相同，枚举的原始值需要显示的声明类型。原始值可以是字符串，字符，或者任意整型值或浮点型值。每个原始值在枚举声明中必须是唯一的。如下为枚举设置原始值： 123456enum Season: String &#123; case spring = \"春天\" case summer = \"夏天\" case autumn = \"秋天\" case winter = \"冬天\"&#125; 声明隐式原始值： 12345enum Number: Int &#123; case one,two,three,four,five,six,seven,eight,nine,ten&#125;let one = Number(rawValue: 0) 原始值为 Int 类型时默认是从0开始的，但是一旦设置了一个枚举成员的原始值，后面的原始值则依次递增1。原始值为 String 类型时默认原始值是该枚举成员的名称。原始值是其他类型的时候则需要一个一个的设置其原始值。 123456enum Constants: Double &#123; case π = 3.14159 case e = 2.71828 case φ = 1.61803398874 case λ = 1.30357&#125; 使用枚举成员的 rawValue 属性可以访问枚举成员的原始值： 123456enum Number: Int &#123; case one,two = 8,three,four,five,six,seven,eight,nine,ten&#125;let one = Number.eight.rawValue//输出 14 使用原始值初始化枚举成员，该方法会返回一个可选枚举成员，因为可能存在没有原始值对应的枚举成员： 12345enum Number: Int &#123; case one,two = 8,three,four,five,six,seven,eight,nine,ten&#125;let six = Number(rawValue: 6)//该值不回返回6，而是nil 递归枚举枚举递归可以让枚举包含枚举本身，如下嫁入文件夹和文件的关系就可以这样表示，因为文件夹中可以包含文件和文件夹： 12345678910enum FileNode &#123; case File(name: String) indirect case Folder(name: String, files: [FileNode])&#125;let fileName = FileNode.File(name: \"变形金刚\")let fileName2 = FileNode.File(name: \"西游记\")let fileName3 = FileNode.Folder(name: \"动作电影\", files: [FileNode.Folder(name: \"日本的\", files: [FileNode.File(name: \"MIAE-044 女子校生拷問フェラくらぶマニアックスvol.1\")])])let fileFolder = FileNode.Folder(name: \"电影\", files: [fileName,fileName2,fileName3]) 更多高阶用法参考Swift中枚举的高级用法与实践","categories":[],"tags":[{"name":"Swift","slug":"Swift","permalink":"Aaronzjp.cn/tags/Swift/"}]},{"title":"自定义转场动画（ViewController Transition）","slug":"TransitionAnimation","date":"2017-04-19T09:28:41.000Z","updated":"2018-11-24T09:36:41.298Z","comments":true,"path":"2017/04/19/TransitionAnimation/","link":"","permalink":"Aaronzjp.cn/2017/04/19/TransitionAnimation/","excerpt":"什么是转场动画，转场动画就是从一个 Controller 跳转到另一个 Controller 时呈现的动画。在现在的iOS App 中很多 App 都实现了自己的转场动画，要知道自定义转场动画在 iOS7 以前是没有这么轻松的，在 iOS7 以前要想自定义转场动画那就只能自己去一步一步的实现，很久以前我隐约记得我看过一篇文章是关于自定义控制器容易器转场动画的，大概意思就是自定","text":"什么是转场动画，转场动画就是从一个 Controller 跳转到另一个 Controller 时呈现的动画。在现在的iOS App 中很多 App 都实现了自己的转场动画，要知道自定义转场动画在 iOS7 以前是没有这么轻松的，在 iOS7 以前要想自定义转场动画那就只能自己去一步一步的实现，很久以前我隐约记得我看过一篇文章是关于自定义控制器容易器转场动画的，大概意思就是自定 义一个 ContainerViewController 将要转场的两个控制器放入到 ContainerViewController ，然后使用 UIView 的+ (void)transitionFromView:(UIView *)fromView toView:(UIView *)toView duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options completion:(void (^)(BOOL finished))completion; 方法，在该方法中去完成转场到操作，具体怎么做我也懒的去研究了，这里还是继续看一下 iOS7 提供的转场动画的 API 的使用。在 iOS7 之后苹果公开了一些接口可以让我们很轻松的来自定义转场动画。 自定义转场动画自定义转场动画总共的大概分为以下步骤： 提供一个遵守 &lt;UIViewControllerAnimatedTransitioning&gt; 协议的动画控制器（Animation Controller）。在动画控制器中我们需要完成转场时间以及转场动画的提供。 提供一个遵守 &lt;UIviewControllerInteractiveTransitioning&gt; 协议的交互控制器（Interaction Controller），该控制器其实不需要自己去实现，因为苹果已经提供了一个封装好了的交互控制器 UIPercentDrivenInteractiveTransition 。 自定义转场动画的控制器提供转场代理（Transition Delegate），遵守代理的规则。 转场代理目前来说有三种，分别对应了三种不同类型的转场情况，分别如下： 123&lt;UINavigationControllerDelegate&gt; //UINavigationController 的 delegate 属性遵守该协议。&lt;UIViewControllerTransitioningDelegate&gt; //UIViewController 的 transitioningDelegate 属性遵守该协议。&lt;UITabBarControllerDelegate&gt; //UITabBarController 的 delegate 属性遵守该协议。 在转场动画发生的时候这三个协议中都分别有不同的方法要求我们提供一个动画控制器和一个交互控制器，这都是可选的。 除了上面说的这些以外还有两个会用到的那就是转场环境（Transition Context）和转场协调器（Transition Coordinator），其中转场环境是必须的，转场环境遵守 &lt;UIViewControllerContextTransitioning&gt; 协议，不过这是系统提供给我们的，方便我们在转场时，获取转场中需要的数据。转场协调器目前我还没有具体的使用过，转场协调器遵守 &lt;UIViewControllerTransitionCoordinator&gt; 协议，可以通过控制器的 transitionCoordinator 属性获取转场协调器，不过它只在转场的过程中才会存在，如果处于非转场状态下该属性会返回 nil。 开始DemoPush／Pop 转场废话也不多说了，直接开始上代码。首先写一个 NavigationController 的 Push 和 Pop 的转场动画。 首先用 StoryBoard 快速的拖出两个控制器来。在我的 Demo 中根视图是一个 UITableViewController ，被 Push 的控制器是一个普通的 Controller。如图： 目前这个 Demo 就可以 Run 起来了，只不过动画是系统默认的，致于 Demo 中具体放什么东西就不说了，Demo 而已你想放啥就放啥。接下来我们开始自定义转场动画中需要的动画，就是动画控制器。 新建一个 PushAnimation 的类并遵守 &lt;UIViewControllerAnimatedTransitioning&gt; 协议如下： 1234567// PushAnimation.h#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;@interface PushAnimation : NSObject &lt;UIViewControllerAnimatedTransitioning&gt;@end 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// PushAnimation.m#import &quot;PushAnimation.h&quot;#import &quot;RootTableViewController.h&quot;#import &quot;RootDetailViewController.h&quot;#import &quot;RootTableViewCell.h&quot;@implementation PushAnimation- (NSTimeInterval)transitionDuration:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123; return 0.5;&#125;- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123; //通过转场环境获取 fromVC 和 toVC。 RootTableViewController *fromVC = (RootTableViewController *)[transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey]; RootDetailViewController *toVC = (RootDetailViewController *)[transitionContext viewControllerForKey:UITransitionContextToViewControllerKey]; //获取 fromVC 中被选中的 Cell RootTableViewCell *cell = [fromVC.tableView cellForRowAtIndexPath:fromVC.currentIndexPath]; //通过转场环境获取 容器视图 UIView *containerView = [transitionContext containerView]; //获取 Cell 中 headerView 的截图 UIView *cellImageView = [cell.headerView snapshotViewAfterScreenUpdates:NO]; //将获取到的 cell 的 headerView 的截图的 frame 转换成当前容器视图的位置 cellImageView.frame = [cell.headerView convertRect:cell.headerView.bounds toView:containerView]; //设置转场前初始的状态 toVC.view.alpha = 0; cell.headerView.hidden = YES; toVC.headerImageView.hidden = YES; //把需要参与到转场动画中的视图添加到容器视图中 [containerView addSubview:toVC.view]; [containerView addSubview:cellImageView]; //转场动画开始 [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^&#123; //需要更新布局 否则在横屏状态下 cellImageView 位置不正确 [containerView layoutIfNeeded]; cellImageView.frame = [toVC.headerImageView convertRect:toVC.headerImageView.bounds toView:containerView]; toVC.view.alpha = 1; &#125; completion:^(BOOL finished) &#123; [cellImageView removeFromSuperview]; toVC.headerImageView.hidden = NO; cell.headerView.hidden = NO; //动画结束后必须要向 Context 调用该方法通知动画结束，这里可以直接返回YES，如果动画有手势参与到话最好不要直接返回YES [transitionContext completeTransition:YES]; &#125;]; &#125;@end &lt;UIViewControllerAnimatedTransitioning&gt; 协议主要有两个方法： - (NSTimeInterval)transitionDuration:(nullable id &lt;UIViewControllerContextTransitioning&gt;)transitionContext; 该方法返回一个 NSTimeInterval ，即转场动画的时间长度，确定转场动画所需要的时间。在该方法中系统还提供了一个上文中提到的转场环境。 - (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext; 该方法没有返回值，同时也为我们提供了转场环境，转场的动画就需要在这个方法里面来完成。这里得说下 fromVc 和 toVC ，这两个是一个相对的概念，就是说当前正在显示的 Controller 就是 fromVC ，将要转场过去的 Controller 就是 toVC。 上面讲到的自定义转场动画的步骤到这已经完成了第一步，但是现在先跳过第二部，暂时不添加交互控制器到我们的转场动画中来，先完成转场动画后再添加。现在进入到第三步，遵守转场动画协议，为转场动画提供代理。 12345678// RootTableViewController.h#import &lt;UIKit/UIKit.h&gt;@interface RootTableViewController : UITableViewController//这个属性就是用来记录被选中的Cell的，在上面动画控制器中就通过这个属性来获取的Cell@property (nonatomic,strong) NSIndexPath *currentIndexPath;@end 1234567891011121314151617181920212223242526272829303132333435363738394041// RootTableViewController.m#import &quot;RootTableViewController.h&quot;#import &quot;PushAnimation.h&quot;@interface RootTableViewController () &lt;UINavigationControllerDelegate&gt;...@property (nonatomic,strong) PushAnimation *pushAnimation;...@end@implementation RootTableViewController- (void)viewDidLoad &#123; [super viewDidLoad]; ... ... self.pushAnimation = [PushAnimation new]; self.navigationController.delegate = self;&#125;#pragma mark - Table view data source......#pragma mark - Table view data delegate......#pragma mark - UINavigationControllerDelegate// 1.转场协议，返回一个 遵守 UIViewControllerAnimatedTransitioning 协议的类。（就是动画控制器）- (id&lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController animationControllerForOperation:(UINavigationControllerOperation)operation fromViewController:(UIViewController *)fromVC toViewController:(UIViewController *)toVC &#123; if (operation == UINavigationControllerOperationPush) &#123; return _pushAnimation; &#125; else &#123; return nil; &#125;&#125; 完成了上面的这些，现在这个 Demo 在 Push 的时候就已经是我们的自定义的转场动画了。测试一下，没问题。 Pop 动画呢这里就不详细说太多了，和 Push 是一样的，写个动画控制器，在转场协议的方法中（上面代码中标为1的那个方法）判断一下，返回一个 Pop 的动画控制器就可以了。 添加交互控制器上面已经讲了系统已经为我们封装好了一个交互控制器，我们继承这个类就可以了。代码如下： 12345678910// SwipInteractiveTransition.h#import &lt;UIKit/UIKit.h&gt;@interface SwipInteractiveTransition : UIPercentDrivenInteractiveTransition//该属性用来记录是否处于交互中，后面会用到这个属性@property (nonatomic,assign) BOOL interacting;//添加一个添加手势的方法- (void)addGestureInViewController:(UIViewController *)controller;@end 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// SwipInteractiveTransition.m#import &quot;SwipInteractiveTransition.h&quot;@interface SwipInteractiveTransition ()//该属性用来持有被添加手势的控制器，因为后面手势触发的时候要用改控制器Pop回去@property (nonatomic,strong) UIViewController *pushingViewController;@end@implementation SwipInteractiveTransition- (void)addGestureInViewController:(UIViewController *)controller &#123; self.pushingViewController = controller; [self prepareGesture];&#125;- (void)prepareGesture &#123; UIScreenEdgePanGestureRecognizer *gesture = [[UIScreenEdgePanGestureRecognizer alloc]initWithTarget:self action:@selector(handleGesture:)]; //设置手势方向 gesture.edges = UIRectEdgeLeft; //添加手势到控制器的View [self.pushingViewController.view addGestureRecognizer:gesture];&#125;- (void)handleGesture:(UIPanGestureRecognizer *)gesture &#123; //获取手势在View中当前的位置 CGPoint traslation = [gesture translationInView:self.pushingViewController.view]; //计算进度，这里按照当前控制器的宽来计算。 CGFloat progress = traslation.x / CGRectGetWidth(self.pushingViewController.view.bounds); //手势开始 if (gesture.state == UIGestureRecognizerStateBegan) &#123; //设置该属性，标记转场正在进行 self.interacting = YES; //Pop当前控制器 [self.pushingViewController.navigationController popViewControllerAnimated:YES]; //手势状态变化 &#125; else if (gesture.state == UIGestureRecognizerStateChanged) &#123; //更新手势控制器进度 [self updateInteractiveTransition:progress]; //手势结束或者取消的时候 &#125; else if (gesture.state == UIGestureRecognizerStateEnded || gesture.state == UIGestureRecognizerStateCancelled) &#123; //标记转场结束 self.interacting = NO; //如果进去大于50%就完成转场，否则取消转场 if (progress &gt; 0.5) &#123; [self finishInteractiveTransition]; &#125; else &#123; [self cancelInteractiveTransition]; &#125; &#125; else &#123; //对其他情况的处理 self.interacting = NO; [self cancelInteractiveTransition]; &#125;&#125;@end 做到这一步的时候手势控制器也完成了，那么如何把手势控制器添加到 Controller 并生效使用手势来进行转场？继续往下看。😄 这里回到 RootDetailViewController 这个类，遵守 &lt;UINavigationControllerDelegate&gt; 代理，实现该代理中的另一个方法即可。其实这里添加在那个控制器都可以的，但是这里还是添加到 RootDetailViewController 吧。 12345678910111213141516171819202122232425262728293031323334353637383940414243// RootDetailViewController.m#import &quot;RootDetailViewController.h&quot;#import &quot;PopAnimation.h&quot;#import &quot;SwipInteractiveTransition.h&quot;#import &quot;PushAnimation.h&quot;@interface RootDetailViewController () &lt;UINavigationControllerDelegate&gt;@property (nonatomic,strong) UIPercentDrivenInteractiveTransition *interactiveControler;@property (nonatomic,strong) SwipInteractiveTransition *swipInteractiveController;@property (nonatomic,strong) PopAnimation *popAnimation;@property (nonatomic,strong) PushAnimation *pushAnimation;@end@implementation RootDetailViewController- (void)viewDidLoad &#123; [super viewDidLoad]; _headerImageView.image = _image; _textView.text = _text; self.popAnimation = [PopAnimation new]; self.pushAnimation = [PushAnimation new]; self.swipInteractiveController = [SwipInteractiveTransition new]; [self.swipInteractiveController addGestureInViewController:self]; self.navigationController.delegate = self;&#125;- (id&lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController animationControllerForOperation:(UINavigationControllerOperation)operation fromViewController:(UIViewController *)fromVC toViewController:(UIViewController *)toVC &#123; if (operation == UINavigationControllerOperationPop) &#123; return _popAnimation; &#125; else if (operation == UINavigationControllerOperationPush) &#123; return _pushAnimation; &#125; return nil;&#125;//在该方法中返回手势控制器即可- (id&lt;UIViewControllerInteractiveTransitioning&gt;)navigationController:(UINavigationController *)navigationController interactionControllerForAnimationController:(id&lt;UIViewControllerAnimatedTransitioning&gt;)animationController &#123; return self.swipInteractiveController.interacting ? self.swipInteractiveController : nil;&#125;@end 完成后的效果如下： 这里可能手势取消后到动画有点问题（如果谁知道原因可以告诉我一下，谢谢😁），模拟器上动画表现的不是很好，后面我会把代码上传到Github，可以下载源码在真机上测试。 Modal转场普通的 Modal 转场就不详细的解释Demo，因为其实和 Push／Pop 转场是差不多的，只是转场代理不一样。 Modal 转场遵守 &lt;UIViewControllerTransitioningDelegate&gt; 协议，协议中的方法如下： 1234567891011//提供 Present 时的动画控制器- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source;//提供 Dismiss 时的动画控制器- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed;//提供 Present 时的交互控制器- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForPresentation:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator;//提供 Dismiss 时的交互控制器- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForDismissal:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator;//该方法是在 iOS8 之后提供的，其作用就是现在要讲的。- (nullable UIPresentationController *)presentationControllerForPresentedViewController:(UIViewController *)presented presentingViewController:(nullable UIViewController *)presenting sourceViewController:(UIViewController *)source; 在 Modal 转场中除了平时默认的动画外其实系统也默认的提供了其他四种的转场动画，设置控制器的 modalTransitionStyle 属性就可以很方便的使用这四种默认的转场动画，分别如下： 1234UIModalTransitionStyleCoverVerticalUIModalTransitionStyleFlipHorizontal UIModalTransitionStyleCrossDissolveUIModalTransitionStylePartialCurl 但是很多时候还是并不能满足对转场动画的需求，所以这里就需要自定义转场动画了。 自定义转场动画需要在 ViewController 的 modalPresentationStyle 分别为 UIModalPresentationCustom 和 UIModalPresentationFullScreen 的时候才可以自定义转场动画，同时 ViewController 指定的 modalTransitionStyle 转场动画将会被忽略。 UIModalPresentationCustom 和 UIModalPresentationFullScreen 之间也是有差别的，这点需要特别的注意，不然很有可能在后面的自定义转场动画中踩坑。 UIModalPresentationFullScreen 模式：presentation 后，presentingView 被主动移出视图结构，在 dismissal 中 presentingView 是 toView 的角色，其将会重新加入 containerView 中。 UIModalPresentationCustom 模式：转场时 containerView 并不担任 presentingView 的父视图，后者由 UIKit 另行管理。在 presentation 后，fromView(presentingView) 未被移出视图结构，在 dismissal 中，注意不要像其他转场中那样将 toView(presentingView) 加入 containerView 中，否则本来可见的 presentingView 将会被移除出自身所处的视图结构消失不见。这点在 Custom 模式下要特别注意。 在 iOS8 之后 Modal 转场代理中新增了上面的第4个方法，可以提供一个 UIPresentationController ，这个类为模态视图的转场提供了更好的解决方案，可以更加深入的自定义 PresentedViewController ，比如 PresentedView 的尺寸大小，背景等，这个其实也可以在不需要转场动画的情况下单独使用。其中还有最重要的一个功能，那就是对屏幕布局的管理，这里就不展开学习了，后面单独去学习关于这个的使用。 现在我要自定义一个像 iOS 10 中 Music App中，播放界面弹出的效果（其实 Demo 中的效果并不是很像，只能说差不多吧😅）。如图： 首先还是先提供一个 Modal 转场的动画控制器吧，关于动画控制器上面也详细说过了，就是一个遵守 &lt;UIViewControllerAnimatedTransitioning&gt; 协议的对象，这里就直接贴上代码了： 12345678910111213141516// PresentAnimation.h#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;typedef NS_ENUM(NSInteger,AnimationType) &#123; AnimationTypeOfPresent = 0, AnimationTypeOfPop&#125;;@interface PresentAnimation : NSObject &lt;UIViewControllerAnimatedTransitioning&gt;+ (instancetype)animationUseAnimationType:(AnimationType)type;- (instancetype)initWithAnimationType:(AnimationType)type;@end 在这个控制器里，我直接把两个动画写到了一起，type 的不同去获取 present 或者 dismiss 对应的动画。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// PresentAnimation.m#import &quot;PresentAnimation.h&quot;#import &quot;PresentedViewController.h&quot;@interface PresentAnimation ()@property (nonatomic,assign) AnimationType type;@end@implementation PresentAnimation+ (instancetype)animationUseAnimationType:(AnimationType)type &#123; return [[self alloc]initWithAnimationType:type];&#125;- (instancetype)initWithAnimationType:(AnimationType)type &#123; self = [super init]; if (self) &#123; _type = type; &#125; return self;&#125;- (NSTimeInterval)transitionDuration:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123; return 0.5;&#125;- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123; switch (self.type) &#123; case AnimationTypeOfPresent: [self doPresentAnimation:transitionContext]; break; case AnimationTypeOfPop: [self doDisMissAnimation:transitionContext]; break; default: break; &#125;&#125;- (void)doPresentAnimation:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123; UIViewController *toVC = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey]; toVC.view.transform = CGAffineTransformScale(CGAffineTransformIdentity, 0.01, 0.01); UIView *containerView = [transitionContext containerView]; [containerView addSubview:toVC.view]; [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^&#123; toVC.view.transform = CGAffineTransformIdentity; &#125; completion:^(BOOL finished) &#123; [transitionContext completeTransition:YES]; &#125;];&#125;- (void)doDisMissAnimation:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123; UIViewController *fromVC = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey]; UIView *toView = [transitionContext viewForKey:UITransitionContextToViewKey]; UIView *containerView = [transitionContext containerView]; [containerView insertSubview:toView belowSubview:fromVC.view]; [containerView addSubview:fromVC.view]; [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^&#123; fromVC.view.transform = CGAffineTransformScale(CGAffineTransformIdentity, 0.01, 0.01); &#125; completion:^(BOOL finished) &#123; [transitionContext completeTransition:![transitionContext transitionWasCancelled]]; &#125;];&#125;@end 动画控制器完成后这里回到 presentingViewController ，在这个 presentingViewController 中遵守转场协议，提供转场需要的动画控制器。在 Demo 中还是在 RootTableViewController 这个控制器中进行的模态转场的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// RootTableViewController.m#import &quot;RootTableViewController.h&quot;@interface RootTableViewController () &lt;UIViewControllerTransitioningDelegate&gt;......@end@implementation RootTableViewController- (void)viewDidLoad &#123; [super viewDidLoad]; ... ... self.pushAnimation = [PushAnimation new]; self.navigationController.delegate = self;&#125;#pragma mark - Table view data source......#pragma mark - Table view data delegate...//这里我时在一个 TableViewController 中演示各种转场动画的，所以在这里进行 present 操作- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123; [tableView deselectRowAtIndexPath:indexPath animated:YES]; //通过 MainStoryboard 初始化控制器 UIStoryboard *board = [UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:nil]; HalfPresentedViewController *presentVC = [board instantiateViewControllerWithIdentifier:@&quot;customOfPresentattionVC&quot;]; //将 presented 的模态转场设置为自定义 presentVC.modalPresentationStyle = UIModalPresentationCustom; //添加 UIViewControllerTransitioningDelegate 协议的代理 presentVC.transitioningDelegate = self; [self presentViewController:presentVC animated:YES completion:nil];&#125;...#pragma mark - UIViewControllerTransitioningDelegate//返回 Present 时的动画控制器- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source &#123; return [PresentAnimation animationUseAnimationType:AnimationTypeOfPresent];&#125;//返回 Dismiss 时的动画控制器- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed &#123; return [PresentAnimation animationUseAnimationType:AnimationTypeOfPop];&#125; 完成这步后 run 一下 Demo ，嗯没问题。这其实就是自定义了 Model的转场动画了。但是这时候 presented 还是一个全屏的方式呈现出来的。不过下面就开始自定义 preseted 这个视图了，自定义 preseted 就需要遵守上面提到的 &lt;UIViewControllerTransitioningDelegate&gt; 代理中的最后一个方法，为其提供一个 PresentationController 。 接下来开始自定义 PresentationController 。 1234567// CustomPresentationController.h#import &lt;UIKit/UIKit.h&gt;@interface CustomPresentationController : UIPresentationController@end 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// CustomPresentationController.m// Test//// Created by Aaron Zhang on 12/04/2017.// Copyright © 2017 张近坪. All rights reserved.//#import &quot;CustomPresentationController.h&quot;@interface CustomPresentationController ()//该视图时作为上面图中那个黑色半透明的背景的@property (nonatomic,strong) UIView *backView;@end@implementation CustomPresentationController- (void)presentationTransitionWillBegin &#123; self.backView = [[UIView alloc]init]; self.backView.frame = self.containerView.bounds; self.backView.backgroundColor = [UIColor blackColor]; self.backView.alpha = 0.0; //获取当前转场的容器视图并添加要转场视图到容器 [self.containerView insertSubview:self.backView atIndex:0]; [self.containerView addSubview:self.presentedView]; //在转场中做动画这里就用到了上面提到的 转场协调器，如果不通过转场协调器来做动画，可能转场的时候动画不同步 id &lt;UIViewControllerTransitionCoordinator&gt; transitionCoordinator = self.presentingViewController.transitionCoordinator; [transitionCoordinator animateAlongsideTransition:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; _Nonnull context) &#123; _backView.alpha = 0.5; self.presentingViewController.view.transform = CGAffineTransformScale(self.presentingViewController.view.transform, 0.98, 0.98); &#125; completion:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; _Nonnull context) &#123; &#125;]; &#125;//在 present 失败的时候移除背景半透明视图- (void)presentationTransitionDidEnd:(BOOL)completed &#123; if (!completed) &#123; [_backView removeFromSuperview]; &#125;&#125;- (void)dismissalTransitionWillBegin &#123; id &lt;UIViewControllerTransitionCoordinator&gt; transitionCoordinator = self.presentingViewController.transitionCoordinator; [transitionCoordinator animateAlongsideTransition:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; _Nonnull context) &#123; _backView.alpha = 0.0; self.presentingViewController.view.transform = CGAffineTransformIdentity; &#125; completion:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; _Nonnull context) &#123; &#125;];&#125;////在 present 结束的时候移除背景半透明视图- (void)dismissalTransitionDidEnd:(BOOL)completed &#123; if (completed) &#123; [_backView removeFromSuperview]; &#125;&#125;//该方法返回 PresentedView 在容器中的frame ，就是在这里修改 presentedView 视图大小的。- (CGRect)frameOfPresentedViewInContainerView &#123; return CGRectMake(10, self.containerView.bounds.size.height / 2, self.containerView.bounds.size.width - 20, self.containerView.bounds.size.height / 2 - 10);&#125;//容器视图重新布局子视图，在我的这个Demo中必须做这一步的操作，否则上面方法返回的 presentedView 的 frame 不会生效，目前我也不是特别清楚原因。- (void)containerViewWillLayoutSubviews &#123; self.backView.frame = self.containerView.bounds; self.presentedView.frame = [self frameOfPresentedViewInContainerView];&#125;//返回 presentedView 视图。- (UIView *)presentedView &#123; UIView *presentedView = self.presentedViewController.view; presentedView.layer.cornerRadius = 8; return presentedView;&#125;@end PresentationController 就完成了，在这中主要重写了在 PresentationController 不同状态下的方法，来自定义 PresentationController 的呈现。接下来只需要回到刚刚的 presentedViewController 中，在这个类 RootTableViewController 中通过 &lt;UIViewControllerTransitioningDelegate&gt; 返回自定义的 PresentationViewController 就好了，如下： 123456789101112131415161718192021222324252627282930313233343536// RootTableViewController.m#import &quot;RootTableViewController.h&quot;@interface RootTableViewController () &lt;UIViewControllerTransitioningDelegate&gt;......@end@implementation RootTableViewController- (void)viewDidLoad &#123; [super viewDidLoad]; ... ... self.pushAnimation = [PushAnimation new]; self.navigationController.delegate = self;&#125;#pragma mark - Table view data source......#pragma mark - Table view data delegate......#pragma mark - UIViewControllerTransitioningDelegate......//提供自定义的 UIPresentationController- (UIPresentationController *)presentationControllerForPresentedViewController:(UIViewController *)presented presentingViewController:(UIViewController *)presenting sourceViewController:(UIViewController *)source &#123; CustomPresentationController *myPresentationController = [[CustomPresentationController alloc]initWithPresentedViewController:presented presentingViewController:presenting]; return myPresentationController;&#125; 完成后最终的效果如下： Demo 参考资料： View Controller Programming Guide for iOS Presentation Controllers, Adaptivity, and Custom Animator Objects","categories":[],"tags":[{"name":"转场动画","slug":"转场动画","permalink":"Aaronzjp.cn/tags/转场动画/"}]},{"title":"Swift-构造过程","slug":"Swift-Initializer","date":"2017-03-27T14:06:28.000Z","updated":"2017-07-31T19:35:42.000Z","comments":true,"path":"2017/03/27/Swift-Initializer/","link":"","permalink":"Aaronzjp.cn/2017/03/27/Swift-Initializer/","excerpt":"Swift 构造过程是在使用类、结构体或者枚举类型的实例之前所做的准备工作。在使用类型实例之前为了确保类型实例能够正确的实例化，需要在实例化过程中对存储属性等设置初始值，和一些必须执行和初始化的工作。","text":"Swift 构造过程是在使用类、结构体或者枚举类型的实例之前所做的准备工作。在使用类型实例之前为了确保类型实例能够正确的实例化，需要在实例化过程中对存储属性等设置初始值，和一些必须执行和初始化的工作。 构造器构造器是在创建一个类型的实例等时候被调用的方法，构造器的声明是以 init 关键字声明的。如下就是创建了 Person 类的构造器。 123456class Person &#123; var name: String init(name: String) &#123; self.name = name &#125;&#125; 在构造器方法中，将参数 name 的值设置为 name 属性的值，作为初始值。 默认属性值要知道在 Swift 中类和结构体在创建实例的时候，所有的存储属性都必须要有合适的初始值，存储属性的值不能是出于一个未赋值的未知状态，这样才能正确的使用类型的实例。除了像上面那样在构造器中位存储属性设置初始值外，可以在属性声明时为其设置默认值。如下，为 Person 类设置一个默认值。 123456class Person &#123; var name: String = \"Aaron\"&#125;let person = Person()print(person.name)//输出 Aaron 当然属性默认值也可以设置为可选类型。 自定义构造过程当然也可以自定义构造器的构造过程来确保类型在创建类型实例的时候可以被正确的初始化。 构造参数自定义构造器构造过程的时候可以在定义中提供构造参数，指定参数的名称，类型等。自定义构造器的语法和函数和方法类似。其实在上面的 Person 类中就使用了自定义的构造过程。如下: 123456class Person &#123; var name: String init(name: String) &#123; self.name = name &#125;&#125; 该构造器有一个 name 参数，该参数是 String 类型，在构造器内部，将构造器的参数 name 赋值给了 Person 类的 name 属性。 外部参数名称和内部参数名称构造器和方法、函数一样，参数也有外部参数名称和内部参数名称。但是和方法和函数不一样的是，如果在定义构造器的时候没有为其定义参数外部名称，那么构造器将会自动的为构造器生成跟内部参数名称一样的外部参数名称。 123456789class Person &#123; var name: String init(name: String) &#123; self.name = name &#125; init(nickName name: String) &#123; self.name = name &#125;&#125; 这里展示了两种构造器，第一个是没有明确添加外部参数名的构造器，第二个则是添加了 nickName 作为 name 参数的外部名称的构造器。这两种构造器方法都可以创建一个 Person 实例。 当然也可以不使用外部名称，使用下划线(_)来显示的说明忽略掉外部参数名称。 123456789101112class Person &#123; var name: String init(name: String) &#123; self.name = name &#125; init(_ name: String) &#123; self.name = name &#125;&#125;let person = Person(name: \"Aaron\")let person2 = Person(\"Aaron\") 可选属性如果一个类型在初始化实例的时候某个属性并不需要初始值怎么办呢？上面也说了属性不能处于未知状态。那么可以定义一个可选类型的属性，可选类型的属性如果在构造器中未赋值的时候将会自动初始化为 nil 。这样就可以表示这个属性初始化后是没有值的。 1234567class Person &#123; var name: String var age: Int? init(name: String) &#123; self.name = name &#125;&#125; 上面这段代码在创建一个 Person 实例后，Person 的 age 属性就是 nil 构造过程中常量属性的修改在构造过程中同样也可以对常量的属性进行赋值，但是一旦类型的实例被创建后该实例的常量属性就无法被修改。在类中常量属性只能在定义该类的构造器中修改常量属性，在子类的构造器中是无法对常量属性进行修改的。 默认构造器在 Swift 中如果结构体和类中所有的属性都有默认值，同时没有自定义的构造器的时候 Swift 则会提供一个默认的构造器，通过该构造器会创建一个所有属性都是默认值的实例。 123456class Person &#123; var name: String? var age: Int?&#125;let person = Person() 通过该构造器创建出来的 Person 类的实例其所有的属性都将是 nil 结构体的逐一成员构造器除了默认的构造器以外，在结构体中如果没有提供自定义的构造器，那么将会有一个自动根据结构体中的属性生成的一个构造器，该构造器的参数将是结构体中所有属性，参数名则是所有属性名。如下： 123456struct Point &#123; var x: Float var y: Float&#125;let point = Point(x: 100, y: 100) 值类型的构造器代理构造器可以通过调用其他构造器来完成实例的部分构造过程，这样的过程就是构造器代理，构造器代理可以减少多个构造器之间的重复。值类型和类类型的构造器代理规则是有区别的，值类型是不支持继承的，所以值类型的构造器代理职能使用自己的其他构造器，而类则是可以继承自其他类的。 在值类型中可以使用 self.init 在自定义的构造器中使用本类型中其他的的构造器，且只能够在构造器内部调用 self.init 。当为值类型自定义了构造器时，将无法使用默认构造器、逐一成员构造器。如果需要自定义构造器，默认构造器和逐一成员构造器都可以访问，则需要将自定义构造器写到扩展中。 123456789101112131415161718192021struct Size &#123; var width = 0.0, height = 0.0&#125;struct Point &#123; var x = 0.0, y = 0.0&#125;struct Rect &#123; var origin = Point() var size = Size() init() &#123;&#125; init(origin: Point, size: Size) &#123; self.origin = origin self.size = size &#125; init(center: Point, size: Size) &#123; let originX = center.x - (size.width / 2) let originY = center.y - (size.height / 2) self.init(origin: Point(x: originX, y: originY), size: size) &#125;&#125; 在该例子中 Rect 定义了三个构造器，其中第一个构造器是一个空函数，这和没有自定义构造器的时自动获得的默认构造器是一样的。第二个构造器有两个参数，构造器内部在构造过程中将这两个参数分别赋值给了 origin 和 size 属性。第三个构造器也是有两个参数，不同的是在构造器内部的构造过程中，将获取到的参数经过计算后，再调用第二个构造器将计算得到的 origin 和 size 赋值到对应的属性。像第三个构造器这样在构造器内部的构造过程中调用其他的构造器就是构造器代理。 类的继承和构造过程类是可以继承的，在类中所有的存储属性包括继承自父类的属性都必须在构造过程中设置初始值。在类类型中 Swift 为其提供了两种构造器，分别是指定构造器和便利构造器。 指定构造器和便利构造器指定构造器是类中最主要的构造器，一个指定的构造器初始化类中所有的属性，并根据父类链往上调用父类的构造器来实现父类的初始化。每一个类都必须有至少一个的指定构造器。便利构造器则是类中的辅助型的构造器，可以通过便利构造器调用类中的指定构造器，并为其参数提供默认值，也可以在便利构造器中创建一些特殊用途的实例。 指定构造器其实和构造器语法是一样的，使用 init 作为关键字可以加入参数。便利构造器需要在构造器 init 前加上 convenience 关键字。 类的构造器代理规则Swift 中有三条规则来限制构造器之间的代理调用： 指定构造器必须调用其直接父类的的指定构造器。 便利构造器必须调用同类中定义的其它构造器。 便利构造器必须最终导致一个指定构造器被调用。 指定构造器是向上代理，便利构造器是横向代理。 构造器的继承和重写Swift 中默认情况下子类是不会继承父类的构造器的。但是如果满足以下任意一个条件子类是可以继承父类的构造器的。 1.子类没有定义任何的指定构造器，这时候子类会自动的继承父类所有的指定构造器 2.如果子类提供了所有的父类指定的构造器的实现，不管是继承还是自己提供实现。子类都会自动继承父类所有的便利构造器。 可失败构造器在很多时候在构造器传入的参数可能并不能如预期的完成初始化，这样构造过程就会失败，在 swift 中可以使用可失败构造器来处理这样的情况。可失败构造器可以在类，结构体，或者是枚举中添加一个或多个可失败构造器。可失败构造器的语法为在 init 后添加一个问号：（init?） 如下： 123456789101112class Person &#123; var name: String? init?(name: String) &#123; if name.isEmpty &#123; return nil &#125; self.name = name &#125; var apartment: Apartment?&#125;let aaron = Person(name: \"Aaron\") 在上面这段代码中构造一个 Person 实例，当传入的参数为空字符串的时候则会返回 nil。 需要注意的是。可失败构造器的参数名和参数类型，不能与其它非可失败构造器的参数名，及其参数类型相同。 枚举类型的可失败构造器同样的在枚举中也可以使用可失败构造器，当实例化一个对象的时候，参数无法匹配任何的枚举值的时候则构造失败，返回 nil 1234567891011121314151617enum Food &#123; case Beef,Noodles,Fish init?(name: String) &#123; switch name &#123; case \"Beef\": self = .Beef case \"Noodles\": self = .Noodles case \"Fish\": self = .Fish default: return nil &#125; &#125;&#125;let myFavriteFood = Food(name: \"Fish\") 同样的如同上面情况的构造器一样，如果在枚举构造器中找不到与之匹配的参数则会返回nil。同时，枚举的可失败构造器也可以通过带有原始值的方式来完成，这样写更加的简短。 123enum Food &#123; case Beef = “Beef”,Noodles = “Noodles”,Fish = \"Fish\"&#125; 构造失败的传递和普通构造器一样可失败构造器也可以横向代理到同类型的其他构造器中，同时子类的可失败构造器也可以向上代理到父类的可失败构造器，同时可失败构造器也可以代理到其他非可失败构造器中。无论是向上代理还是横向代理，如果你代理到的其他可失败构造器触发构造失败，整个构造过程将立即终止，接下来的任何构造代码不会再被执行。 可失败构造器的重写和其他普通构造器一样，可失败构造器是可以在子类中重写父类的可失败构造器的，也可以用子类的非可失败构造器重写父类的可失败构造器，但是不能反过来用可失败构造器重写非可失败构造器。 可失败构造器init!通常来说我们通过在init关键字后添加问号的方式（init?）来定义一个可失败构造器，但你也可以通过在init后面添加惊叹号的方式来定义一个可失败构造器（init!），该可失败构造器将会构建一个对应类型的隐式解包可选类型的对象。 你可以在init?中代理到init!，反之亦然。你也可以用init?重写init!，反之亦然。你还可以用init代理到init!，不过，一旦init!构造失败，则会触发一个断言。 必要构造器必要构造器是通过在构造器前添加 requred 关键字表示所有该类的子类都应该必须实现该构造器。 12345class SomeClass &#123; required init() &#123; // 构造器的实现代码 &#125;&#125; 在子类重写父类的必要构造器时，必须在子类的构造器前也添加required修饰符，表明该构造器要求也应用于继承链后面的子类。在重写父类中必要的指定构造器时，不需要添加override修饰符： 12345class SomeSubclass: SomeClass &#123; required init() &#123; // 构造器的实现代码 &#125;&#125; 注意如果子类继承的构造器能满足必要构造器的要求，则无须在子类中显式提供必要构造器的实现。","categories":[],"tags":[{"name":"Swift","slug":"Swift","permalink":"Aaronzjp.cn/tags/Swift/"}]},{"title":"Swift-方法","slug":"Swift-Method","date":"2017-03-22T04:57:57.000Z","updated":"2017-07-27T02:53:02.000Z","comments":true,"path":"2017/03/22/Swift-Method/","link":"","permalink":"Aaronzjp.cn/2017/03/22/Swift-Method/","excerpt":"在 Swift 中方法分为两种，实例方法、类型方法。其中类型方法和 Obj-c 中的类方法相似的，类型方法是作用于类型本身的，实例方法则是作用于类型对应的实例。和 Obj-c 不同的是，在 Swift 中不仅可以给类定义方法，同时还可以给结构体和枚举定义方法。","text":"在 Swift 中方法分为两种，实例方法、类型方法。其中类型方法和 Obj-c 中的类方法相似的，类型方法是作用于类型本身的，实例方法则是作用于类型对应的实例。和 Obj-c 不同的是，在 Swift 中不仅可以给类定义方法，同时还可以给结构体和枚举定义方法。 实例方法实例方法是属于类、结构体或者枚举类型实例的方法。实例方法的语法和函数是一致的（其实就是函数吧，只是是和某个特定类型相关联的函数），实例方法是提供修改和访问实例属性的方法，实现和实例目的相关的功能。 123456789101112class Dog &#123; var name: String? func giveDog(name: String) &#123; self.name = name &#125; func changeDog(name: String) &#123; self.name = name &#125; func deleteDogName() &#123; self.name = nil &#125;&#125; Dog 类定义了三个实例方法，方法的调用和属性是一样的使用点语法: 1234567let dog = Dog()dog.giveDog(name: \"DouDou\")//dog 的名字是 DouDoudog.changeDog(name: \"SB\")//dog 的名字是 SBdog.deleteDogName()//dog 的名字是一个 nil 的可选值 方法和函数一样也可以指定参数外部名称和内部名称。 实例方法中修改值类型属性swift 中枚举和结构体属于值类型，默认情况下值类型的属性是不能在实例方法中就行修改的，如果需要在值类型中修改属性就需要使用可变方法。可变方法使用关键字 mutating 修饰，放在方法声明的最前面，在可变方法中还可以对 self 进行赋值，方法结束后被赋值的 self 的实例会被新的值所取代。在常量值类型实例中是不可以调用可变方法的，因为值类型的实例一旦声明成为常量那么他的属性也全部变为常量。 123456struct Point &#123; var x = 0.0, y = 0.0 mutating func moveTo(x:Double, y:Double) &#123; self = Point(x: x, y: y) &#125;&#125; 同样的也可以应用在枚举中 12345678910111213enum TriStateSwitch &#123; case Off, Low, High mutating func next() &#123; switch self &#123; case Off: self = Low case Low: self = High case High: self = Off &#125; &#125;&#125; 类型方法实例方法是被类型的特定实例调用，那么类型方法就是被类型调用的。在类中声明类型方法使用 class 关键字，放在 func 的前面，在结构体和枚举中声明类型方法使用 static 关键字，也是放在 func 前面。 1234567891011class Person &#123; var name: String? class func newPerson(name: String) -&gt; Person &#123; return Person(name: name) &#125; init(name: String) &#123; self.name = name &#125;&#125;let person = Person.newPerson(name: \"Aaron\") 在 Person 中声明了一个类方法，调用该类方法会返回一个 person 实例。在类型方法中可以直接访问类型属性或者调用类型方法，而不需要加上类型名称。","categories":[],"tags":[{"name":"Swift","slug":"Swift","permalink":"Aaronzjp.cn/tags/Swift/"}]},{"title":"iOS动画","slug":"Animation","date":"2017-03-07T06:44:31.000Z","updated":"2018-11-24T09:30:28.050Z","comments":true,"path":"2017/03/07/Animation/","link":"","permalink":"Aaronzjp.cn/2017/03/07/Animation/","excerpt":"​ 在iOS／MacOS中，基本上所有的动画都是由 Core Animation 这个框架来完成的。这个框架的主要功能就是渲染图形，以及动画的实现，使用 Core Animation 来实现图形渲染以及动画只需要配置一些简单的参数，告诉它动画应该什么时候开始，什么时候结束，以及状态等。 Core Animation 通过硬件加速自动的完成图形的绘制，渲染以及动画。","text":"​ 在iOS／MacOS中，基本上所有的动画都是由 Core Animation 这个框架来完成的。这个框架的主要功能就是渲染图形，以及动画的实现，使用 Core Animation 来实现图形渲染以及动画只需要配置一些简单的参数，告诉它动画应该什么时候开始，什么时候结束，以及状态等。 Core Animation 通过硬件加速自动的完成图形的绘制，渲染以及动画。 ​ 首先看一下 Core Animation 中主要的几个类的继承机构，如下图： 隐式动画之所以叫隐式动画我觉得应该是我们在处理隐式动画的时候不需要去处理动画相关的东西，不需要去设置动画的时间，动画的轨迹，而只需要改变一个属性就可以做出一个动画，这些动画其实都是由 Core Animation 来完成的。Core Animation 包含了一系列的属性动画的集合机制。隐式动画只作用于 RootLayer 以外的 Layer 。 事务隐式动画其实是通过事务来管理的，事务实际上是 Core Animation 用来包含管理属性动画的集合机制，任何通过事务去改变的动画属性都不会立刻的发生变化，而是当事务提交的时候才开始从原来的值过渡到一个新的值。事务是通过 CATransaction 类来管理的，该类和其他普通的类不一样，没有属性和实例方法，也没有 + alloc; ， - init; 等方法。而是通过 + begin; ， + commit; 来入栈和出栈。所有可以做动画的属性都可以添加到栈顶顶事务，然后提交事务。隐式动画中动画默认的时间为0.25秒，但是我们也可以通过 - setAnimationDuration; 来设置时间，或者通过 + animationDuration; 来获取当前的时间。图层作出的所有的改变都是事务的一部分，都是经由事务把图层的改变更新到图层的。事务又可以分为隐式事务和显式事务。 隐式事务当修改图层没有在显示的获取事务进行更改的时候都会自动的创建隐式事务，当线程中的 run-loop 执行下一次迭代的时候就会自动的收集事务并提交事务。 1layer.position = CGPointMake(0.0,1.0); 上面的这段代码会被事务收集并提交，生成动画效果。 显式事务显示事务就需要在修改 layer 前开始一个新的事务，然后在修改 layer 后提交事务。 1234567891011121314151617//开始一个新事务，如果不开启新的事务，直接在当前事务中做修改可能会造成一些副作用[CATransaction begin];// [CATransaction setDisableActions:YES];//设置事务时间[CATransaction setAnimationDuration:3.0];//设置完成事务[CATransaction setCompletionBlock:^&#123; CGAffineTransform transform = self.layer.affineTransform; transform = CGAffineTransformRotate(transform, M_PI_4); self.layer.affineTransform = transform;&#125;];CGFloat red = arc4random() / (CGFloat)INT_MAX;CGFloat green = arc4random() / (CGFloat)INT_MAX;CGFloat blue = arc4random() / (CGFloat)INT_MAX;self.layer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;//提交事务[CATransaction commit]; 这种设置动画的方式是不是觉得好像在那见过？对，在 UIView 中也有这样类似的动画的实现方式。在 UIView中设置一个动画如下： 12345678CGPoint piont = [[touches anyObject]locationInView:self.view];[UIView beginAnimations:nil context:nil];[UIView setAnimationDuration:2.0];self.layerView.backgroundColor = [UIColor orangeColor];self.layerView.center = piont;[UIView commitAnimations]; 实际上通过 UIView 这种方式实现的动画都是通过设置 CATransaction 来完成的，但是 UIView 相对于 CATransaction 来说要更加丰富一些，可以设置 delay、repeatCount等等。 在 iOS 4.0 点时苹果为 UIView 添加了基于 Block 添加点动画点方式： + (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion； 在 Block 动画方式中可以设置 completion 以在动画完成的时候做一些其他操作，这种方式在 CATransaction 中也有对应的方法 ：+ (void)setCompletionBlock:(nullable void (^)(void))block; 在 CATransaction 中使用动画完成块： 1234567891011121314151617//开始一个新事务[CATransaction begin];// [CATransaction setDisableActions:YES];//设置事务时间[CATransaction setAnimationDuration:3.0];//设置完成事务[CATransaction setCompletionBlock:^&#123; CGAffineTransform transform = self.layer.affineTransform; transform = CGAffineTransformRotate(transform, M_PI_4); self.layer.affineTransform = transform;&#125;];CGFloat red = arc4random() / (CGFloat)INT_MAX;CGFloat green = arc4random() / (CGFloat)INT_MAX;CGFloat blue = arc4random() / (CGFloat)INT_MAX;self.layer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;//提交事务[CATransaction commit]; 以上代码会在动画完成的时候旋转90度，在图层旋转的时候要比颜色渐变快很多，这是因为旋转是在事务提交后才被执行的，是使用默认的事务做的旋转，所以时间就变成了默认的0.25秒。 隐式动画的实现在最上面就讲到了隐式动画只作用于非 RootLayer 的图层，这是因为在 UIView 中苹果禁用了 RootLayer 的这个特性。为了搞清楚 UIView 是如何禁用 CALayer 的隐式动画的就需要了解隐式动画的实现。 隐式动画实现方式可以分为如下的几步： 当 CALayer 的属性改变的时候，就会调用 - actionForKey(NSSrting *):event; 方法传递属性的名称。 如果图层否有委托，并且是否实现 CALayerDelegate 协议指定的 - actionForLayer:forKey 方法。如果有，直接调用并返回结果。 如果没有委托，或者委托没有实现 -actionForLayer:forKey 方法，图层接着检查包含属性名称对应行为映射的 actions 字典。 如果 actions 字典没有包含对应的属性，那么图层接着在它的 style 字典接着搜索属性名。 最后，如果在 style 里面也找不到对应的行为，那么图层将会直接调用定义了每个属性的标准行为的 - defaultActionForKey: 方法。 所以当一轮搜索过后，要么 - actionForLayer:forkey; 返回 nil ，要么就是 CAAction 协议对应的对象，最后 CALayer 就会获取这个结果对之前和现在的值做动画。 那么 UIView 是如何禁用隐式动画的呢？ 每个 UIView 对其关联的 RootLayer 都是一个委托，并且实现了 - actionForLayer:forKey; 方法，当不再一个动画块的实现的时候，UIView 对所有的图层的动画行为都返回 nil ，但是在动画范围内的就返回一个非空的值。当然还有一种方式可以直接禁用隐式动画，就是在入栈的时候调用 - setDisableActions; 方法。 123[CATransaction begin];[CATransaction setDisableActions:YES];[CATrasnaction commit]; 呈现与模型前面也提到了，当更改一个图层的属性的时候，事务被提交，图层在屏幕上就会从之前的值过渡到更改的新值，而不是立即就会生效的。当图层的属性值更新后，并不会马上的在屏幕上显示出来，而是从之前的值慢慢过渡过来的，我们更改的图层属性的值其实是在过渡完成后将要显示在屏幕上的值。 在iOS中，屏幕每秒钟重绘60次。如果动画时长比60分之一秒要长，Core Animation就需要在设置一次新值和新值生效之间，对屏幕上的图层进行重新组织。这意味着 CALayer 除了“真实”值（就是你设置的值）之外，必须要知道当前显示在屏幕上的属性值的记录。每个图层属性的显示值都被存储在一个叫呈现图层的独立图层中，该图层可以通过 presentationLayer; 方法获取，这个呈现图层其实是模型图层的复制，呈现图层的值就是当前屏幕正在显示的值。除了呈现层，模型层以外其实还有一个渲染层，但是渲染层是私有的所以这里不做了解。 什么时候会用到呈现层？ 当我们需要实现一个基于定时器的动画的时候，需要知道在某个时间图层显示的位置时，或者在动画正在进行的时候也允许动画与用户交互的时候，这个时候呈现层就起了很大的作用，我们通过呈现层可以知道目前图层在屏幕上处于什么位置，以及当前屏幕上图层的状态。 如下Demo： 1234567891011121314151617181920- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; CGPoint point = [[touches anyObject] locationInView:self.view]; if ([self.layer.presentationLayer hitTest:point]) &#123; CGFloat red = arc4random() / (CGFloat)INT_MAX; CGFloat green = arc4random() / (CGFloat)INT_MAX; CGFloat blue = arc4random() / (CGFloat)INT_MAX; [CATransaction begin]; [CATransaction setAnimationDuration:1]; self.layer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1].CGColor; [CATransaction commit]; &#125;else&#123; [CATransaction begin]; [CATransaction setAnimationDuration:4]; self.layer.position = point; [CATransaction commit]; &#125;&#125; 显式动画​ 显示动画就是需要显示去设置动画时间动画轨迹，以及一些其他动画的特性。它能够对一些属性做指定的自定义动画，或者创建非线性动画，比如沿着任意一条曲线移动。 CAAnimation​ CAAnimation 作为动画的根类，是不可以直接使用的，应该使用他的子类。但是 CAAnimation中还是有一些经常使用到的一些属性，和方法，这里列举一下。 属性： delgate:为 CAAnimation 设置代理，默认的为ni，该代理下有两个代理回调方法。 removedOnCompletion:动画完成后是否移除动画效果，默认为 YES ，当动画结束的时候则会立即恢复到动画前的状态。如果想让动画在完成后保持动画执行完的状态，需要设置该属性为 NO ，同时还要设置 fillMode 为kCAFillModeForwards。 timingFuncation:速度控制，控制动画的节奏。该属性是一个 NSString 类型，可以接受如下几种常量： 12345678910//匀速kCAMediaTimingFunctionLinear//慢进快出kCAMediaTimingFunctionEaseIn//快进慢出kCAMediaTimingFunctionEaseOut//慢进慢出中间加速kCAMediaTimingFunctionEaseInEaseOut//默认形式kCAMediaTimingFunctionDefault 方法： + animation; 返回一个 CAAnimation 实例对象。 + defualtValueForKey:(NSString *)key; 根据属性 Key 返回相对应的值，用于当使用的键没有被设置值的时候，返回一个默认值。 - (BOOL)shouldArchiveValueForKey:(NSString *)key; 设置对应的键的属性是否可以被归档，默认为 YES 。 代理方法： - (void)animationDidStart:(CAAnimation *)theAnimation; 动画开始的回调。 - (void)animationDidStop:(CAAnimation *)theAnimation finished:(BOOL)flag; 动画停止时候回调，flag动画是否结束。 CAMediaTiming​ CAMediaTiming 作为一个协议类，CAAnimation 和 CALayer 都实现了该协议。该协议主要控制动画的时间，以及一些重复属性。该协议包含了一系列的属性，如下： beginTime：指动画开始前延迟的时间，这个开始时间是相对当前图层时间来说的，这个时间是从动画被添加那一刻开始的，默认为0。 timeOffset: 时间偏移量，这个属性有点不太好理解，首先把一个动画看成是一个循环，如果设置动画的时间为5s，timeOffset 默认为0的情况下没有任何的变化。如果把 timeOffset 设置为3，那么动画就会从第4秒的地方开始，执行到第3秒。 duration: 动画执行的时间，该属性还和 speed 属性有关系，如果一个 speed 为2， duration 为3的动画，那么这个动画的实际执行时间为 duration / speed ，speed 是可以叠加的，如果一个 layer 的 speed 为2，sublayer 的 speed 也为2， duration为3，那么这个 sublayer 的动画时间则为 3 / (2 * 2) 秒。 speed: 动画执行速度，和 duration 有一定的关系，具体的参见上一条 duration。 repeatCount: 动画重复次数 repeatDuration: 重复时间，这个重复时间是指让动画持续重复执行的时长 autoreverses: 动画翻转回放，默认为 NO ，如果设置为 YES ，那么动画结束时会以动画的方式回到初始状态。 fillMode: 填充模式，该属性时一个 NSString 的类型，可以接受如下四种常量： 12345678//动画结束后回到准备状态kCAFillModeForwards//动画结束后保持最后状态kCAFillModeBackwards//动画结束后回到准备状态,并保持最后状态kCAFillModeBoth//执行完成移除动画kCAFillModeRemoved 要注意的是如果 CA Animation 的 removedOnCompletion 属性设置为 NO 的时候，fillMode 是无效的。 属性动画(CAPropertyAnimation)​ 属性动画作用于图层的某个单一属性，并指定了它的一个目标值，或者一连串将要做动画的值。属性动画分为两种：基础和关键帧。 基础动画(CABasicAnimation)​ 在上面的显示动画中也提到了，动画其实就是图层/视图在一段时间内发生的改变，从一个值到另一个值之间的过渡，这也是 CABasicAnimation 最主要的功能。 CABasicAnimation 是 CAPropertyAnimation 的子类。 CAPropertyAnimation 通过指定一个图层的 keyPath 作用于这个属性，实际上这个 keyPath 并不是指单一的图层的属性，而是包含了它子成员的属性，或者是一些虚拟属性。 CABasicAnimation 继承于 CAPropertyAnimation，并且添加了如下三个属性： 123id fromValueid toValueid byValue 分别设置这三个属性说表达的效果： 同时设置 fromValue 和 toValue，会在这两个值之间做动画 同时设置 formValue 和 byValue，则会在 fromValue 和 fromValue + byValue 之间做动画 同时设置 byValue 和 toValue，会在 toValue - byValue 和 toValue 之间做动画 只设置 fromValue 则会在 fromValue 和当前图层的呈现层的目标值之间做动画 只设置 toValue 则会在当前图层呈现层的目标值和 toValue 之间做动画 只设置 byValue 则会在当前图层呈现层的目标值和 当前图层呈现层的目标值 + byValue 之间做动画 这三个属性都被指定成了 id 类型，之所以是 id 类型的是因为属性动画不是单一的作用在一个固定类型的属性，而是很多不同类型的属性上，包括数字类型，矢量，变换矩阵，甚至是颜色或者图片。还有一些非 NSObject 派生对象的属性，那么如果用这些属性来做动画就需要将数据转换包装一下。 但是需要注意的是不能同事设置这三个属性，因为可能会发生冲突。 如下通过 CABasicAnimation 显示动画来修改 CALayer 的背景色： 123456789CGFloat red = arc4random() / (CGFloat)INT_MAX;CGFloat green = arc4random() / (CGFloat)INT_MAX;CGFloat blue = arc4random() / (CGFloat)INT_MAX;UIColor *color = [UIColor colorWithRed:red green:green blue:blue alpha:1.0];CABasicAnimation *animation = [CABasicAnimation animation];animation.duration = 3.0;animation.keyPath = @&quot;backgroundColor&quot;;animation.toValue = (__bridge id) color.CGColor;[_layer addAnimation:animation forKey:@&quot;backgroundColor&quot;]; 当运行这段代码的时候会发现 layer 的背景色过渡到一个新的颜色后当动画结束的那一瞬间， layer 的背景色又立刻变回了最初始的值。这所以这样是因为 CABasicAnimation 动画并不会改变图层的模型层，而是改变的呈现层。一旦动画结束就会从图层上移除，图层恢复到初始的状态。因为我们也从来没有改变 backgroudColor 这个属性。利用这一点， CABasicAnimation 很合适用来做连续循环的动画。如下展示了一个心跳的简单动画。 123456789101112131415161718192021_layer = [CALayer layer];UIImage *image = [UIImage imageNamed:@&quot;heart.jpg&quot;];_layer.contents = (__bridge id )image.CGImage;self.layer.bounds = CGRectMake(0, 0, image.size.width / 10, image.size.height / 10);_layer.position = self.view.layer.position;[self.view.layer addSublayer:_layer];CABasicAnimation *animation = [CABasicAnimation animation];animation.keyPath = @&quot;bounds&quot;;animation.fromValue = [NSValue valueWithCGRect:_layer.bounds];animation.toValue = [NSValue valueWithCGRect:CGRectMake(0, 0, image.size.width / 2, image.size.height / 2)];//重复次数，HUGE 一个宏定义等同于MAXFLOATanimation.repeatCount = HUGE;//动画时长animation.duration = 1.0;//以动画的形式回到初始状态animation.autoreverses = YES;//计时方式animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];//添加动画到 layer[_layer addAnimation:animation forKey:@&quot;heartJump&quot;]; 关键帧动画(CAKeyframeAnimation)​ CAKeyframeAnimation 同样的也是 CAPropertyAnimation 的子类，同样的也是作用于一个单一的属性。但是和 CABasicAnimation 不同的是它不限制于在 fromValue 、 byValue 和 toValue 之间的值做动画，而是可以根据一连串随意的值来做动画。 ​ CAKeyframeAnimation 有一些关键的属性如下： values: 关键帧值数组，动画会根据该数组的内容数值作出动画变换。 path: 关键帧路径，动画根据该路径作出变化，优先权大于 values ，当同时设置 values 和 path 时，优先作用于 path 。 keyTimes: 每一帧所对应的时间，时间可以控制动画的速度，值从 0.0-1.0 ，默认为每一帧时间相等。 timingFunctions: 时间控制数组，即每一帧的动画速度控制，具体效果在 CAAnimation 中有描述。 calculationMode: 动画计算模式，该属性时一个 NSString 类型的，可接受如下几种常量： 1234567891011121314//关键帧为座标点的时候,关键帧之间直接直线相连进行插值计算kCAAnimationLinear//离散的,也就是没有补间动画kCAAnimationDiscrete//平均，keyTimes跟timeFunctions失效kCAAnimationPaced//对关键帧为座标点的关键帧进行圆滑曲线相连后插值计算,对于曲线的形状还可以通过tensionValues,continuityValues,biasValues来进行调整自定义,keyTimes跟timeFunctions失效kCAAnimationCubic//在kCAAnimationCubic的基础上使得动画运行变得均匀,就是系统时间内运动的距离相同,keyTimes跟timeFunctions失效kCAAnimationCubicPaced tensionValues: NSNumber 数组，定义曲线密度。 continuityValues: NSNumber 数组，定义曲线拐角的锐度 biasValues: 动画的偏斜率 rotationMode: 动画沿 path 移动时旋转的方式，默认为 nil 就是不做任何旋转。NSString 类型的属性，接受如下两种常量： 1234//根据path的切面自动旋转方向kCAAnimationRotateAuto//根据path的切面自动翻转kCAAnimationRotateAutoReverse 如下使用做一个动画让其根据设定的点移动。 123456789101112131415161718192021222324252627//首先添加一个 layer 到视图_maliaoLayer = [CALayer layer];_maliaoLayer.frame = CGRectMake(0, 0, 65, 75);_maliaoLayer.position = CGPointMake(33, CGRectGetHeight(self.view.bounds) - 38);_maliaoLayer.contents = (__bridge id) [UIImage imageNamed:@&quot;maliao.png&quot;].CGImage;[self.view.layer addSublayer:_maliaoLayer];//添加动画- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; //创建关键帧动画 CAKeyframeAnimation *animation = [CAKeyframeAnimation animation]; //针对position值做动画 animation.keyPath = @&quot;position&quot;; //动画时间 animation.duration = 3.0; animation.values = @[[NSValue valueWithCGPoint:CGPointMake(0, 667)], [NSValue valueWithCGPoint:CGPointMake(10, 550)], [NSValue valueWithCGPoint:CGPointMake(40, 400)], [NSValue valueWithCGPoint:CGPointMake(100, 300)], [NSValue valueWithCGPoint:CGPointMake(200, 600)], [NSValue valueWithCGPoint:CGPointMake(300, 250)], [NSValue valueWithCGPoint:CGPointMake(350, 0)]]; //动画方式 animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; //添加动画到图层 [_maliaoLayer addAnimation:animation forKey:nil];&#125; 效果如下： 当然上面的例子时通过 values 来做动画的，但是同样的效果也可以通过 path 来实现，只需要把 values 更改成 path，如下: 1234567_path = [[UIBezierPath alloc]init];[_path moveToPoint:CGPointMake(33, CGRectGetHeight(self.view.bounds))];[_path addCurveToPoint:CGPointMake(100, 10) controlPoint1:CGPointMake(100, 20) controlPoint2:CGPointMake(100, 50)];[_path addCurveToPoint:CGPointMake(200,20) controlPoint1:CGPointMake(100, 50) controlPoint2:CGPointMake(200, 50)];animation.path = _path.CGPath;[_maliaoLayer addAnimation:animation forKey:nil]; 弹性动画(CASpringAnimation)​ 弹性动画是在 iOS9 之后新加入的，主要可以通过这个类来做一些带有弹性的动画，该类继承自 CABasicAnimation ，除了 CABasicAnimation 的属性外，新增了如下属性： mass: 质量，影响图层运动时的弹簧惯性，质量越大，弹簧拉伸和压缩的幅度越大。 stiffness: 刚度系数，刚度系数越大，形变产生的力就越大，运动越快 damping: 阻尼系数，阻止弹簧伸缩的系数，阻尼系数越大，动画停止越快 initialVelocity: 初始速率，动画视图的初始速度大小速率为正数时，速度方向与运动方向一致，速率为负数时，速度方向与运动方向相反 settlingDuration: 结束时间，这是一个只读属性，返回动画结束的时间，该时间是根据当前动画的各个参数计算的。 下面通过一个 Demo 来感受下这个弹性动画😄 12345678910CASpringAnimation *animation = [CASpringAnimation animation];animation.keyPath = @&quot;position.x&quot;;animation.fromValue = (id)@(_imageView.layer.position.x);animation.toValue = (id)@(_imageView.layer.position.x + 100);animation.mass = 1;animation.stiffness = 100;animation.damping = 1;animation.initialVelocity = 0;animation.duration = animation.settlingDuration;[_imageView.layer addAnimation:animation forKey:nil]; 动画组(CAAnimationGroup)​ 动画组，顾名思义就是一组动画同时进行。CAAnimationGroup 继承于 CAAnimation ，有一个 Animations 的属性，就是把多个 Animation 或者其子类装入数组中添加到动画组中一起执行。用法如下： 1234567891011121314151617181920CASpringAnimation *animation = [CASpringAnimation animation];animation.keyPath = @&quot;position.x&quot;;animation.fromValue = (id)@(_imageView.layer.position.x);animation.toValue = (id)@(_imageView.layer.position.x + 100);animation.mass = 1;animation.stiffness = 100;animation.damping = 1;animation.initialVelocity = 0;animation.duration = animation.settlingDuration;CABasicAnimation *scalAnimation = [CABasicAnimation animation];scalAnimation.keyPath = @&quot;bounds.size&quot;;scalAnimation.fromValue = [NSValue valueWithCGSize:_imageView.layer.bounds.size];scalAnimation.toValue = [NSValue valueWithCGSize:CGSizeMake(_imageView.layer.bounds.size.width * 3, _imageView.layer.bounds.size.height *3)];scalAnimation.duration = 3;CAAnimationGroup *animationGroup = [CAAnimationGroup animation];animationGroup.animations = @[animation,scalAnimation];animationGroup.duration = 6;[_imageView.layer addAnimation:animationGroup forKey:nil]; 转场过渡动画(CATrsantion)​ CATrasition 继承自 CAAnimation ，CATrasntion 通过 type 属性提供了 4 种过渡动画，是一个 NSString 类型的属性，可以接受下面四种常量： 12345678//淡入淡出kCATransitionFade//移进kCATransitionMoveIn //推动进去kCATransitionPush //揭开kCATransitionReveal 其实除了上面这 4 种过渡动画还有一些私有的。这四种出了第一种是固定的以为，后面三种都是有一个方向的，方向的更改可以通过 subtype 属性来更改方向，该属性也是一个 NSString 类型的，有如下四种常量： 1234kCATransitionFromRight kCATransitionFromLeft kCATransitionFromTop kCATransitionFromBottom 平常基本上需要用到的动画都在这里了，基本上都可以通过这里讲到的动画方式来组合出来的。","categories":[],"tags":[{"name":"动画","slug":"动画","permalink":"Aaronzjp.cn/tags/动画/"},{"name":"Animation","slug":"Animation","permalink":"Aaronzjp.cn/tags/Animation/"}]},{"title":"Swift-集合类型","slug":"Swift-CollectionTypes","date":"2017-03-05T07:10:35.000Z","updated":"2017-08-01T07:55:09.000Z","comments":true,"path":"2017/03/05/Swift-CollectionTypes/","link":"","permalink":"Aaronzjp.cn/2017/03/05/Swift-CollectionTypes/","excerpt":"集合类型在 Swift 中集合类型主要有 Array、Sets、Dictionaries。和 O-bjc 中不同的是 Swift 中集合的可变类型和不可变类型并不是子类和父类的关系，而是同一个类。可变和不可变是通过变量类型来区分的，如果使用 var 来声明成变量那么就是可变的，如果使用 let 来声明成常量那么就是不可变的。","text":"集合类型在 Swift 中集合类型主要有 Array、Sets、Dictionaries。和 O-bjc 中不同的是 Swift 中集合的可变类型和不可变类型并不是子类和父类的关系，而是同一个类。可变和不可变是通过变量类型来区分的，如果使用 var 来声明成变量那么就是可变的，如果使用 let 来声明成常量那么就是不可变的。 数组的简单使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//创建一个空的数组//可变var someInts = [Int]()//不可变let someDoubels = [Double]()//字面量创建数组let ints = [1,2,3,4,5]var shoppingList: [String] = [\"Eggs\",\"Milk\",\"Tomato\"]//创建带有默认值的数组var defualtArray = Array(repeating: 6, count: 3)//数组也可以使用 + 运算符来拼接let sumArray = ints + defualtArray//获取数组元素个数let arrayCount = sumArray.count//判断数组是否为空//通过 isEmpty 属性判断if sumArray.isEmpty &#123; print(\"sumArray is empty array\");&#125; else &#123; print(\"sumArray is not empty array\");&#125;//通过检查数组元素个数是否为0来判断数组是否为空if sumArray.count == 0 &#123; print(\"sumArray is empty array\");&#125; else &#123; print(\"sumArray is not empty array\");&#125;/* 数组拼接添／加数据*/shoppingList.append(\"Water\")shoppingList += [\"Cheese\",\"Butter\"]//数组元素的获取let water = shoppingList[3]//使用数组下标修改数组中的元素shoppingList[3] = \"Bananas\"//使用下标区间一次修改多个值shoppingList[0...3] = [\"iPhone\",\"iMac\",\"iPod\"]//在数组的制定下标索引位置插入元素shoppingList.insert(\"Apple\", at: 0)//在数组的指定下标索引位置插入一个数组shoppingList.insert(contentsOf: [\"MicroSoft\",\"Google\"], at: 0)//在数组中移除某个指定下标位置的数组元素shoppingList.remove(at: 0)shoppingList.removeLast()shoppingList.removeSubrange(0...1)//替换数组中指定范围的元素shoppingList.replaceSubrange(0...1, with: [\"MacBook Pro\",\"MacBook Air\"])//数组的遍历for item in shoppingList &#123; print(item)&#125;/* 使用 enumerated() 方法同时遍历数组索引，和数组元素*/for (index, value) in shoppingList.enumerated() &#123; print(\"第\\(index + 1)个元素是\\(value)\")&#125; 集合的简单使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//初始化一个空的集合，必须显示的声明集合的类型var letters = Set&lt;Int&gt;()//确定集合的类型后可以使用数组字面量赋值letters = []//使用数组字面量创建集合var set:Set&lt;Int&gt; = [1,2,3,3,4]var set2:Set = [2,23,5,6,89,]//判断集合是否为空var foods:Set = [\"Apple\",\"Milk\",\"Beef\"]if foods.isEmpty &#123; print(\"this sets is empty\")&#125; else &#123; print(\"this sets is not empty\")&#125;//也可以像数组一样使用元素个数来检查是否为空if foods.count == 0 &#123; print(\"this sets is empty\")&#125; else &#123; print(\"this sets is not empty\")&#125;//获取集合的元素个数foods.count//像集合添加新的元素foods.insert(\"Peach\")foods.insert(\"Tomato\")foods.insert(\"Bread\")//移除集合元素foods.remove(at: foods.index(of: \"Apple\")!)foods.remove(\"Peach\")foods.removeFirst()//是否包含某个元素的检查if foods.contains(\"Milk\") &#123; print(\"foods hava Milk\")&#125;//遍历集合for food in foods &#123; print(food)&#125;//使用 sorted() 方法有序的遍历集合for food in foods.sorted() &#123; print(food)&#125;//既然是集合就有交集，相交等let numbers: Set = [1,2,3,4,5,6,7,8,9]let newNumbers: Set = [2,3,4,5,10,11,12,13]//相交等集合元素，创建一个新的集合let interNumbers = numbers.intersection(newNumbers)//不相交的集合元素，创建一个新的集合let symmerricNumbers = numbers.symmetricDifference(newNumbers)//将两个集合融合在一起，创建一个新的集合let unionNumbers = numbers.union(newNumbers)//不包含另一个集合的元素，创建一个新的集合let notSubNumbers = numbers.subtracting(newNumbers)//集合关系的判断//判断集合是否相等if numbers == newNumbers &#123; print(\"numbers == newNumbers\")&#125; else &#123; print(\"numbers != newNumbers\")&#125;//判断集合a是是集合b的子集let a: Set = [2,3,4]let b: Set = [2,3,4,5,1]if a.isSubset(of: b) &#123; print(\"a is subSet of b\")&#125;//判断一个集合b是否包含集合a的所有元素if b.isSuperset(of: a) &#123; print(\"b is superSet of a\")&#125;//判断两个集合是否不含有相同的值if b.isDisjoint(with: a) &#123; print(\"YES\")&#125; else &#123; print(\"NO\")&#125; 字典的简单使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//创建一个空字典var emptyDictionary = [Int: String]()emptyDictionary[16] = \"Aaron\"//使用字面量创建字典//常量，不可变字典let newDictionary = [1:\"Aaron\",2:\"Jay\",3:\"Edison\",4:\"Jack\"]//变量，可变字典var muatableDictionary: [String: String] = [\"艾伦\":\"Aaron\",\"爱迪生\":\"Edison\",\"杰\":\"Jay\",\"杰克\":\"Jack\"]//访问和修改字典//通过键值获取let name = muatableDictionary[\"艾伦\"]//通过键值修改muatableDictionary[\"艾伦\"] = \"Alan\"//修改和添加元素muatableDictionary.updateValue(\"艾伦\", forKey: \"艾伦\")print(muatableDictionary)muatableDictionary.updateValue(\"Alan\", forKey: \"艾伦\")print(muatableDictionary)//删除元素//通过key删除元素muatableDictionary.removeValue(forKey: \"艾伦\")//通过索引删除muatableDictionary.remove(at: muatableDictionary.index(forKey: \"杰克\")!)//通过置nil删除元素muatableDictionary[\"爱迪生\"] = nilprint(muatableDictionary)//字典的遍历//通过元组遍历字典for (numberOfName, englishName) in newDictionary &#123; print(\"第\\(numberOfName)个名字是\\(englishName)\")&#125;//这样遍历出来的应该也是元组for keysAndValues in newDictionary &#123; print(keysAndValues)&#125;//遍历字典所有的keyfor numberOfName in newDictionary.keys &#123; print(numberOfName)&#125;//遍历字典所有的值for name in newDictionary.values &#123; print(name)&#125;","categories":[],"tags":[{"name":"Swift","slug":"Swift","permalink":"Aaronzjp.cn/tags/Swift/"}]},{"title":"Swift-函数","slug":"Swift-Function","date":"2016-12-01T06:11:37.000Z","updated":"2018-11-24T09:36:23.567Z","comments":true,"path":"2016/12/01/Swift-Function/","link":"","permalink":"Aaronzjp.cn/2016/12/01/Swift-Function/","excerpt":"","text":"函数的声明和调用在swift中函数是一个非常灵活的东西，可以定义任何的类型来作为函数的参数和返回值，一个比较完整的函数声明包括很多部分，下面就是一个简单的函数声明： 1234567func sum(numbers: [Int]) -&gt; Int &#123; var sum = 0 for number in numbers &#123; sum += number &#125; return sum&#125; 该函数的函数名为sum(numbers:)，有一个叫numbers的Int类型的数组参数，并返回一个Int类型的值。这应该就是一个比较完整的函数的声明。在swift中声明一个函数的时候尽量做到函数名简洁清楚，以达到该函数使用者在看到这个函数的时候就能大致理解函数的用意。调用下上面的函数看下结果会是什么样： 123let numbers = [1,2,3,4,5,6,7,8,9]let sumNumber = sum(numbers: numbers)//输出结果：45 上面这个函数传入的是一个Int类型的数组来计算数组中元素的和，通过调用函数证明该函数正确的输出了数组中元素的和。 可变函数参数也可以将上面的函数改成如下函数来求各个数的和，该函数看起来可能和上面的函数看起来基本上没有差别，但是仔细看可以看到函数参数变了，该函数接收Int类型的参数且参数个数是可变的，在函数体内部可变函数的参数被转换为参数同类型的数组，函数体内部其实和上面的那个函数没有差别，都是对数组进行处理求和。如果愿意这里可以传入大量的参数。 12345678910func sum(numbers: Int...) -&gt; Int &#123; var sum = 0 for number in numbers &#123; sum += number &#125; return sum&#125;let sumNumber = sum(numbers: 1,2,3,4,5,6,7,8,9)//输出结果：45 需要注意的是一个函数最多只能有一个可变参。 多参数函数函数也可以接受多个参数的输入，多个参数用逗号隔开即可。下面这个函数输出一个字符串，告诉你谁和谁是好朋友： 123456func whoIsFriend(person1: String, person2: String) -&gt; String &#123; return person1+\"和\"+person2+\"是好朋友！\"&#125;let friend = whoIsFriend(person1: \"Aaron\", person2: \"Edison\")//输出结果：Aaron和Edison是好朋友！ 无参数和无返回值函数函数可以是没有参数的，比如下面的这个参数在调用的时候它会返回一个固定的值： 123456func printHello() -&gt; String &#123; return \"Hello!\"&#125;let hello = printHello()//输出结果：Hello！ 函数可以没有参数也可以没有返回值，下面的函数就是一个没有返回值的函数，当函数调用的时候会直接执行函数体中的代码，不会返回任何值： 123456func printHello() &#123; print(\"Hello!\")&#125;printHello()//输出结果：Hello！ 多返回值函数当函数需要返回多个值的时候可以使用元组来包裹需要返回的值以达到返回多个值的目的，下面的这个函数通过元组返回数组中的最大值和最小值： 123456789101112131415161718func minMax(array: [Int]) -&gt; (min: Int, max: Int) &#123; var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count] &#123; if value &lt; currentMin &#123; currentMin = value &#125; else if value &gt; currentMax &#123; currentMax = value &#125; &#125; return (currentMin, currentMax)&#125;let numbers = [2,5,3,6,7,10]let bounds = minMax(array: numbers)print(bounds.min,bounds.max)//输出结果：2 10 该函数返回一个包含了两个Int元素的元组，元素被标记为min和max，我们可以通过元组中的元素名用点语法来取出元组中的值。 可选多返回值函数函数可以通过元组返回多个值，这些值也可以是可选类型的。但是要注意的是元组可以区分为元素可选元组(Int,String?)和元组可选元组(Int,String)?。上面的这个函数，其实并不是很安全，如果给该函数传入一个空数组就会导致程序崩溃，为了安全起见我们可以改成下面这样，当传入的数组为空时我们返回nil： 1234567891011121314151617181920func minMax(array: [Int]) -&gt; (min: Int, max: Int)? &#123; if array.isEmpty &#123;return nil&#125; var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count] &#123; if value &lt; currentMin &#123; currentMin = value &#125; else if value &gt; currentMax &#123; currentMax = value &#125; &#125; return (currentMin, currentMax)&#125;let numbers = [Int]()//用可选绑定来检查返回值if let bounds = minMax(array: numbers) &#123; print(bounds.min,bounds.max)&#125;//此处没有任何输出结果，因为返回值为nil 函数参数标签和参数名称在swift的函数中每个函数的参数都有一个参数标签和参数名称。参数标签在调用参数的时候使用，参数名称则在函数的实现中使用，在默认情况下参数标签就是参数名称。但是在某些时候可能需要更好的为函数调用者说明参数的用意，可能会另外的为参数取一个易懂的参数标签，以便函数调用的时候使用。如下为函数参数指定标签： 123456789let sumNumber = sum(numbers: 1,2,3,4,5,6,7,8,9)func whoIsFriend(person: String, with person1: String) -&gt; String &#123; return person+\"和\"+person1+\"是好朋友！\"&#125;let friend = whoIsFriend(person: \"Aaron\", with: \"Edison\")print(friend)//输出结果：Aaron和Edison是好朋友！ 上面的这个函数为函数的第二个参数加入了一个with的参数标签，这样函数在调用的时候就显得可读性更高，比之前没有函数标签时可读性更高，更规范。函数中参数名称必须是不一样的，但是参数标签是可以相通的。 忽略参数标签当然参数标签也是可以忽略的，忽略参数标签使用_来占位代替参数标签： 1234567func whoIsFriend(_ person: String, _ person1: String) -&gt; String &#123; return person+\"和\"+person1+\"是好朋友！\"&#125;let friend = whoIsFriend(\"Aaron\", \"Edison\")print(friend)//输出结果：Aaron和Edison是好朋友！ 函数默认参数值函数中还可以为参数赋予默认值，当默认值被设置后在调用函数的时候可以忽略这个参数： 123456789func sumNumber(number1: Int, number2: Int = 10) -&gt; Int &#123; return number1 + number2&#125;let sum = sumNumber(number1: 1)let sum2 = sumNumber(number1: 1, number2: 15)print(\"sum = \\(sum),sum2 = \\(sum2)\")//输出结果：sum = 11,sum2 = 16 很明显sum在调用函数的时候忽略了第二个默认为 10 的参数，所以使用默认的值来计算返回 11，sum2在调用函数的时候传入了第二个参数为 15 来替代了默认值 10 所以返回为16。 输入输出参数输入输出参数是指给函数传入的参数是可以在函数内部被修改的，设置输入输出参数要在函数参数的类型前加上inout关键字，这样被标记的函数参数才是可以被修改的。调用函数的时候传入输入输出参数的值必须是变量，不能是常量或是字面量，因为只有变量可以被修改，可变参数不能设定为输入输出参数。且输入输出参数不能设置默认值。 12345678910111213func swapNumber( a: inout Int, b: inout Int) &#123; let temp = a a = b b = temp&#125;var a = 10,b = 20print(\"交换前 a = \\(a),b = \\(b) \")swap(&amp;a, &amp;b)print(\"交换后 a = \\(a),b = \\(b)\")//输出结果：交换前 a = 10,b = 20 交换后 a = 20,b = 10 该函数是交换两个Int类型的值，要注意的是在调用有输入输出参数的函数时需要在输入输出参数前加上&amp;符号。 函数类型在swift中函数是具有函数类型的，函数的类型是由函数参数和函数返回值组成的。如下函数： 123func sumNumber(number1: Int, number2: Int = 10) -&gt; Int &#123; return number1 + number2&#125; 该函数的函数类型是(Int,Int) -&gt; Int，可以理解为该函数有两个Int型的参数并返回Int型的值。那如果函数没有参数和返回值，函数会是什么类型？如下： 123func printHelloWorld() &#123; print(\"hello, world\")&#125; 该函数没有参数也没有返回值，该函数的类型是() -&gt; Void，可以理解为该函数没有参数并返回Void类型的函数。在OC中如果一个方法没有返回值，那么会用void关键字来标示。在swift中没有返回值的函数函数类型也用Void表示，其实swift中没有返回值的函数会返回一个特殊的Void值，其本质是一个空的元组，没有任何的元素。 函数类型的使用函数类型赋值 在swift中函数类型就像是普通的类型一样，可以声明一个变量或者是常量的函数类型，并且可以给同类型的函数相互赋值，且函数的类型也是可以通过推断得出来的。如下，声明一个函数，并将它赋值给另一个函数并调用该函数： 1234567891011121314func sum(number1: Int, number2: Int = 10) -&gt; Int &#123; return number1 + number2&#125;let sumNumber = sum(number1: 10, number2: 100);print(sumNumber)let numberSum = sumlet sumNumber2 = numberSum(10, 100)print(sumNumber2)//输出结果：110110 上面声明了一个(Int,Int) -&gt; Int类型的函数sum，并将该函数赋值给常量类型的函数numberSum，分别调用sum和numberSum函数，其结果是一样的。 函数类型作为参数类型 当然函数既然可以相互赋值那么函数也可以作为其他函数的参数和返回值，将函数类型作为参数类型这样就可以给函数调用者更大的空间来实现这一部分的函数。 1234567891011func sum(sumFunc: (Int, Int) -&gt; Int ,numberA: Int, numberB: Int = 10) -&gt; Int &#123; return sumFunc(numberA, numberB)&#125;func sumNumber(a: Int, b: Int) -&gt; Int &#123; return a + b&#125;let result = sum(sumFunc: sumNumber, numberA: 10, numberB: 20)//输出结果：result = 30 该函数有三个参数，其中一个sumFunc的参数是一个函数类型，接受两个Int类型的参数，并返回一个Int类型的值，numberA和numberB则是两个Int类型的参数。该函数返回一个Int类型的值，该值是由第一个函数类型的参数来决定的。函数类型也可以作为函数的返回值来使用，我想这里的用处应该是返回一个内部函数（嵌套函数）吧。 总结swift的函数总的来说比起在OC语言中的函数要灵活得多，函数的创建有两种方式，一种是通过func关键字来创建，另一种方式是使用{}来创建，其中通过{}创建的函数被称作闭包表达式。在swift中函数的类型其实总的来说可以像我们平常使用变量或者常量一样，可以在相通类型的函数之间相互赋值，也可以作为函数的参数，或者将函数类型作为函数的返回值来使用。","categories":[],"tags":[{"name":"Swift","slug":"Swift","permalink":"Aaronzjp.cn/tags/Swift/"}]},{"title":"初识CALayer","slug":"iOS-CALayer","date":"2016-12-01T06:11:37.000Z","updated":"2018-11-24T09:33:45.894Z","comments":true,"path":"2016/12/01/iOS-CALayer/","link":"","permalink":"Aaronzjp.cn/2016/12/01/iOS-CALayer/","excerpt":"CALayer 和 UIView 类似，也是一些被层级关系树管理的块。 CALayer 和 UIView 一样的可以可以在其中展示图片，文本，通过方法或属性做动画和图形变换等等的界面上的显示相关的东西，可以说 UIView 能做到的 CALayer 基本上也能做到，但是 CALayer 和 UIView 最大的不同是 CALayer 不处理和用户的交互。因为 CALayer 不能很好的处理具体的响应链，无法响应事件的处理，即使在 CALayer 的方法中提供了触摸事件的检测方法。","text":"CALayer 和 UIView 类似，也是一些被层级关系树管理的块。 CALayer 和 UIView 一样的可以可以在其中展示图片，文本，通过方法或属性做动画和图形变换等等的界面上的显示相关的东西，可以说 UIView 能做到的 CALayer 基本上也能做到，但是 CALayer 和 UIView 最大的不同是 CALayer 不处理和用户的交互。因为 CALayer 不能很好的处理具体的响应链，无法响应事件的处理，即使在 CALayer 的方法中提供了触摸事件的检测方法。 CALayer和UIView的关系很早以前我一直弄不清楚 CALayer 和 UIView 之间到底是个怎么样的关系，我只是知道每一个 UIView 中都至少包含了一个 CALayer 。其实在每一个 UIView 中都有一个 CALayer 的实例图层属性，当视图被创建的时候就会有对应的一个图层，图层和视图一样也可以添加子图层。 UIView 其实是对 CALayer 的一层封装，之前也说了 CALayer 不能响应事件以及和用户交互， UIView 在这里就充当了一个来代替 CALayer 响应事件的处理和管理 CALayer 的一个角色， UIView 也只是负责这些东西的处理，在屏幕上显示和动画的处理其实都是在 CALayer 上进行的。 图层结构和对应的视图层级的关系如下图： CALayer常用属性 属性 属性相关描述 backgroundColor 为图层添加背景色，该属性为CGColorRef类型 contents 图层内容，寄宿图。id 类型，iOS中一般使用CGImage赋值，MacOS中则可以使用NSImage 或 CGImage contentsGravity 寄宿图内容展示方式，和UIImageView的contensMode对应。该属性是NSString类型 contentsScale 寄宿图显示比例设置， maskToBounds 是否显示超出边界的内容，该属性是一个BOOL值类型，默认为NO，即显示超出边界的内容 contentsRect CGRect类型，允许图层显示寄宿图的某个固定区域。使用单位坐标，即0到1之间 contentsCenter 图层可拉伸区域的设置，也是使用单位坐标 frame 代表图层外部的坐标以及大小，即相对于父图层的位置 bounds 图层的内部坐标大小，bounds的X，Y轴在 iOS 中一般位于图层的左上角 position position 是相对于 anchorPiont 的位置在 superLayer 的位置。 anchorPiont 图层的锚点，固定图层的点。（当对图层做旋转形变的时候，图层将围绕该点旋转），使用单位坐标即{0,0,1,1}; geometryFlipped 图层翻转，该属性是一个 BOOL 属性，在 iOS 中将该属性设置为 YES 的时候，图层将会相对于父图层做垂直翻转，即该图层的位置将会相对于父图层从左下角开始。 conrnerRadius 该属性控制着图层角的曲率。它是一个浮点数，默认为0（为0的时候就是直角），但是你可以把它设置成任意值。 masksToBounds 该属性是一个BOOL类型的，当设置为YES的时候他将会截取图层中超出边界的部分 borderWidth 图层边框宽度，以点为单位，默认为0 borderColor 图层边框颜色，是一个 CGColorRef 类型的属性 CALayer的使用 CALayer 也可以像 UIView 一样的添加背景色，寄宿图，同时还可以通过 CALayer 做一些 UIView 不能做到的视觉效果。 为CALayer添加背景色123456789101112131415161718192021222324#import &quot;CALayerBGColorViewController.h&quot;@interface CALayerBGColorViewController ()@property (nonatomic,strong) UIView *whiteView;@end@implementation CALayerBGColorViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.whiteView = [[UIView alloc]init]; _whiteView.backgroundColor = [UIColor whiteColor]; _whiteView.bounds = CGRectMake(0, 0, 150, 150); _whiteView.center = self.view.center; [self.view addSubview:_whiteView]; CALayer *orangeLayer = [CALayer layer]; orangeLayer.frame = CGRectMake(25, 25, 100, 100); orangeLayer.backgroundColor = [UIColor orangeColor].CGColor; [_whiteView.layer addSublayer:orangeLayer];&#125;@end 这里为控制器添加了一个白色的视图 图 whiteView ，然后向 whiteView 中的 layer 添加了一个子图层（ orangeLayer ），并给 orangeLayer 添加了橘色的背景色。 CALayer 和 UIView 相比，缺少了一个 center 属性。当向 CALayer 添加背景色的时候并不是赋值的 UIColor 类，而是一个 CGColorRef 这是因为该库是由 C 语言所编写的。 CALayer 中设置寄宿图同样也是赋值一个 CGImage 。 CALayer的contents的使用1234567891011121314151617181920212223#import &quot;CALayerBackImageViewController.h&quot;@interface CALayerBackImageViewController ()@property (nonatomic,strong) UIView *layerView;@end@implementation CALayerBackImageViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.layerView = [[UIView alloc]init]; _layerView.bounds = CGRectMake(0, 0, 150, 100); _layerView.center = self.view.center; [self.view addSubview:_layerView]; UIImage *EdisonImage = [UIImage imageNamed:@&quot;Edison.jpg&quot;]; _layerView.layer.contents = (__bridge id)(EdisonImage.CGImage); _layerView.layer.backgroundColor = [UIColor orangeColor].CGColor; _layerView.layer.contentsGravity = kCAGravityResizeAspect; &#125;@end 代码中我们为视图的 layer 添加了一个图片作为 layer 的寄宿图，但是这里要注意⚠️的是，这和我们使用 UIImageView 添加图片是有区别的。我们给 layer 赋值的图片是一个 CGImage 的类型，原因上面也提到了因为该库是由 C 语言编写的，所以 CGImage 其实是一个 CGImageRef 的 Core Foundation 类型。 Core Foundation 类型和 Cocoa 对象并不是兼容的对象，所以这里在赋值的时候还需要进行类型转换，在 ARC 环境下需要使用桥接来转换类型，以便编译器在内存管理的时候不会出错。 1_layerView.layer.contents = (__bridge id)(EdisonImage.CGImage); layer 在被赋值寄宿图的时候被赋值的属性并不是平常使用 UIImageView 时赋值的 Image 属性，该属性是一个叫 Contents 的 id 类型的属性。 id 类型就意味着可以赋值任何的对象给这个 Contents 属性，可以尝试下赋值其他的对象给 Contents 属性，当被赋值其他对象的时候 layer 几乎不会发生任何的改变，就是一个空白的图层， 编译也能通过，甚至还可能产生错误，这样的错误❌如果出现在实际的项目中的话应该是很难被发现的。其实在 iOS 中只能为 layer 的 Contents 属性赋值 CGImageRef 类型，这个属性被苹果设置成 id 的原因是因为 iOS 系统是由 MacOS 的系统演变出来的，在 MacOS 中该属性可以接受 CGImage 和 NSImage 类型。 CALayer 可以添加寄宿图，所以 CALayer 还有一个和 UIImageView 的 contentMode 属性相对应的属性用来处理寄宿图的显示方式。这个与之相对应的属性叫 contentsGravity ，但是这个属性是一个 NSString 的类型，而 UIKit 中的 contentMode 属性是一个枚举类型。具体的使用和 contentMode 所对应的枚举值一一对应，区别是一个是作用于 UIImageView 上的，一个是作用于 CALayer 。 寄宿图显示比例（contentsScale）还有一个值得注意的是，在 CALayer 赋值寄宿图的时候是赋值的一个由 UIImage 转换成 CGImage 的类型的图片， UIImage 在获取图片的时候是按照 Retina 屏幕的分辨率比例来获取图片的，获取的是高质量的 Retina 版本的图片，但是在转换成 CGImage 后这个比例的缩放拉伸就被忽略了，所以同样的一张图片 UIImage 展示出来的看起来比 CGImage 展示出来的要小，但是更清晰。但是在 CALayer 中还是可以让赋值的 CGImage 正常的显示在 Retina 屏幕上的，这里设置 CALayer 的 contentScale 属性，该属性其实就是为了支持高分辨率屏幕的显示而存在的吧。一般如下设置该属性： 1layer.contentsScale = [UIScreen mainScreen].scale; 该方法设置 layer 的 contentsScale 属性比起直接设置改属性的比例更好，改方法会让该属性跟随屏幕的比例而改变。 截取超出图层边界的显示内容（masksToBounds）在图层上显示寄宿图有时候图片可能会超出图层的边界，这样的情况在 UIView 下也有同样的问题。在 UIView 中用一个叫做 clipsToBounds 属性来决定是否显示超出边界的内容。 CALayer 中同样的也有一个属性可以决定是否显示其超出边界的内容 masksToBounds 。示例🌰如下： 1_layerView.layer.masksToBounds = YES; CALayer中使用图片拼合技术（contentsRect） CALayer 中 contentsRect 可以图层显示自己的一部分内容。这个属性是一个 CGRect 类型的，但是这里和平常使用的 bounds 、 frame 属性不同。 contentsRect 使用的是单位坐标，单位坐标是指在0到1之间的一个相对的坐标系，这里就是相对于寄宿图的。 contentsRect 默认情况下是{0，0，1，1}，也就是说在默认情况下是显示一个完整的图片的，当把该属性缩小后图片就会被裁剪，只显示出设置的相对的坐标中的内容。如下演示了如何将一个图片切割成4块，来拼接显示出来： 1234567891011121314151617181920212223242526272829303132333435#import &quot;CALayerImageSpritesViewController.h&quot;@interface CALayerImageSpritesViewController ()@property (weak, nonatomic) IBOutlet UIView *firstView;@property (weak, nonatomic) IBOutlet UIView *secondView;@property (weak, nonatomic) IBOutlet UIView *thirdView;@property (weak, nonatomic) IBOutlet UIView *forthView;@end@implementation CALayerImageSpritesViewController- (instancetype)init &#123; self = [super init]; if (self) &#123; UIStoryboard *storyboard = [UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:nil]; self = [storyboard instantiateViewControllerWithIdentifier:@&quot;spriteImageVC&quot;]; &#125; return self;&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; UIImage *spriteImage = [UIImage imageNamed:@&quot;Edison.jpg&quot;]; [self addImage:spriteImage WithContentsRect:CGRectMake(0, 0, 0.5, 0.5) toLayer:self.firstView.layer]; [self addImage:spriteImage WithContentsRect:CGRectMake(0.5, 0, 0.5, 0.5) toLayer:self.secondView.layer]; [self addImage:spriteImage WithContentsRect:CGRectMake(0, 0.5, 0.5, 0.5) toLayer:self.thirdView.layer]; [self addImage:spriteImage WithContentsRect:CGRectMake(0.5, 0.5, 0.5, 0.5) toLayer:self.forthView.layer];&#125;- (void)addImage:(UIImage *)image WithContentsRect:(CGRect)rect toLayer:(CALayer *)layer &#123; layer.contents = (__bridge id)image.CGImage; layer.contentsGravity = kCAGravityResizeAspect; layer.contentsRect = rect;&#125;@end 设置图层的可拉伸区域（contentsCenter）该属性是一个 CGRect 类型，和 contentsRect 一样使用的是单位坐标，默认情况下是{0，0，1，1}。它定义了一个固定的边框和一个在图层上可拉伸的区域，在普通情况下修改该属性，图层的显示并不会发生任何的变化，但是当图层被拉伸的时候就会有所变化，因为这就是设置拉伸区域的一个属性。 例如🌰：将 contentsCenter 设置为：{0.25，0.25，0.5，0.5}。其效果如下所示： 其实我看到这个图我也还是搞不太懂这个是怎么拉伸的，但是再看下下面这个例子🌰： 被拉伸前的原图： 在代码中如下设置 contentsCenter 属性： 12345678910111213141516171819202122#import &quot;CALayerContentsCenterViewController.h&quot;@interface CALayerContentsCenterViewController ()@property (nonatomic,strong) UIView *layerView;@end@implementation CALayerContentsCenterViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.layerView = [[UIView alloc]init]; _layerView.bounds = CGRectMake(0, 0, 300, 300); _layerView.center = self.view.center; [self.view addSubview:_layerView]; UIImage *image = [UIImage imageNamed:@&quot;Test.png&quot;]; _layerView.layer.contents = (__bridge id) image.CGImage; _layerView.layer.contentsGravity = kCAGravityResizeAspect; _layerView.layer.contentsCenter = CGRectMake(0.25, 0.25, 0.5, 0.5); &#125;@end 拉伸后的效果如下图： 该效果可以作用于在寄宿图层上，同时也可以作用于在 Core Graphics 运行时绘制的图形上。 图层布局管理图层和 UIView 一样也有自己的布局管理的相关的属性， UIView 有 frame， bounds ， center ， CALayer 也有与之相对应的属性， frame， bounds ， position 。 CALayer 的 position 其实和 UIView 的 center 代表的都是同一个值。 frame 这个属性其实并不是一个初始的属性，该属性是通过 bounds 和 position 和 transform 计算得到的，所有改变这3个中的任意一个的值都会影响到 frame ，同样改变 frame 也会影响这三个属性的值的改变。最后注意一点的是当图层做出旋转后，图层的 frame 可能就和 bounds 不一致了， frame 实际上代表了覆盖在图层旋转之后的整个轴对齐的矩形区域。 锚点（anchorPoint）这个属性很可能会把人搞糊涂，看似是很好理解的，但是很多人经常因为这个属性被搞糊涂。 anchorPoint 一般位于图层的中心，但是这个属性是可以被改变的，虽然在 UIView 中该属性没有被暴露出来，但是在 CALayer 中是可以进行修改的。当修改 anchorPoint 属性时可能会造成图层的偏移， 也就是说这个时候图层的中心点（ position ）以及 UIView 的 center 相对于父视图是不会改变的，但是 anchorPoint 发生了改变， anchorPoint 被修改后 anchorPoint 会自动的向图层的 position 对齐，这个时候 center 或者 position 这个属性可能并不是图层真正的中心点。当改变了 anchorPoint ， position 属性保持固定的值并没有发生改变，但是 frame 却移动了。当对图层做变换，旋转的时候，图层都会以 anchorPoint 为中心点来旋转。 图层翻转（geometryFlipped）通常来说，在 iOS 上，一个图层的位置是相对于父图层从左上角开始的，但是在 MacOS 中则是从左下角开始的。图层翻转，该属性是一个 BOOL 属性，在 iOS 中将该属性设置为 YES 的时候，图层将会相对于父图层做垂直翻转，即该图层的位置将会相对于父图层从左下角开始。 坐标系转换图层和 UIView 一样，图层树中各个图层间相对于的坐标位置是可以相互转换的，苹果提供了如下的方法，让我们可以在各个图层间获得其相对于其他图层的坐标位置，而不仅限于相对于父图层的位置： 1234- (CGPoint)convertPoint:(CGPoint)point fromLayer:(CALayer *)layer; - (CGPoint)convertPoint:(CGPoint)point toLayer:(CALayer *)layer; - (CGRect)convertRect:(CGRect)rect fromLayer:(CALayer *)layer;- (CGRect)convertRect:(CGRect)rect toLayer:(CALayer *)layer; 图层的自动布局在Mac OS平台下， CALayer 有一个叫做 layoutManager 的属性可以通过 CALayoutManager 协议和 CAConstraintLayoutManager 类来实现自动排版的机制。但是因为 iOS 和 MacOS 还是有一定的区别，所有在 iOS 上并不适用。在使用视图 UIView 时我们一般使用 UIViewAutoresizingMask 和 NSLayoutConstraint 来完成自动布局，但是在 CALayer 下就不能使用这样的方式来处理了。在 CALayer 中布局需要遵守 CALayerDelegate 中的方法： 1- (void)layoutSublayersOfLayer:(CALayer *)layer; 在此方法中来布局图层。当图层的 bounds 发生改变，或者图层的-setNeedsLayout方法被调用时就会执行此代理方法。我们可以在此代理方法中来布局或重新调整子图层的大小以及位置，但是不能像 UIView 的 autoresizingMask 和 constraints 属性做到自适应屏幕旋转。 图层效果圆角圆角矩形， CALayer 有一个叫 conrnerRadius 的属性，他控制图层的圆角率，默认是0.0，但是我们可以设置为任意的值，该值会影响背景色，但是背景图片和里面的子图层不会受到影响，所以如果有背景图片或者有子视图在图层内时，设置改属性后可能不会根据设置的圆角率来显示图层。不过这个问题只需要设置另一个属性即可解决， masksToBounds ，该属性是一个 BOOL 类型,他可以决定是否显示超出图层外的图层部分。默认是 NO ，当设置为 YES 的时候图层就会截取超出图层的部分。圆形图层也可以通过设置 conrnerRadius 来设置，前提是当前图层是一个正方形，当 conrnerRadius 的值等于正方形边长的一半的时候就是圆形。 图层边框 CALayer 有两个属性可以为图层绘制边框，即 borderWidth 和 borderColor ，通过这两个属性我们可以定制图层绘制的边框，这条线(又被称作stroke)会沿着图层的 bounds 边缘来绘制，同时也包含了图层的角。边框是绘制在图层边界里面的，且在所有的子图层或子内容前面。 borderWidth 确定了图层所绘制的边框的宽度， borderColor 则确定了图层边框的颜色。 图层阴影在很多情况下我们需要为图层绘制阴影，绘制图层阴影之需要给图层的 shadowOpacity 复制即可，该属性是一个0(不可见)-1(完全不透明)之间的浮点数。另外还可以通过其他一些图层的属性来更改阴影的一些其他效果， shadowColor ， shadowOffset 和shwdowRadius。 shadowColor 看名字我们就知道这是控制阴影颜色的属性，该属性是一个 CGColorRef 类型的属性，该属性默认的阴影颜色是黑色。 shadowOffset 属性控制着阴影的方向和距离，它是一个 CGSize 的值。 shadowRadius 是控制图层阴影边界模糊度的属性，当该属性为0的时候，图层边界和阴影之间就显得非常明显，不是很自然，当数值越大图层和阴影的边界就越自然，显得没有那么明显。 要注意的是图层的阴影是根据图层内容计算绘制出来的，并不是简单的在图层边框外绘制出阴影的。比如说如果图层中除了图层中图片显示部分有内容，其他部分是透明的，那么这个阴影将会沿着图层的显示内容来绘制，而不是沿着图层的边界绘制的。还有一点阴影在图层中是可以被 masksToBounds 属性裁剪掉的，所以在有使用 masksToBounds 属性的图层中绘制阴影的时候最好单独在创建一个图层放在图层之下来专门绘制图层的阴影，这样阴影就不会被裁剪掉。 使用 shadowPath 自定义图层阴影事实上图层的阴影是很消耗性能的，因为从上面得知图层阴影并不是固定的沿着图层的边缘绘制的，而是根据图层内容的形状计算来的。我们可以事先为图层指定阴影样式，通过对图层的 shadowPath 属性指定图层样式来提高性能。 shadowPath 是一个 CGPathRef 类型（一个指向 CGPath 的指针）。 CGPath 是一个 Core Graphics 对象，用来指定任意的一个矢量图形。可以通过这个属性单独于图层形状之外指定阴影的形状。 123456789101112131415161718192021222324252627@interface ViewController ()@property (nonatomic, weak) IBOutlet UIView *layerView1;@property (nonatomic, weak) IBOutlet UIView *layerView2;@end@implementation ViewController- (void)viewDidLoad&#123; [super viewDidLoad]; //enable layer shadows self.layerView1.layer.shadowOpacity = 0.5f; self.layerView2.layer.shadowOpacity = 0.5f; //create a square shadow CGMutablePathRef squarePath = CGPathCreateMutable(); CGPathAddRect(squarePath, NULL, self.layerView1.bounds); self.layerView1.layer.shadowPath = squarePath; CGPathRelease(squarePath); ￼//create a circular shadow CGMutablePathRef circlePath = CGPathCreateMutable(); CGPathAddEllipseInRect(circlePath, NULL, self.layerView2.bounds); self.layerView2.layer.shadowPath = circlePath; CGPathRelease(circlePath);&#125;@end 如果图层阴影的图形相当的复杂也可以使用 UIBezierPath 来为图层绘制阴影。 图层蒙版 CALayer 中有一个叫 mask 的属性，这个属性本身就是一个 CALayer 的类型。该图层就像是图层的子图层一样，我的理解应该是覆盖在父图层(该属性的拥有者)之上的图层，上面一部分代码中的 conrnerRadius 和 masksToBounds 属性就是通过对 mask 图层进行操作达到修改图层圆角率以及裁剪图层的。有很重要的一点我之前一直有错误的理解，我一直以为 mask 属性中 mask 图层透明的部分才是被保留的而实心的部分会被裁剪，然而这点和我的理解刚刚相反。 mask 图层中实心的部分会被保留显示出来，透明的部分则会被隐藏掉。 如下代码，将会把一个图层，显示成 mask 内容的形状： 1234567891011121314151617181920212223242526272829#import \"CALayerMaskViewController.h\"@interface CALayerMaskViewController ()@property (weak, nonatomic) IBOutlet UIImageView *imageView;@end@implementation CALayerMaskViewController- (instancetype)init &#123; self = [super init]; if (self) &#123; UIStoryboard *storyboard = [UIStoryboard storyboardWithName:@\"Main\" bundle:nil]; self = [storyboard instantiateViewControllerWithIdentifier:@\"MaskLayerVC\"]; &#125; return self;&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor]; self.imageView.image = [UIImage imageNamed:@\"Edison.jpg\"]; CALayer *maskLayer = [[CALayer alloc]init]; maskLayer.frame = _imageView.bounds; maskLayer.contents = (__bridge id)[UIImage imageNamed:@\"Heart\"].CGImage; _imageView.layer.mask = maskLayer; &#125; CALayer 的 mask 属性因为是 CALayer 类型，所以图层蒙版不一定局限于静态的图片的样式。任何由图层构成的都可以作为 mask 属性，这样蒙板可以通过代码甚至是动画实时生成。 组透明在 UIView 中有一个 alpha 的属性用来设置视图的透明度，同样的在 CALayer 中也有与之对应设置透明度的属性，那就是opacity。这两个属性都会对子视图或者子图层有所影响。当一个视图包含子视图的时候，去设置视图的透明度就会有所问题，比如把一个视图的透明度（alpha）设置为0.5的时候该视图的子视图透明度却不是0.5。这是因为图层的重叠透明度造成的，如果希望子视图也同样和视图透明，那么有两种方式去解决。第一种就是通过在项目的Info.plist文件中设置 UIViewGroupOpacity 属性为 YES 即可达到效果，但是这种方式会影响到整个的项目，很明显的在某些时候这个解决方式并不是最好的。第二种方式就是设置视图中图层的 shouldRasterize 属性为 YES ，设置该属性的时候一定要设置 rasterizationScale 属性以去匹配屏幕，防止视图在Retina屏幕下像素化的问题。还有一点，如果 shouldRasterize 和 UIViewGroupOpacity 同时使用会有一定的性能问题。 绘制CALayer的寄宿图CALayer 的 Contents 属性也不一定非要赋值一个寄宿图，可能有的时候我们需呀自己定义一些简单的视图，这个时候我们可以通过 Core Grapcis 直接来绘制寄宿图。通过继承 UIView 并实现 - drawRect：方法来实现自定义绘制。 在默认的情况下 - drawRect：方法是没有实现的，因为对于UIView来说寄宿图不是必须的，而且调用这个方法后系统就会为视图分配一个寄宿图，这个寄宿图的像素尺寸就是视图的尺寸大小乘以 contentsSacle 的值。该方法的调用会消耗一定的 CPU 资源，对性能造成一定的损耗，所以在没有实现自定义绘制的时候就不要去调用该方法。 在实现了- drawRect：方法后系统就会自动绘制寄宿图显示到屏幕上。但是有的时候我们需要重新绘制一个寄宿图，当然重绘也是在- drawRect：方法中来完成的，但是当添加了绘制代码后运行起来发现没有任何的效果。其实这里我们需要去手动的调用另一个方法- setNeedDisplay：，调用该方法后系统会自动调用- drawRect：方法进行重绘，为什么会这样呢？这是因为- drawRect：方法默认只会调用一次，我们重绘的时候就不回再次调用了，这个时候我们就需要调用- setNeedDisplay：来让系统自动调用- drawRect：方法来进行重绘。当然这是在 UIView 中绘制寄宿图，其实也是使用 CALayer 来完成的绘制工作，和保存绘制好的寄宿图。 我们也可以在 CALayer 中直接绘制寄宿图。CALayer 有一个可选的 delegate 属性，实现了 CALayerDelegate的协议，该协议是一个非正式协议，只需要在需要绘制的时候调用相对应的方法后 CALayer 就会自动去完成剩下的工作。当 CALayer 被绘制的时候首先会调用下面的这个代理方法，来请求获取一个寄宿图来显示： 1- (void)displayLayer:(CALayerCALayer *)layer; 在这个代理方法中我们可以给它一个已经绘制好的寄宿图。如果没有实现该方法那么 CALayer 就会继续调用下面这个方法： 1- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx; 在这个方法调用后这个方法里会生成一个空的寄宿图 layer 和一个 Core Graphics 的绘制寄宿图的上下文环境 ctx。在这个方法中我们就可以做一些绘制的工作。但是这里我们还需要显示的去调用- display方法我们绘制的寄宿图才会显示在屏幕上，这里和 UIView 的不同是当图层显示在屏幕上的时候 CALayer 不回自动重绘该内容，重绘内容是需要开发者自己去调用的。在 CALayer 中绘制寄宿的的时候超出边界的图是不回被绘制出来的。 其实在平时自定义绘制控件的时候我们一般都是不会使用 CALayer 的 delegate 去绘制控件的，一般都是在 UIView 中调用 - drawRect：方法进行绘制，UIView 会自动的把图层的代理设置为 self ，并且提供- displayLayer ：的实现，完成所有的绘制，并且在需要重绘的时候调用- display方法。 如下演示一下如何使用 CALayer 来绘制寄宿图： 1234567891011121314151617181920212223242526272829303132333435363738#import &quot;ViewController.h&quot;@interface ViewController () &lt;CALayerDelegate&gt;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; CALayer *layer = [CALayer layer]; layer.frame = CGRectMake(50, 50, 100, 100); layer.backgroundColor = [UIColor orangeColor].CGColor; layer.delegate = self; layer.contentsScale = [UIScreen mainScreen].scale; [self.view.layer addSublayer:layer]; [layer display];&#125;- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx &#123; CGContextSetLineWidth(ctx, 10.0); CGContextSetFillColorWithColor(ctx, [UIColor redColor].CGColor); CGMutablePathRef path = CGPathCreateMutable(); CGPathMoveToPoint(path, &amp;CGAffineTransformIdentity, 0, 0); CGPathAddLineToPoint(path, &amp;CGAffineTransformIdentity, 100, 100); CGPathAddLineToPoint(path, &amp;CGAffineTransformIdentity, 20, 80); CGPathCloseSubpath(path); CGContextAddPath(ctx, path); CGContextFillPath(ctx); &#125;@end 效果如下：","categories":[],"tags":[{"name":"图层","slug":"图层","permalink":"Aaronzjp.cn/tags/图层/"},{"name":"CALayer","slug":"CALayer","permalink":"Aaronzjp.cn/tags/CALayer/"},{"name":"Core Animation","slug":"Core-Animation","permalink":"Aaronzjp.cn/tags/Core-Animation/"}]},{"title":"方法调配技术（method swizzling）","slug":"Method-Swizzling","date":"2016-09-19T09:33:52.000Z","updated":"2018-11-17T06:47:23.059Z","comments":true,"path":"2016/09/19/Method-Swizzling/","link":"","permalink":"Aaronzjp.cn/2016/09/19/Method-Swizzling/","excerpt":"在前面的关于`runtime`中已经说过`OC`运行时语言，在其编译的时候就会把OC中的消息转换成一个类似于如下： id objc_msgSend ( id self, SEL cmd, ... );结构的C语言函数，在程序运行的时候程序就会根据id所对应的类，以及传入的SEL选择子在该类的方法列表中去查找相对应的方法，并执行。利用这一特点，我们可以在运行期去改变选择子名称相对应的方法，这样我们既不需要查看到源代码，又没有必要去重写子类来覆写方法就能改变类本身的功能。这样一来新功能就会在类的所有实例中表现出来，而不仅限于那些重写子类的实例。这种方案就叫做“方法调配”（method swizzling）。","text":"在前面的关于`runtime`中已经说过`OC`运行时语言，在其编译的时候就会把OC中的消息转换成一个类似于如下： id objc_msgSend ( id self, SEL cmd, ... );结构的C语言函数，在程序运行的时候程序就会根据id所对应的类，以及传入的SEL选择子在该类的方法列表中去查找相对应的方法，并执行。利用这一特点，我们可以在运行期去改变选择子名称相对应的方法，这样我们既不需要查看到源代码，又没有必要去重写子类来覆写方法就能改变类本身的功能。这样一来新功能就会在类的所有实例中表现出来，而不仅限于那些重写子类的实例。这种方案就叫做“方法调配”（method swizzling）。 类方法列表会把选择子的名称映射到相关的方法列表上，使得动态消息派发系统能够通过查找方法列表找到相对应的方法并调用。这些方法均以指针的形式表示，并存储在类的方法列表（`objc_method_list`）中，该指针就是`IMP`。 IMP的原型如下： id (*IMP)(id, SEL,...); 实现方法交换的实现方法如下： void method_exchangeImplementations(Method m1,Method m2) 这个函数有两个参数，其中这两个参数就是待交换的两个方法。 而方法的实现则可以通过以下这个方法来获得： Method class_getInstanceMethod(Class class,SEL aSelector) 此函数会根据给定的参数的类，和选择子去到方法列表中取出相应的方法。 下面用一个例子🌰来验证下： NSSrting中有两个方法，分别是lowercaseString和uppercaseString其作用时将英文字符串分别转换成小写和大写。现在用上面介绍的方法来让这两个方法交换。 12345Method originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString));Method swappedMethod = class_getInstanceMethod([NSString class], @selector(uppercaseString));method_exchangeImplementions(originalMethod, swappedMethod); 实际上这样直接交换两个方法的意义基本不大，因为他们都已经被实现得很好了，这样交换后反而引起混淆。一般会编写一个新的方法，在新的方法中实现一些附加的功能，再调用原有的实现。如下： 1234567891011- (NSString *)zjp_myLowercaseString &#123; NSString *lowercase = [self zjp_myLowercaseString] NSLog(@&quot;%@ =&gt; %@&quot;,self, lowercase); return lowercase;&#125;Method originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString));Method swappedMethod = class_getInstanceMethod([NSString class], @selector(zjp_myLowercaseString));method_exchangeImplementions(originalMethod, swappedMethod); 这样交换方法后，我们在调用这个lowercaseString时就回附加的完成我们向里面添加的方法了。会打印出被转换前和转换后的字符串。通过这样的方法我们就可以为我们不知道具体实现的方法增加日志输出的功能以便我们的程序调试。不过除了这样用以为其实还有一些好用的功能，你懂的。。。。这样后面有机会再说。","categories":[],"tags":[{"name":"runtime","slug":"runtime","permalink":"Aaronzjp.cn/tags/runtime/"}]},{"title":"runtime-消息转发机制（message forwarding）","slug":"Message-Forwarding","date":"2016-09-13T03:48:39.000Z","updated":"2018-11-24T09:35:01.000Z","comments":true,"path":"2016/09/13/Message-Forwarding/","link":"","permalink":"Aaronzjp.cn/2016/09/13/Message-Forwarding/","excerpt":"​ 上次在发送消息objc_msgSend中提到了，如果在当前的类的方法列表中如果找不到对应的选择子的方法就会执行消息转发（message forwarding），在消息的转发过程中我们就可以在程序中告诉程序应该怎样去处理这样未知的消息，可以在消息的转发过程中设置挂钩，用来执行预定的逻辑处理方式，来做到当程序中的某个类找不到对应的方法时不至于导致程序的崩溃。 ​ 其中消息转发机制详细的来划分一共分为3个部分： 动态方法解析 备援接收者 完整的消息转发","text":"​ 上次在发送消息objc_msgSend中提到了，如果在当前的类的方法列表中如果找不到对应的选择子的方法就会执行消息转发（message forwarding），在消息的转发过程中我们就可以在程序中告诉程序应该怎样去处理这样未知的消息，可以在消息的转发过程中设置挂钩，用来执行预定的逻辑处理方式，来做到当程序中的某个类找不到对应的方法时不至于导致程序的崩溃。 ​ 其中消息转发机制详细的来划分一共分为3个部分： 动态方法解析 备援接收者 完整的消息转发 动态方法解析​ 对象在收到这条无法做出响应的消息后，首先会调用所属类的如下的方法： + (BOOL)resolveInstanceMethod:(SEL)sel 当然如果这个未实现的方法不是一个实例方法，而是类方法，那么会有一个与之相对应的方法来处理： + (BOOL)resolveClassMethod:(SEL)sel 该方法的这个参数SEL就是那个未知的选择子，返回值是一个Boolean类型，如果返回YES则表示这个类为其新增了一个实例方法来处理此选择子，如果返回NO则反之。使用此方法的前提是，相关处理函数的实现代码已经实现了，只是在运行的时候动态的将该实现方法动态的插入到类就好了。（所插入添加的方法是要用C函数实现的）。 具体使用例子🌰如下： 123456789101112+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; //首先判断这个未实现的方法是不是已经实现了等待被动态插入到类的方法，这里用test作为例子 //也可以同过把选择子字符串化通过判断字符串的匹配来做处理 //NSString *selectorString = NSStringFromSelector(sel) //if ([selectorString hasPrefix:@&quot;set&quot;]) &#123;&#125;.... if (aSEL == @selector(test)) &#123; class_addMethod([self class], sel, (IMP)(已经实现的那个函数), &quot;v@:&quot;); // 动态添加方法 return YES; // 返回YES，则不会转发&#125; return [super resolveInstanceMethod:aSEL]; // 不是需要动态添加的方法，按照父类处理&#125; 这里用到了class_addMethod函数，该函数可以向类中动态地添加方法，用以处理给定的选择子。其中第一个参数是被插入方法的类，第二个参数是选择子，第三个参数是函数指针，只想待插入添加到类的方法，而最后一个参数则表示待添加方法的”类型编码”（type encoding）。 备援接收者​ 如果在动态方法解析的那一步没有对此做相关的处理，那么接下来还是可以对此作出相应的处理的。在这步中主要做的就是能不能把这个未能解读到到方法转交给其他的消息接受者来处理。该步中会在如下的方法中进行这个步骤的处理： - (id)forwardingTargetForSelector:(SEL)aSelector 具体使用例子🌰如下： 1234567- (id)forwardingTargetForSelector:(SEL)aSelector&#123; if(aSelector == @selector(test))&#123; return testObject;//返回被转交的其它的消息接受者 &#125; return [super forwardingTargetForSelector:aSelector];// 不是需要动态添加的方法，按照父类处理&#125; 只要这个方法中最后返回的不适nil和self那么整个消息发送的过程就会被重启，当然接收消息的对象就回变成这里返回的这个类。如果这里还是没有及时的处理那么就回进入到消息转发的最后一步了，进行完整的消息转发。 完整的消息转发​ 到了这一步的时候就是最后挽救未解读消息的时候，在这步首先要创建NSInvocation对象，然后把未处理的消息的所有的细节都添加到此，此对象中包含了选择子，目标，以及参数。在这里我们同样的可以改变调用目标，使消息在新目标上调用，这个就和第二步中的操作其实是等效的了。我们还可以在消息触发前对消息进行其它的修改，比如改变消息内容，增加消息的参数，更改消息的目标。如果此消息不应该由本类来处理，也可以调用超类的同名方法来处理。如果最终还是未被处理，则还是会调用doseNotRecognizeSelector，以抛出异常，表示这条消息最终未能得到处理，导致程序崩溃。 整个消息转发流程图如下：","categories":[],"tags":[{"name":"runtime​","slug":"runtime​","permalink":"Aaronzjp.cn/tags/runtime​/"}]},{"title":"iOS发送消息","slug":"objc-msgSend","date":"2016-09-08T14:23:28.000Z","updated":"2018-11-17T06:44:57.473Z","comments":true,"path":"2016/09/08/objc-msgSend/","link":"","permalink":"Aaronzjp.cn/2016/09/08/objc-msgSend/","excerpt":"`OC` 语言中，对象调用方法我们称之为发送消息，或者叫做“传递消息”（`pass a message`）。消息具有“名称”（`name`）或“选择子”（`selector`），实际上就是方法名称，可以接受参数，也可以有返回值。在 `OC` 中我们是这样发送消息的，结构如下： id retrunValue = [someObject messageName:parameter];","text":"`OC` 语言中，对象调用方法我们称之为发送消息，或者叫做“传递消息”（`pass a message`）。消息具有“名称”（`name`）或“选择子”（`selector`），实际上就是方法名称，可以接受参数，也可以有返回值。在 `OC` 中我们是这样发送消息的，结构如下： id retrunValue = [someObject messageName:parameter]; OC中的消息传递就如同上面分解出来的结构一样。其中returnValue是返回值；someObject是接受者，即调用这个方法的对象；messageName:是选择子，即方法名称；parameter是参数，即调用方法的时候传入的参数。选择子（selector）与参数（parameter）合起来就是我们称为的“消息”。在程序编译期的时候，所有类似这样的消息最终都会被转换成一条标准的C语言函数内供程序调用，其结构如下： id objc_msgSend ( id self, SEL cmd, ... ); 这是一个参数个数可变的函数，能够接收多个的参数，其中第一个参数代表接收者，第二个参数代码选择子（SEL是选择子的类型），后面其他的消息就是发送消息中所传入的参数。 讲上面的那个OC的例子转换后的原型如下： id returnValue = objc_msgSend(someObject, @selector(messageName:),parameter); 在程序运行的时候objc_msgSend函数会根据接受者和选择子在相对应的类中查找方法，在对应类中有一个“方法列表”如果能找到对应的方法就执行此方法，若不能就沿着继承体向上父类继续查找，如果最终还是找不到相对应的方法就会执行“消息转发（message forwarding）”。 在调用方法的时候执行的步骤很多，但是`objc_msgSend`会将匹配到的方法列表中的方法缓存起来，其缓存在一个叫“快速映射表”里面。每一个类都有这样的一块缓存，在该类下次再执行相同的消息的时候就会优先从“快速映射表”中查找，而选择子就是查找方法时所用到的键。 objc_object, objc_class 以及 Ojbc_method在OC中，类，对象和方法其实都是一个C的结构体，这点我忙在objc/objc.h和runtime.h的文件中就能找到他们的定义。 1234567891011121314151617181920212223242526272829#if !OBJC_TYPES_DEFINED/// An opaque type that represents an Objective-C class.typedef struct objc_class *Class;/// Represents an instance of a class.struct objc_object &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;;/// A pointer to an instance of a class.typedef struct objc_object *id;#endifstruct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endiftypedef struct objc_method *Method; objc_object实际上是一个指向 Class 结构体类型的指针，指向对象的类，而 Class 中也有一个 isa 指针，指向了元类，元类中则存储了该类的方法列表objc_method_list。 objc_method_list 本质是一个有 objc_method 元素的可变长度的数组。一个 objc_method 结构体中有函数名，也就是SEL，有表示函数类型的字符串，以及函数的实现IMP。 objc_class就是前面说到的被objc_object中那个 isa 指针所指向的 Class 的类了。这个objc_class其实是一个结构体，其中在这个结构体中就包含了很多这个类的信息。其中就包括了上文中提到的储存这个类中当前方法的链表objc_method_list和储存这个类中被执行过的方法的缓存objc_cache等相关的信息。 总结那么总结来说当在代码中写下一个 OC 语言发送的消息后，那么这条 OC 语言的消息首先经过编译器，就会被编译器转换成这样类似结构的一条 C 语言函数： id objc_msgSend ( id self, SEL cmd, ... ); 举个例子🌰： objc_msgSend(dog,@selector(eat:),) 1.首先这个函数就会根据传入的dog这个类的 isa 指针找到他的 class即objc_class 2.在 class 中找到这个类的所有的相关信息 3.然后会首先的从 class 中的objc_cache去查找eat 方法 4.如果在objc_cache中没有找到 eat 这个方法，则说明 eat 方法没有被执行过，在缓存中没有 5.然后进一步到这个类中的objc_method_list中找和选择器中对应的方法eat 6.如果在 class 中没有找到相关的方法，则会继续向上查找，在父类（super_class）中去找相对应的方法 7.一旦找到这个方法，就去执行它的实现 IMP。 但是如果最终一直都没有找到 eat 这个相对应的方法呢？通常程序就会crash并抛出异常，但是在抛出异常前首先会执行消息转发，关于消息转发的相关学习和笔记我将会在下一篇的博客中整理出来。","categories":[],"tags":[{"name":"runtime","slug":"runtime","permalink":"Aaronzjp.cn/tags/runtime/"}]},{"title":"iOS-对象关联","slug":"Associated-Object","date":"2016-08-18T10:35:51.000Z","updated":"2017-07-27T02:57:42.000Z","comments":true,"path":"2016/08/18/Associated-Object/","link":"","permalink":"Aaronzjp.cn/2016/08/18/Associated-Object/","excerpt":"关联对象就是给某个对象关联一些其他的对象，这些被关联的对象通过键（key）来区分管理。比如： 有一个Person类，Aaron是这个Person类的实例也就是对象。现在又增加了一个Car类，且有一个Audi的实例，我们需要给Aaron实例增加关联一辆Audi车。显然常规的做法是把Car类作为属性添加到Aaron中，但是在有的某些特殊的情况下我们无法对Aaron这个实例直接进行操作，也无法通过继承去操作，那么这个时候就可以用关联对象来解决这个问题了。","text":"关联对象就是给某个对象关联一些其他的对象，这些被关联的对象通过键（key）来区分管理。比如： 有一个Person类，Aaron是这个Person类的实例也就是对象。现在又增加了一个Car类，且有一个Audi的实例，我们需要给Aaron实例增加关联一辆Audi车。显然常规的做法是把Car类作为属性添加到Aaron中，但是在有的某些特殊的情况下我们无法对Aaron这个实例直接进行操作，也无法通过继承去操作，那么这个时候就可以用关联对象来解决这个问题了。 怎么关联对象如何关联对象？苹果早就为我们提供了关联对象的方法： //通过设置键（key）和关联对象以及被管理对象和内存关联类型来关联对象 void objc_setAssociatedObject(id object, void *key, id value, objc_AssociationPolicy policy) //从对应的键（key）获取相对应的关联对象 id objc_getAssociatedObject(id object, void *key) //移除指定对象的全部关联对象。一般不这样做，因为会移除所有的关联对象，如不需要的时候只要关联对象为nil即可 void objc_removeAssociatedObjects(id object) 参数说明： id object ：被关联的对象 const void *key ：被关联对象的键（key）此键是一个不透明的指针，即该指针指向的数据不局限于某种特定的类型 id value ： 关联的对象 objc_AssociationPolicy policy : 内存管理策略 objc_AssociationPolicy policy是一个枚举值，其中每一个枚举值对应了关联对象的存储策略，其中如果与其@property对应的策略如下： 关联类型 与之等效的@property属性 OBJC_ASSOCIATION_ASSIGN assign OBJC_ASSOCIATION_RETAIN_NONATOMIC nonatomic,retain OBJC_ASSOCIATION_COPY_NONATOMIC nonatomic,copy OBJC_ASSOCIATION_RETAIN retain OBJC_ASSOCIATION_COPY copy 关联对象的使用如在当前控制器需要弹出一个AlertView，但是在有很多这样的信息要处理的时候，代码就会显得很乱。但是我们在创建alertView的时候就把每个按钮点击后的事件写好就看起来简洁多了。 123456789101112131415161718192021222324252627282930313233343536373839404142#import &quot;ViewController.h&quot;#import &lt;objc/runtime.h&gt;static void *AlertViewTest = &quot;AlertViewTest&quot;;@interface ViewController () &lt;UIAlertViewDelegate&gt;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib.&#125;- (IBAction)alertViewClicked:(UIButton *)sender &#123; UIAlertView *alertView = [[UIAlertView alloc]initWithTitle:@&quot;AlertView弹出&quot; message:@&quot;对象关联的练习&quot; delegate:self cancelButtonTitle:@&quot;取消&quot; otherButtonTitles:@&quot;确定&quot;, nil]; //block,点击后处理的block void (^alertViewClicked) (NSInteger) = ^(NSInteger buttonIndex) &#123; NSLog(@&quot;你点击了第 %ld 个按钮&quot;,buttonIndex); &#125;; //把block关联到alertView中 objc_setAssociatedObject(alertView, AlertViewTest, alertViewClicked, OBJC_ASSOCIATION_COPY); [alertView show]; &#125;- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex &#123; //从alertView中获取被关联的block void (^alertViewClicked) (NSInteger) = objc_getAssociatedObject(alertView, AlertViewTest); //调用block，以来处理alertView按钮被点击后的响应 alertViewClicked(buttonIndex);&#125;@end 关联对象的介绍和用法大致就是这样，虽然使用起来很方便，好用。但是在项目中我觉得还是尽量避免使用这样的方法，因为对象关联频繁大量的使用会对项目后期的调试和维护造成困难，一旦这里出现问题就会很难再bug查找调试中找到问题所在。","categories":[],"tags":[{"name":"runtime","slug":"runtime","permalink":"Aaronzjp.cn/tags/runtime/"}]},{"title":"iOS网络编程NSURLConnection／NSURLSession","slug":"iOS-NetWork-Programming-NSURLConnectionAndNSURLSession","date":"2016-08-11T04:16:49.000Z","updated":"2017-07-27T02:56:59.000Z","comments":true,"path":"2016/08/11/iOS-NetWork-Programming-NSURLConnectionAndNSURLSession/","link":"","permalink":"Aaronzjp.cn/2016/08/11/iOS-NetWork-Programming-NSURLConnectionAndNSURLSession/","excerpt":"iOS网络编程是最基础常用的知识，可以说是从开始学习iOS的时候就应该要必备的基础知识。但是平常在项目中都使用比较成熟的第三方网络请求的框架（比如：AFNetworking）来替代了苹果官方所提供的网络请求API，对苹果提供的API相关的东西就逐渐的忽略了。为了理解其相关知识和原理，所以对这块知识复习一下，顺便整理成博客。","text":"iOS网络编程是最基础常用的知识，可以说是从开始学习iOS的时候就应该要必备的基础知识。但是平常在项目中都使用比较成熟的第三方网络请求的框架（比如：AFNetworking）来替代了苹果官方所提供的网络请求API，对苹果提供的API相关的东西就逐渐的忽略了。为了理解其相关知识和原理，所以对这块知识复习一下，顺便整理成博客。 目前在iOS的Foundation框架中提供的原生的网络访问类主要由两个，NSURLConnection 和 NSURLSession ，其中 NSURLConnection 是在2003年从 iOS 2.0+ 随着Safari的发布就发布了，NSURLSession 是从 iOS 7.0+ 出现的，其目的就是作为NSURLConnection 的替换，但是目前来说 NSURLConnection 还是不能完全的被替换的，NSURLSession 总的来说作为 NSURLConnection 的替换来说，对比 NSURLConnection 还是有很多优化的。NSURLSession 针对下载／上传，断点续传，后台下载等提供了专门的解决方案。 网络请求方法（GET／POST）网络请求这里就要说到 HTTP／HTTPS 网络协议，该协议规定了网络通信的一些标准，用于客户端和服务器之间的通信。后者 HTTPS 是基于 HTTP 协议进行一层加密后的网络协议，所传输的数据都是经过加密，相对于 HTTP 来说要安全。 使用 HTTP／HTTPS 协议客户端和服务器进行数据传输，首先客户端会向服务器发送请求，在服务器收到客户端的请求后再将客户端请求的数据返回给客户端。请求的方法有如下几种： 方法 描述 GET 从指定的资源请求数据。 POST 向指定的资源提交要被处理的数据。 HEAD 与 GET 相同，但只返回 HTTP 报头，不返回文档主体。 PUT 上传指定的 URI 表示。 DELETE 删除指定资源。 OPTIONS 返回服务器支持的 HTTP 方法。 CONNECT 把请求连接转换到透明的 TCP/IP 通道。 其中常用的就是 GET 和 POST 方法。 GET 请求是将数据拼接在 URL 之后发起的明文数据请求，也就是说该请求可以很明显的在 URL 中看到请求时发送给服务器的数据，而且 GET 请求时提交的数据是有长度限制的。所以 GET 请求一般用来单纯的从服务器取回数据，或者提交一些无关紧要的数据给服务器。其实当浏览网站的时候，我们在网址栏输入的网址就是一种 GET 请求，通过该请求从服务器取回网页数据，然后通过浏览器解析渲染然后显示在浏览器窗口。 POST 请求是将数据放在请求体中发出的请求，相对于 GET 请求来说更加安全，且 PSOT 请求提交的数据是没有长度限制的。POST 相对于 GET 请求更加适合用来向服务器提交数据。 NSURLConnection 使用步骤NSURLConnection 的一般使用步骤如下： 1.NSURL，网络请求地址，即待请求的网络资源的路径。（URL相关的可查看网络协议） 2.设置请求，NSURLRequest／NSMutableURLRequest。主要是用 NSMutableURLRequest ，因为 NSURLRequest 一旦初始化完成后就无法修改了。 3.连接到网络，发起网络请求。在苹果提供的 API 中已经对网络请求做了同步请求和异步请求的支持，同步请求会阻塞当前线程，而异步则不会，异步请求中请求的回调方式分为 Block 和 Delegate 两种方式。 4.接收请求到的数据 5.对请求到的数据进行解析处理等 NSURLConnection 的使用POST 同步请求：1234567891011121314151617181920//URL网络资源请求位置NSString *webLocation = @&quot;http://v.juhe.cn/todayOnhistory/queryEvent.php&quot;;NSString *parametersString = [NSString stringWithFormat:@&quot;date=%@&amp;key=%@&quot;,date,appKey];NSURL *url = [NSURL URLWithString:webLocation];//设置请求，请求地址、缓存方式、请求超时时间NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:60];//设置请求方法,默认为GET[request setHTTPMethod:@&quot;POST&quot;];//POST请求参数，设置在请求体中[request setHTTPBody:[parametersString dataUsingEncoding:NSUTF8StringEncoding]];//用于接收服务器的响应和请求错误。NSHTTPURLResponse *response;NSError * error = nil;//发送同步网络请求NSData *data = [NSURLConnection sendSynchronousRequest:request returningResponse:&amp;response error:&amp;error];//解析JSON数据，转换成Dictionary// NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil];NSString *string = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];[self showAlertWith:string]; 上面也提到了，网络请求API，NSURLConnection、NSURLSession等已经针对网络请求做了线程的处理。上面这段代码发起的是一个同步请求，也就是说该请求会阻塞住线程直到网络请求完成才会进一步的做其他的处理，所以同步请求是无法取消的。 GET 同步请求：GET 和 POST 请求其实在使用上步骤基本是一样的，在没有对 NSURLRequest／NSMutableURLRequest 请求方法做显示的设置的时候默认发起的网络请求是 GET 请求。 123456789101112131415//URL网络请求地址，以及请求提交的数据NSString *webLocation = [NSString stringWithFormat:@&quot;http://v.juhe.cn/todayOnhistory/queryEvent.php?date=%@&amp;key=%@&quot;,date,appKey];NSURL *url = [NSURL URLWithString:webLocation];//设置请求，请求地址、缓存方式、请求超时时间NSMutableURLRequest *request = [[NSMutableURLRequest alloc]initWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:60];//设置请求方式。默认就时GET请求，可以不要下面这段代码// [request setHTTPMethod:@&quot;GET&quot;];//用于接收服务器的响应和请求错误。NSHTTPURLResponse *response;NSError * error = nil;//发起请求NSData *data = [NSURLConnection sendSynchronousRequest:request returningResponse:&amp;response error:&amp;error];NSString *str = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];[self showAlertWith:str]; GET 异步请求 （Block回调方式）在上面的使用步骤中提到异步请求可以分为两种回调方式，Block 和 Delegate。这两种方式在 GET 和 POST 请求中使用基本都是一样的，所以就不分别在 GET 和 POST 中一一举例了，主要在回调方式上作出两个例子。 12345678910111213NSString *webLocation = [NSString stringWithFormat:@&quot;http://v.juhe.cn/todayOnhistory/queryEvent.php?date=%@&amp;key=%@&quot;,date,appKey]; NSURL *url = [NSURL URLWithString:webLocation];NSMutableURLRequest *request = [[NSMutableURLRequest alloc]initWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:60];// [request setHTTPMethod:@&quot;GET&quot;];// 发起网络请求，并通过block回调接收请求到的数据，并展示出来[NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) &#123; NSString *string = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]; __weak NetworkRequestViewController *weakSelf = self; [weakSelf showAlertWith:string];&#125;]; POST 异步请求（Delegate回调方式）Delegate 方式可以监控请求进度以及数据接收详情，所以 Delegate 方式也常常用来下载比较大的数据。数据较大的时候也可以通过一些方式支持断点续传等。这就是 Delegate 回调方式的好处吧。下面的例子将简单的实现下载一个短视频的功能，并可以暂停下载的功能。首先添加如下属性： 12345678@property (nonatomic,strong) NSMutableData *returnDataInfo;@property (nonatomic,strong) NSURLConnection *connection;@property (nonatomic,assign) NSUInteger totalSize;@property (nonatomic,copy) NSString *filmName;@property (nonatomic,assign) NSUInteger currentSize;@property (nonatomic,strong) NSFileHandle *handle;@property (weak, nonatomic) IBOutlet UIProgressView *progressView;@property (weak, nonatomic) IBOutlet UIButton *downloadButton; 在使用代理回调的时候首先要遵守两个协议，NSURLConnectionDelegate,NSURLConnectionDataDelegate。 123456789101112131415NSString *mp4WebLocation = @&quot;http://120.25.226.186:32812/resources/videos/minion_01.mp4&quot;;NSURL *url = [NSURL URLWithString:mp4WebLocation];//初始化一个请求NSMutableURLRequest *request = [[NSMutableURLRequest alloc]initWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:60]; //谁请求头参数，即下载文件开始结束的位置/*bytes=0-100下载文件数据的范围，-前面的数字是开始的位置，-后面的数字是结束的位置、不指定即为下载到完成*/NSString *range = [NSString stringWithFormat:@&quot;bytes=%zd-&quot;,self.currentSize];[request setValue:range forHTTPHeaderField:@&quot;Range&quot;]; //发送请求，并设置请求代理self.connection = [NSURLConnection connectionWithRequest:request delegate:self]; 在发送请求后主要在如下的三个代理方法中管理下载进度以及接收数据，存储数据的处理： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#pragma mark - Connection Delegate- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response &#123; if (connection == self.connection) &#123; //一定要做此判断，否则在暂停下载后再此下载时会出错，创建新的文件句柄，文件会损坏。 if (self.currentSize &gt; 0) &#123; return; &#125; else &#123; //获取将要下载的文件的总大小 self.totalSize = response.expectedContentLength; //获取要下载文件的文件名 self.filmName = response.suggestedFilename; //设置文件存储地址 NSString *path = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)lastObject]; NSString *fullPath = [path stringByAppendingPathComponent:_filmName]; NSLog(@&quot;%@&quot;,fullPath); //创建一个空文件在改地址，第一个参数是文件的地址，第二个参数是文件内容，第三个参数是文件属性 [[NSFileManager defaultManager]createFileAtPath:fullPath contents:nil attributes:nil]; //创建一个文件句柄 self.handle = [NSFileHandle fileHandleForWritingAtPath:fullPath]; &#125; &#125; else &#123; self.returnDataInfo = [[NSMutableData alloc]init]; NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)response; NSLog(@&quot;%ld&quot;,(long)httpResponse.statusCode); NSLog(@&quot;%@&quot;,httpResponse.allHeaderFields); &#125; &#125;- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data &#123; if (connection == self.connection) &#123; //移动文件句柄到文件末尾 [self.handle seekToEndOfFile]; //通过文件句柄写入文件 [self.handle writeData:data]; //计算当前下载到数据长度 self.currentSize += data.length; //当前下载文件的百分比 self.progressView.progress = (double) self.currentSize / self.totalSize; &#125; else &#123; [_returnDataInfo appendData:data]; &#125;&#125;- (void)connectionDidFinishLoading:(NSURLConnection *)connection &#123; //数据请求完毕 if (connection == self.connection) &#123; //关闭文件句柄 [self.handle closeFile]; //句柄设置为nil self.handle = nil; [self.downloadButton setSelected:NO]; [self.downloadButton setTitle:@&quot;下载完成&quot; forState:UIControlStateNormal]; &#125; else &#123; NSString *string = [[NSString alloc]initWithData:_returnDataInfo encoding:NSUTF8StringEncoding]; [self showAlertWith:string]; _returnDataInfo = nil; &#125;&#125;#pragma mark - Connection DataDelegate- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error &#123; NSLog(@&quot;数据请求失败!&quot;);&#125; NSURLSession 介绍前面也提到了 NSURLSession 是用来替换 NSURLConnection 的，那么 URLSession 肯定比 NSURLConnection 更加方便，强大，以及灵活。NSURLSession 对于 NSURLConnection 最大的改变就是可以灵活的单独配置给个 Session 的缓存，协议，cookie，以及证书策略。NSURL 主要可以分为三大块，NSURLSession、NSURLSessionConfiguration、NSURLSessionTask。 NSURLSeesionTask该类下有四个子类，分别是 NSURLSessionDataTask、NSURLSessionDownloadTask、NSURLSessionUploadTask、NSURLSessionStreamTask，通过名字我想也能大概知道这四个子类主要的区别和使用场景。 NSURLSessionDataTask，从服务器请求数据，并返回 NSData 类型的数据。主要用于GET、POST的网络请求 NSURLSessionDownloadTask，从服务器请求数据，并临时存储在内存中，当下载结束会返回一个临时的文件路径。主要用于从服务器下载文件，或者针对数据比较大的下载请求。 NSURLSessionUploadTask，上传数据到服务器，但是也会返回相应的数据，所以该类是继承于 NSURLSessionDataTask 的。主要用来上传文件到服务器，或者上传大量的数据到服务器端。 NSURLSessionStreamTask，建立一个TCP / IP连接的主机名和端口或一个网络服务对象。 NSURLSession 的使用NSURLSessionDataTask：首先通过 NSURLSession 创建一个 GET 请求： 12345678910111213141516171819202122232425262728//网络地址NSString *webLocation = [NSString stringWithFormat:@&quot;http://v.juhe.cn/todayOnhistory/queryEvent.php?date=%@&amp;key=%@&quot;,date,appKey];//创建网络地址URLNSURL *url = [NSURL URLWithString:webLocation];//创建请求NSURLRequest *request = [NSURLRequest requestWithURL:url];//获得 iOS 提供的共享 Session 单例NSURLSession *session = [NSURLSession sharedSession];//通过 request 创建任务NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; NSString *str = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]; [self showAlertWith:str]; &#125;);&#125;];//开始任务[task resume]; /* 也可以直接通过 URL 创建任务.....通过 URL 直接创建的请求，就相当于一个默认的 GET 请求，这只是一种快捷的方式*／// NSURLSessionDataTask *task2 = [session dataTaskWithURL:url completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;// dispatch_async(dispatch_get_main_queue(), ^&#123;// NSString *str = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];// [self showAlertWith:str];// &#125;);// &#125;];// [task2 resume]; 上面使用 NSURLSessionDataTask 创建了一个 GET 请求，POST 请求就和上面 NSURLConnection 中创建 POST 请求的方法一样，使用 request.HTTPMethod = @&quot;POST&quot;; 或者使用相应的 Set 方法也可以，设置请求体也是类似 [request setHTTPBody:[parametersString dataUsingEncoding:NSUTF8StringEncoding]];。NSURLSession 和 NSURLConnection 区别就是 NSURLSession 是没有同步请求的，NSURLSession 的请求都是异步执行的，当数据请求完毕回调更新 UI 的时候需要回到主线程进行进一步的操作。 NSURLSessionDownloadTask：NSURLSessionDownloadTask 和 NSURLConnection 一样，下载文件有两种回调方式，一种是 Block 一种是 Delegate 方式。这两种方式差别也和 NSURLConnection 的差别是差不多的，这里的 Block 方式无法监控下载进度，当下载完成的时候会直接返回一个下载完成的临时文件的路径。具体使用如下： 12345678910111213NSString *mp4WebLocation = @&quot;http://120.25.226.186:32812/resources/videos/minion_01.mp4&quot;;NSURL *url = [NSURL URLWithString:mp4WebLocation];NSURLRequest *request = [NSURLRequest requestWithURL:url];NSURLSession *session = [NSURLSession sharedSession];NSURLSessionDownloadTask *task = [session downloadTaskWithRequest:request completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; NSLog(@&quot;下载完成，地址为：%@&quot;,location); NSString *path = @&quot;/Users/aaron/Desktop&quot;; NSString *fileName = response.suggestedFilename; NSString *fullPath = [path stringByAppendingPathComponent:fileName]; NSFileManager *fileManager = [NSFileManager defaultManager]; [fileManager copyItemAtURL:location toURL:[NSURL fileURLWithPath:fullPath] error:nil];&#125;];[task resume]; Delegate 方式的回调则可以监控下载进度等，也可以进行断点续传。在 NSURLSession 使用断点续传就要比在 NSURLConnection 中要简单一点，只需要在暂停的时候保存暂停时返回的数据，在继续下载的时候传入暂停时已经下载的数据即可。 首先添加如下几个属性和全局变量并遵守NSURLSessionDelegate代理： 1234567891011@interface NetworkRequestViewController ()&lt;NSURLSessionDelegate&gt;@property (weak, nonatomic) IBOutlet UIProgressView *progressView2;@property (weak, nonatomic) IBOutlet UIButton *downloadButton2;@end@implementation NetworkRequestViewController &#123; NSURLSession *_seesion2; NSURLSessionDownloadTask *_task2; NSData *_data2; NSURLRequest *_request2;&#125; 发起数据下载，或者暂停下载以及继续下载： 12345678910111213141516171819if (sender.isSelected) &#123; [_task2 cancelByProducingResumeData:^(NSData * _Nullable resumeData) &#123; _data2 = resumeData; &#125;]; sender.selected = !sender.selected;&#125; else &#123; if (!_data2) &#123; NSString *mp4WebLocation = @&quot;http://120.25.226.186:32812/resources/videos/minion_01.mp4&quot;; NSURL *url = [NSURL URLWithString:mp4WebLocation]; _request2 = [NSURLRequest requestWithURL:url]; NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration]; _seesion2 = [NSURLSession sessionWithConfiguration:config delegate:self delegateQueue:[NSOperationQueue mainQueue]]; _task2 = [_seesion2 downloadTaskWithRequest:_request2]; &#125; else &#123; _task2 = [_seesion2 downloadTaskWithResumeData:_data2]; &#125; [_task2 resume]; sender.selected = !sender.selected;&#125; 在代理方法种监控下载进度，以及UI的更新 123456789101112- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location &#123; NSLog(@&quot;下载完成，地址为：%@&quot;,location); NSString *path = @&quot;/Users/aaron/Desktop&quot;; NSString *fileName = @&quot;小黄人.mp4&quot;; NSString *fullPath = [path stringByAppendingPathComponent:fileName]; NSFileManager *fileManager = [NSFileManager defaultManager]; [fileManager copyItemAtURL:location toURL:[NSURL fileURLWithPath:fullPath] error:nil];&#125;- (void)URLSession:(NSURLSession *)session downloadTask:(nonnull NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite &#123; self.progressView2.progress = (double)totalBytesWritten/totalBytesExpectedToWrite;&#125; NSURLSessionUploadTask：NSURLSessionUploadTask 的使用方法目前先记录下大概的使用方式，因为具体的我这里现在也没有可以用的 API 来使用以及测试。使用方式如下： 12345678910111213NSURL *URL = [NSURL URLWithString:@&quot;http://example.com/upload&quot;];NSURLRequest *request = [NSURLRequest requestWithURL:URL];NSData *data = ...;NSURLSession *session = [NSURLSession sharedSession];NSURLSessionUploadTask *uploadTask = [session uploadTaskWithRequest:request fromData:data completionHandler: ^(NSData *data, NSURLResponse *response, NSError *error) &#123; // ... &#125;];[uploadTask resume]; NSURLSessionConfigurationNSURLSessionConfiguration 对象是用来对 NSURLSession 进行初始化配置的，NSURLSessionConfiguration 是对以前 NSMutableURLRequest 所提供的网络请求的设置进行扩充，可以指定可用网络，cookie，安全性，缓存策略，甚至是使用自定义协议。 使用 NSURLSessionConfiguration 来初始化 NSURLSession 的时候，NSURLSession 的对象会把用来初始化的 NSURLSessionConfiguration 对象进行 copy 并保存到自己的一个只读属性中去，所以一旦 Session 初始化完成后，他的 Configuration 就是不能被修改的。 创建NSURLSessionConfiguration在常规的使用情况下，我们可以使用如下的三个类方法来创建一个 NSURLSessionConfiguration 对象，从这三个类方法中也可以看出基本上是满足平常的需求的。 + defualtSessionConfiguration; 返回一个常规的 configuration 对象。 + ephemeralSessionConfiguration; 返回一个预设的配置，该配置不会对缓存，Cookies，和证书进行缓存。 + backgroundSessionConfiguration:(NSString *)identifier; 返回一个后台配置，后台配置和其他不同的是，在后台配置下的 Session 可以在应用程序挂起，退出或者崩溃的情况下运行上传和下载任务。初始化时指定的标识符可以用来恢复对这个 Session 的操作。 基本配置NSURLSessionConfiguration 的配置属性太多了，下面会说一些常用的基本的配置，其他的属性详情可以查看苹果官方文档的描述 HTTPAdditionalHeaders 可以设置设置请求的数据头，如请求的内容类型，语言，用户代理和身份认证等。 allowsCellularAccess 是否允许使用蜂窝网进行数据传输，其默认的是 YES timeoutIntervalForRequest 和 timeoutIntervalForResource 分别用于指定请求超时的时间和资源超时的时间 HTTPMaximumConnectionsPerHost 用于指定链接到指定主机的最大数量，在MacOS中默认为6，iOS中默认为4 connectionProxyDictionary 指定 Session 连接中的代理服务器 sharedContainerIdentifier 指定一个共享容器标识符，该属性主要用于App Extension（如Weight）开发中 Session 共享的处理。 Cookie 策略 HTTPCookieStorage 存储了 session 所使用的 cookie。默认情况下会使用 NSHTTPCookieShorage 的 +sharedHTTPCookieStorage; 这个单例对象 HTTPCookieAcceptPolicy 决定了什么情况下 session 应该采用服务器的 cookie HTTPShouldSetCookies BOOL属性，用于指定什么时候请求应该使用 Session 存储的 cookie，即 HTTPCookieSorage 属性的值 安全策略 TLSMaximumSupportedProtocol 和 TLSMinimumSupportedProtocol 确定 session 是否支持 SSL 协议，设置 SSL 协议支持的版本 URLCredentialStorage 存储了 session 所使用的证书。默认情况下会使用 NSURLCredentialStorage 的 +sharedCredentialStorage; 这个单例对象 缓存策略 URLCache 设置 session 使用缓存。默认情况下会使用 NSURLCache 的 +sharedURLCache 这个单例对象，在 ephemeralSession 中默认是 nil ，在 backgroundSession 中默认是私密存储在内存中的，当 Session 失效的时候就会被销毁 requestCachePolicy 指定了一个请求的缓存响应应该在什么时候返回 自定义协议 protocolClasses 用来配置特定某个 session 所使用的自定义协议（该协议是 NSURLProtocol 的子类）的数组。 总结本篇文章就主要回顾一下这块内容，在常用开发中使用的一些关于网络请求的知识，当然这块肯定也是没有太详细的讲解，一些其他不常用的基本没有说到，如果想了解得更加的全面，还是去翻阅苹果官方文档。上面讲到的这些东西其实在苹果的官方文档中都有全面的讲解。","categories":[],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"Aaronzjp.cn/tags/网络编程/"}]},{"title":"iOS10 权限Crash问题","slug":"iOS10-CrashOfPermission","date":"2016-08-09T03:22:30.000Z","updated":"2017-07-27T02:56:10.000Z","comments":true,"path":"2016/08/09/iOS10-CrashOfPermission/","link":"","permalink":"Aaronzjp.cn/2016/08/09/iOS10-CrashOfPermission/","excerpt":"​ 手机升级iOS10beat版本后，公司项目在真机上测试出现了崩溃的现象。一打开App就Crash了，一开始还不太确定问题，以为是项目本身代码的问题。找了半天，后来居然在控制台的输出中找到了问题（控制台输出的内容太多了不好找啊😂）。 ​ 控制台输出的信息如下：","text":"​ 手机升级iOS10beat版本后，公司项目在真机上测试出现了崩溃的现象。一打开App就Crash了，一开始还不太确定问题，以为是项目本身代码的问题。找了半天，后来居然在控制台的输出中找到了问题（控制台输出的内容太多了不好找啊😂）。 ​ 控制台输出的信息如下： ​ This app has crashed because it attempted to access privacy-sensitive data without a usage description. The app’s Info.plist must contain an NSPhotoLibraryUsageDescription key with a string value explaining to the user how the app uses this data. ​ 大概的意思就是说你需要在项目文件的info.plist中去添加相关权限的请求描述。 ​ 解决方式： ​ 1.在项目文件中找到info.plist文件，用Xcode 打开。 ​ 2.在该文件中添加相对应的权限的key以及请求时的文字描述。 以通讯录权限为例： 12&lt;key&gt;Contacts Usage Description&lt;/key&gt;&lt;string&gt;此 App 需要您的同意才能获取联系人&lt;/string&gt; 需要注意的是key不能写错了，具体Crash的原因什么权限没有添加可以从控制台的输出信息中找到，找到后添加相关权限请求的key和描述就可以了。","categories":[],"tags":[{"name":"疑难杂症","slug":"疑难杂症","permalink":"Aaronzjp.cn/tags/疑难杂症/"}]},{"title":"UINavigationBar","slug":"UINavigationBar","date":"2016-05-31T10:31:30.000Z","updated":"2018-11-24T09:36:48.114Z","comments":true,"path":"2016/05/31/UINavigationBar/","link":"","permalink":"Aaronzjp.cn/2016/05/31/UINavigationBar/","excerpt":"NavigationBar 是在大多数App中很常见的一个控件，它总是显示在 App 窗口的顶部，其作用就是用来显示当前视图的层级。 NavigationBar 主要包含了这样几个部分，left(back) Button 、 CenterTitle 、 RightButton。如下图：","text":"NavigationBar 是在大多数App中很常见的一个控件，它总是显示在 App 窗口的顶部，其作用就是用来显示当前视图的层级。 NavigationBar 主要包含了这样几个部分，left(back) Button 、 CenterTitle 、 RightButton。如下图： 大多数时候 NavigationBar 都是使用在 UINavigationController 中的，由 NavigationController 来管理和显示 NavigationBar 的。当然 NavigationBar 也可以单独的使用。当在 NavigationController 中使用 NavigationBar 的时候，NavigationController 会自动管理 NavigationBar 的状态，这时候 NavigationBar 的 Title 默认为当前控制器的 Title 。也可以自己去手动的修改，在 NavigationController 中修改 NavigationBar 直接通过 NavigationController 上的属性 NavigationBar 就可以修改的。 NavigationBar的使用其实 NavigationBar 是很少单独使用的，但是不排除某些时候需要单独的去创建一个 NavigationBar 然后去自己管理。所以还是在这里写一下，以免到时候需要用到我又得到处去翻资料。 向 UINavigationBar 的栈顶压入新的 UINavigationItem 使用如下方法： 1- (void)pushNavigationItem:(UINavigationItem *)item animated:(BOOL)animated; 向 NavigationBar; 使 UINavigationBar 出栈，使用如下方法，该方法会返回出栈的 Item ： 1- (nullable UINavigationItem *)popNavigationItemAnimated:(BOOL)animated; 除了使用上面的方法添加 Items 以外还可以通过 items 属性以及如下方法添加 UINavigationItem 到 UINavigationBar： 1- (void)setItems:(nullable NSArray&lt;UINavigationItem *&gt; *)items animated:(BOOL)animated; NavigationBar代理： 12345678910111213141516//是否 push 该 Item- (BOOL)navigationBar:(UINavigationBar *)navigationBar shouldPushItem:(UINavigationItem *)item &#123; return YES;&#125;//Item push 后到回调- (void)navigationBar:(UINavigationBar *)navigationBar didPushItem:(UINavigationItem *)item &#123;&#125;//是否 pop 该 Item- (BOOL)navigationBar:(UINavigationBar *)navigationBar shouldPopItem:(UINavigationItem *)item &#123; return YES;&#125;//Item pop后到回调- (void)navigationBar:(UINavigationBar *)navigationBar didPopItem:(UINavigationItem *)item &#123;&#125; 通过 UINavigationBar 的代理可以很方便的管理 UINavigationBar 中 items 的进栈和出栈。 UINavigationBar 中 items 的进栈和出栈示意图： 自定义UINavigationBar的外观了解如下属性后，就可以通过这些属性来设置自己满意的 UINavigationBar 了。 barStyle： UINavigationBar 的样式，可供选择的有两种白色(UIBarStyleDefault)和黑色(UIBarStyleBlack) translucent： UINavigationBar 是否半透明，默认为 YES barTintColor： 通过此属性可以设置 UINavigationBar 的背景色 tintColor： 这里是修改 UINavigationBar 中 UINavigationItem 的颜色，包括 Item 中图片和标题的颜色。(该属性是 iOS 7.0 后新增的一个属性，凡是继承于 UIView 的试图都有该属性)。 titleTextAttributes：该属性可以设置标题的颜色，其实除了颜色意外还可以设置字体阴影、背景色等等和字符相关的。使用如下： 1_bar.titleTextAttributes = @&#123;NSForegroundColorAttributeName:[UIColor redColor]&#125;; 除了可以更改标题的颜色外还可以更改标题垂直位置，使用以下方法即可： 1- (void)setTitleVerticalPositionAdjustment:(CGFloat)adjustment forBarMetrics:(UIBarMetrics)barMetrics; 修改返回按钮图标通过这两个属性可以修改返回按钮的图标： backIndicatorImage 返回按钮图标 backIndicatorTransitionMaskImage 返回按钮图标遮罩 需要注意的是要同时设置这两个属性才能修改返回按钮的图标 NavigationBar颜色和标题如下图所示： 为 NavigationBar 设置背景图片以及阴影图片： 使用该方法可以为 UINavigationBar 设置背景图片，调整图片位置等等 1- (void)setBackgroundImage:(nullable UIImage *)backgroundImage forBarPosition:(UIBarPosition)barPosition barMetrics:(UIBarMetrics)barMetrics; 同样也可以提供一个可调整大小的图片来设置阴影图片，通过 shadowImage 这个属性即可，需要注意的是如果没有设置背景图片，那么阴影图片是不会生效的。之前就遇到一个需求要求隐藏 NavigationBar 下面的黑线，就可以通过设置一个空的图片来达到。 在 UINavigationBar 中层级关系如下图： 参考资料： UINavigationBar UINavigationItem","categories":[],"tags":[{"name":"UIKit","slug":"UIKit","permalink":"Aaronzjp.cn/tags/UIKit/"},{"name":"UINavigationBar","slug":"UINavigationBar","permalink":"Aaronzjp.cn/tags/UINavigationBar/"}]},{"title":"iOS - 多线程","slug":"Multiple-Thread","date":"2016-05-17T01:40:48.000Z","updated":"2017-07-27T02:54:50.000Z","comments":true,"path":"2016/05/17/Multiple-Thread/","link":"","permalink":"Aaronzjp.cn/2016/05/17/Multiple-Thread/","excerpt":"很多时候在我们的软件项目中我们都需要用到多线程，在iOS的项目中也不例外。多线程是编程中重要的一项技术，多线程又分为并发和串行，在此基础上又分为同步线程和异步线程。以下这几点很容易混淆，当然GCD中还有并发队列和串行队列，这个在下面的GCD中有提到。","text":"很多时候在我们的软件项目中我们都需要用到多线程，在iOS的项目中也不例外。多线程是编程中重要的一项技术，多线程又分为并发和串行，在此基础上又分为同步线程和异步线程。以下这几点很容易混淆，当然GCD中还有并发队列和串行队列，这个在下面的GCD中有提到。 同步线程 不回开启新的线程，在当前线程中执行任务，同时会阻塞当前线程，等到当前任务执行完毕后才会继续执行下一个任务。 异步线程 会开启新的线程，在新的线程中执行任务，所以并不会阻塞当前的线程。 NSThreadNSThread相对其他线程方案比较轻量级，能更方便直观的去控制线程对象，对其进行管理，但是缺点是需要自己去管理线程生命周期，线程同步。对系统也会有一定的开销。其实在实际的开发使用中该方案使用的很少，一般就是获取下当前线程和主线程的时候使用起来比较便利。 获取当前线程： 1NSThread *current = [NSThread currentThread]; 获取主线程： 1NSThread *main = [NSThread mainThread]; 创建并开启线程： 123NSThread *thread = [[[NSThreadalloc] initWithTarget:selfselector:@selector(run:)object:@&quot;mj&quot;] autorelease];//开启线程[thread start]; 创建并自动启动线程： 1[NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:@&quot;mj&quot;]; 通过NSObject基类的方法隐式创建线程： 1[self performSelectorInBackground:@selector(run:) withObject:@&quot;mj&quot;]; 通过以上NSbject方式创建线程的方式只能在OC中使用，在swift中苹果因为某些安全问题去掉了performSelector这一系列的方法 暂停当前线程： 1[NSThread sleepForTimeInterval:2]; 12NSDate *date = [NSDate dateWithTimeInterval:2 sinceDate:[NSDate date]];[NSThread sleepUntilDate:date]; 暂停当前线程到某个时间 1+ (void)sleepUntilDate:(NSDate *)date; 在指定线程执行操作直到完成： 12//在thread这个线程中执行self的run方法。YES是指该线程会会造成阻塞，run方法会在thread线程执行完毕后才会执行其他操作。[self performSelector:@selector(run) onThread:thread withObject:nil waitUntilDone:YES]; 在主线程执行操作直到完成： 1[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:YES]; 在当前线程执行操作： 1[self performSelector:@selector(run) withObject:nil]; 其他操作： 1234567891011//取消线程- (void)cancel;//启动线程- (void)start;//判断某个线程的状态的属性@property (readonly, getter=isExecuting) BOOL executing;@property (readonly, getter=isFinished) BOOL finished;@property (readonly, getter=isCancelled) BOOL cancelled;//设置和获取线程名字-(void)setName:(NSString *)n;-(NSString *)name; NSOpreation使用NSOperation和NSOperationQueue进行多线程开发，在线程的管理上就更加的方便，只要将一个NSOperation（实际开中需要使用其子类NSInvocationOperation、NSBlockOperation）放到NSOperationQueue这个队列中线程就会依次启动。 NSOperationQueue负责管理、执行所有的NSOperation，在这个过程中可以更加容易的管理线程总数和控制线程之间的依赖关系。 NSOperation有两个常用子类用于创建线程操作：NSInvocationOperation和NSBlockOperation，两种方式其实没有区别，但是是后者使用Block形式进行代码组织，使用起来会相对于前者更加方便灵活。 NSInvocationOperation：123NSInvocationOperation *invocationOperation =[[NSInvocationOperation alloc]initWithTarget:self selector:@selector(loadImage) object:nil];//开始执行[invocationOperation start]; NSBlockOperation：12345678910111213141516NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^()&#123; NSLog(@&quot;执行第1次操作，线程：%@&quot;, [NSThread currentThread]); &#125;];//添加一个新的线程[operation addExecutionBlock:^() &#123; NSLog(@&quot;又执行了1个新的操作，线程：%@&quot;, [NSThread currentThread]); &#125;];////添加一个新的线程[operation addExecutionBlock:^() &#123; NSLog(@&quot;又执行了1个新的操作，线程：%@&quot;, [NSThread currentThread]); &#125;];//开始执行[operation start];/*这里一共并发执行了三个线程*/ 在做完以上的操作后(不管是通过NSInvocationOperation还是通过NSBlockOperation)该线程启动执行，默认是在当前线程同步执行的，调用start方法后并不会去开启一个新的线程去执行操作。需要如下创建一个操作队列，将NSOperation放入操作队列中。 1234//创建操作队列NSOperationQueue *operationQueue=[[NSOperationQueue alloc]init];//注意添加到操作队后，队列会开启一个线程执行此操作[operationQueue addOperation:operation]; 取消线程操作： 1[operation cancel]; 线程结束后做一些操作： 123456//如果想在一个NSOperation执行完毕后做一些事情，就调用NSOperation的setCompletionBlock方法来设置想做的事情operation.completionBlock = ^() &#123; NSLog(@&quot;执行完毕&quot;); &#125;; 设置线程依赖，该方法可以用来处理在执行一个操作前需要用到上一个线程操作的结果的情景。比如有一个网络请求B，该网络需要等待网络请求A请求到的结果来作为网络请求B的参数，这个时候就可以谁知网络请求B线程依赖网络请求A线程，在A线程请求结束得到结果后再发起网络请求B。 12[operation addDependency:A];//operation线程在线程A执行完成后才会执行 GCD(Grand Central Dispatch)GCD(Grand Central Dispatch)是基于C语言开发的一套多线程开发机制，也是目前苹果官方推荐的多线程开发方法。GCD在三种多线程方式中抽象层次最高，是用起来也最简单，它基于C语言开发，并不像NSOperation是面向对象的开发，而是完全面向过程的。这种机制相比较于前面两种多线程开发方式最显著的优点就是它对于多核运算更加有效。 GCD中也有一个类似于NSOperationQueue的队列，GCD统一管理整个队列中的任务。但是GCD中的队列分为并行队列和串行队列两类： 串行队列：一次只执行一个线程，按照添加到队列的顺序依次执行。 并发队列：一次可以执行多个线程，线程的执行没有先后顺序。根据同步或者异步有不同的执行方式。放到并行队列的任务，GCD也会FIFO的取出来，但不同的是，他取出来一个就会放到别的线程，然后再取出来一个又放到另一个线程去执行，但是因为这个过程相当的短暂，所以可以忽略不计，看起来所有的任务都是一起执行的，但是还是得注意并发线程的数量，数量过大同样会对系统性能造成影响。 在GCD中还有一个特殊队列就是主队列，用来执行主线程上的操作任务。在需要更新UI的时候我们就会用到这个队列，我们用如下的方式来获取该队列。 123dispatch_async(dispatch_get_main_queue(), ^&#123; //主队列中需要运行的代码 &#125;); 并发队列的创建：并发队列同样是使用dispatch_queue_create()方法创建，只是最后一个参数指定为DISPATCH_QUEUE_CONCURRENT进行创建,如下： 1dispatch_queue_t concurrent = dispatch_queue_create(&quot;concurrentThread&quot;, DISPATCH_QUEUE_CONCURRENT); 在实际的使用中其实通常不会去创建一个新的并发队列，一般会用下面的方式去获取系统中的全局并发队列来执行任务。 全局并发队列的创建：在实际开发中通常不会重新创建一个全局并发队列而是使用dispatch_get_global_queue()方法取得一个全局的并发队列（如果有多个并发队列可以使用前者创建），其中在该全局并发队列中有四种优先级选项，一般我们使用默认（DISPATCH_QUEUE_PRIORITY_DEFAULT）的就好，四种优先级如下： 123456789/* * The global concurrent queues may still be identified by their priority, * which map to the following QOS classes: * * - DISPATCH_QUEUE_PRIORITY_HIGH: QOS_CLASS_USER_INITIATED * - DISPATCH_QUEUE_PRIORITY_DEFAULT: QOS_CLASS_DEFAULT * - DISPATCH_QUEUE_PRIORITY_LOW: QOS_CLASS_UTILITY * - DISPATCH_QUEUE_PRIORITY_BACKGROUND: QOS_CLASS_BACKGROUND */ 123456789101112 /*取得全局队列 第一个参数：线程优先级 第二个参数：预留参数，目前没有用，一般传入0 */ dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //创建多个线程用于填充图片 for (int i=0; i&lt;count; ++i) &#123; //异步执行队列任务 dispatch_async(globalQueue, ^&#123;//线程中需要执行的操作 &#125;); &#125; 并发数的控制并发太多的时候我们需要去控制并发数量，因为并发太多会带来很多问题，在实际开发中并发数不是越多越好的。因为并发数量太大对系统的开销，消耗会增大，同时对资源的访问也很难控制，容易导致死锁。我们使用dispatch_apply来控制最大并发数。 123456dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);//线程最大并发数为10size_t maxConcurrentThread = 10;dispatch_apply(maxConcurrentThread, globalQueue, ^(size_t i) &#123; //线程中需要的操作&#125;); 串行队列的创建：12345678910111213/*创建一个串行队列 第一个参数：队列名称 第二个参数：队列类型(也可以传NULL，因为默认的就是DISPATCH_QUEUE_SERIAL) */ dispatch_queue_t serialQueue = dispatch_queue_create(&quot;myThreadQueue1&quot;, DISPATCH_QUEUE_SERIAL);//注意queue对象不是指针类型 //创建多个线程用于填充图片 for (int i=0; i&lt;count; ++i) &#123; //异步执行队列任务 dispatch_async(serialQueue, ^&#123; //线程中需要的操作 &#125;); &#125; 异步与同步：上面创建的这些线程操作都是异步操作 dispatch_async()，如果要使用同步操作则是 dispatch_sync()。 同步执行(阻塞当前线程) 异步执行（不阻塞当前线程） 串行队列 当前线程，一个一个执行（FIFO） 其他线程，一个一个执行（FIFO） 并行队列 当前线程，一个一个执行（FIFO） 多个线程，一起执行 获取公共队列其实这个在上面也有提到，通过这几种方法可以获取到系统预设的公共队列: dispatch_get_current_queue：在iOS 6.0之后已经废弃，用于获取当前正在执行任务的队列，主要用于调试 dispatch_get_main_queue： 最常用的，用于获取应用主线程关联的串行调度队列 dispatch_get_global_queue：最常用的，用于获取应用全局共享的并发队列 后面这两个分别获取主线程的串行队列和获取应用全局共享的并发队列是非常常用的，当我们需要开一个线程并发地异步执行任务时，我们就会放到全局队列中。当我们在异步执行完成时，通常需要回到主线程更新UI显示。 队列的内存管理队列，即Dispatch Queue与其它类型的dispatch对象是引用计数的数据类型。当创建一个串行dispatch queue时,初始引用计数为1,我们可用dispatch_retain和dispatch_release函数来增加和减少引用计数。当引用计数为0时,系统会异步地销毁这个queue。对于系统预设提供的队列此方法无效，系统预设的队列不需要我们来管理，系统会自动管理该队列。 暂停/继续队列12dispatch_suspend(gqueue);dispatch_resume(gqueue); 队列组的使用很多时候我们需要进行多个操作，但是需要这些操作都完成以后才能回到主队列去更新UI，那么就可以用这样的方式使用队列组来完成这样的要求。 123456789101112131415161718192021dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); // 异步执行dispatch_async(queue, ^&#123; // 创建一个组 dispatch_group_t group = dispatch_group_create(); // 分别将任务添加到组中 dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; &#125;); dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; &#125;); // 等待组中的任务执行完毕,回到主线程执行block回调 dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; &#125;);&#125;); 延迟执行 使用NSObject提供的API同步执行，但是该类似方法在swift语言中已经废弃，原因的不安全。 1[self performSelector:@selector(myFunction) withObject:nil afterDelay:5.0]; 通过使用计时器来达到延迟执行的效果 使用dispatch_after方法异步延迟执行 123456CGFloat time = 5.0f;dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(time * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; // time秒后异步执行这里的代码... &#125;); 最后附上GCD中的简单使用的Demo GCDDemo","categories":[],"tags":[{"name":"iOS多线程","slug":"iOS多线程","permalink":"Aaronzjp.cn/tags/iOS多线程/"}]},{"title":"iOS开发-文件管理","slug":"File-Manager","date":"2016-04-28T04:53:47.000Z","updated":"2018-11-24T09:32:56.519Z","comments":true,"path":"2016/04/28/File-Manager/","link":"","permalink":"Aaronzjp.cn/2016/04/28/File-Manager/","excerpt":"​ 在 iOS 开发中，总是有需求我们需要在本地存储数据，但是存储数据的方式有很多，我们怎么样去决定用什么方式去存储数据？目前 iOS 开发中存储数据的方式有属性列表、对象归档、数据库（SQLite，Core Data）等，最终这些数据都会以某些文件等形式存入该App对应的沙盒（SandBox）目录中。","text":"​ 在 iOS 开发中，总是有需求我们需要在本地存储数据，但是存储数据的方式有很多，我们怎么样去决定用什么方式去存储数据？目前 iOS 开发中存储数据的方式有属性列表、对象归档、数据库（SQLite，Core Data）等，最终这些数据都会以某些文件等形式存入该App对应的沙盒（SandBox）目录中。 沙箱目录​ 每个 iOS 程序都有自己独立对应的存储空间（沙盒），沙盒目录是一种出于对数据安全策略的设计。沙盒设计的原理就是只能允许自己对应的应用访问，而不允许其他的应用直接访问沙盒，一般来说程序之间是不可以相互访问沙盒的。 ​ 当我们创建一个程序时，该程序沙盒中默认目录是这样的三个文件夹，分别是 Document、Library、tmp。其中Library下又有两个文件夹，分别是Preferences、Caches，他们的用途，使用场景如下： Document：该目录一般用于存储非常大的文件或者频繁更新的数据，一般数据库，大型持久化的数据都存放在此目录下。可以在此目录下添加子文件夹，能够通过 iTunes 或者 iCloud 备份。 Library：在该文件夹下有两个目录 Preferences：该目录一般用户存放应用程序的设置数据， Caches：这个目录和Document很相似，可以存放应用程序的数据，用来存储缓存文件 tmp：这是临时文件目录，用户可以访问此目录，该目录不能够通过 iTunes 或者 iCloud 备份。 各个文件夹的路径获取方式如下： 1234567891011121314NSString *homeString = NSHomeDirectory(); NSLog(@&quot;程序根目录：%@&quot;,homeString); NSString *DocumentPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]; NSLog(@&quot;Document目录:%@&quot;,DocumentPath); NSString *LibraryPath = [NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES) lastObject]; NSLog(@&quot;Library目录:%@&quot;,LibraryPath); NSString *CachesPath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject]; NSLog(@&quot;Caches目录:%@&quot;,CachesPath); NSString *tempPath = NSTemporaryDirectory(); NSLog(@&quot;temp目录：%@&quot;,tempPath); NSFileManagerNSFileManager这个类听名字也应该知道该类主要负责文件的管理，文件的增删查改，以及文件属性的管理。 使用NSFileManager来管理文件首先初始化一个NSFileManager的对象。 12// NSFileManager是一个单例对象，只实例化一次。NSFileManager *manager = [NSFileManager defaultManager]; 创建文件夹： 1234567891011NSString *docPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES) lastObject];NSString *directoryPath = [docPath StringByAppedingPathComponent:@&quot;Test&quot;];BOOL isSucces = [manager createDirectoryAtPath:directoryPath withIntermediateDirectories:YES attributes:nil error:nil];if (isSuccess) &#123; NSLog(@&quot;创建成功!&quot;);&#125; else &#123; NSLog(@&quot;创建失败！&quot;);&#125; 创建文件： 12345// 创建文件的保存路径NSString *filePath = [directoryPath stringByAppendingPathComponent:@&quot;userInfo.plist&quot;];//使用 NSFileManager 创建文件BOOL isSuccess = [manager createFileAtPath:filePath contents:nil attributes:nil]; 删除文件： 12// 使用NSFileManager 移除指定路径的文件BOOL isSuccess = [manager removeItemAtPath:directoryPath error:nil]; 获取文件属性： 12NSDictionary *fileAttribute = [manager attributesOfItemAtPath:subPathString error:nil];NSLog(@&quot;%@&quot;,fileAttribute); 写入文件： 将数据写入文件的方式主要是看具体的文件是什么，比如NSString、NSArray、NSDictionary、NSData等，都有将数据写入文件的方法，如下，基本是WriteToFile：atomically：格式的方法： 12345 NSMutableDictionary *info = [NSMutableDictionary dictionary];[info setObject:@&quot;2015年10月26日13:05:46&quot; forKey:@&quot;date&quot;];[info setObject:@&quot;TEST&quot; forKey:@&quot;content&quot;];// 写入数据BOOL isSuccess = [info writeToFile:filePath atomically:YES];","categories":[],"tags":[{"name":"数据存储","slug":"数据存储","permalink":"Aaronzjp.cn/tags/数据存储/"},{"name":"本地化","slug":"本地化","permalink":"Aaronzjp.cn/tags/本地化/"},{"name":"文件管理","slug":"文件管理","permalink":"Aaronzjp.cn/tags/文件管理/"}]},{"title":"iOS开发-SQLite数据库","slug":"SQLite-DataBase","date":"2016-04-20T13:00:25.000Z","updated":"2018-11-24T09:36:04.471Z","comments":true,"path":"2016/04/20/SQLite-DataBase/","link":"","permalink":"Aaronzjp.cn/2016/04/20/SQLite-DataBase/","excerpt":"​ 在 iOS 开发中我们经常会对数据进行存储，我们已知有如下几种数据本地化的方式： 属性列表 对象归档 SQLite数据库 Core Data","text":"​ 在 iOS 开发中我们经常会对数据进行存储，我们已知有如下几种数据本地化的方式： 属性列表 对象归档 SQLite数据库 Core Data ​ 其中，前两项属性列表以及归档都只适合轻量化的数据存储，对于比较少量的轻量级的数据我们可以使用属性列表以及对象归档的方式来进行存储。但是在需要存储大量的数据的时候我们就需要利用数据库来对数据进行存储。iOS开发中比较常用的数据库有 SQLite ，Core Data ，当然也有一些其它的第三方的框架实现对数据库的存储和操作，比如FMDB，Realm。 SQLite​ SQLite 是一款开源的数据库，主要采用 C 语言编写，具有可移植性强、可靠性高、小而容易使用的特点。SQLite 在使用的时候它与应用程序之间是共用的相同的进程，而不是单独的两个进程。SQLite 目前的主流版本是 SQLite3 。SQLite 是弱类型的数据库，其实基本上可以忽略数据类型，但是为了编程规范，以及后续方便的维护，建议还是在创建数据库表的时候明确定义各个字段的数据类型。 ​ SQLite支持如下常见的数据类型： 数据类型 和程序对应的数据类型 INTEGER 有符号的整数类型 REAl 浮点类型 TEXT 字符串类型，采用UTF-8UTF-16字符编码 BLOB 二进制大对象类型，能够存放任何二进制数据 除了上面这些数据类型的支持，还有一些兼容的数据类型。其中 SQLite 中是没有 Boolean 类型的，一般我们用 0 和 1 来代替，也没有日期和时间类型，一般这样的类型我们将它存储在 TEXT 、 REAL 和 INTEGER 类型中。 创建数据库要想熟练的使用 SQLite 数据库，首先还是需要熟悉一下 SQLite 数据库简单的增、删、改、查的 SQL语句 的，能简单的使用 SQL 的查询语句。 在 iOS中 我们要使用 SQLite 数据库首先要添加 SQLite 库到工程中，并引入头文件 sqlite3.h 要创建数据库，一般使用以下三个步骤 使用 sqlite3_open 函数打开数据库。 使用 sqlite3_exec 函数来创建数据库表。 使用 sqlite3_close 函数关闭数据库。 在我的 Demo 中，我首先创建了一个叫 SQLiteManager 的类，来专门管理数据库的操作，在- (BOOL)creatDB;方法中开始创建数据库表，并返回是否成功创建数据库表，如下： 123456789101112131415161718192021222324252627282930313233343536373839- (BOOL)creatDB &#123; //获取Documents文件路径 NSString *basePath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]; //拼接获取数据库的地址 dataBasePath = [[NSString alloc]initWithString:[basePath stringByAppendingPathComponent:DATA_BASE_NAME]]; NSLog(@&quot;数据库地址---&gt; %@&quot;,dataBasePath); //返回成功与否 BOOL isSuccess = YES; //打开数据库 //第一个参数是数据库完整的地址 //第二个参数是SQLite数据库对象 //SQLITE_OK 是SQLite中的常量宏定义，表示当前数据库操作的状态 if (sqlite3_open([dataBasePath UTF8String], &amp;db) == SQLITE_OK) &#123; char *erro; //数据库SQL语句，当Person表不存在的时候就创建，否则就不创建 NSString *createSQLite = [NSString stringWithFormat:@&quot;CREATE TABLE IF NOT EXISTS Person (name TEXT PRIMARY KEY, phone TEXT, age TEXT);&quot;]; //数据库建表函数 if (sqlite3_exec(db, [createSQLite UTF8String], NULL, NULL, &amp;erro) != SQLITE_OK) &#123; //关闭数据库，释放资源 sqlite3_close(db); NSAssert(NO, @&quot;数据库建表失败！&quot;); return isSuccess = NO; &#125; else &#123; sqlite3_close(db); NSLog(@&quot;数据库建表成功！&quot;); return isSuccess; &#125; &#125; else &#123; //注意只要执行了数据库打开函数的操作，不管数据库是否打开成功或失败，为了安全起见都需要关闭数据库 sqlite3_close(db); NSAssert(NO, @&quot;数据库打开失败!&quot;); return isSuccess = NO; &#125; return isSuccess;&#125; 上面这段代码中的 SQL 语句： 1NSString *createSQLite = [NSString stringWithFormat:@&quot;CREATE TABLE IF NOT EXISTS Person (name TEXT PRIMARY KEY, phone TEXT, age TEXT);&quot;]; 在创建数据库表的时候存入了三种数据，name、phone、age。其中 name 是主键。在 SQL 语句中，还可以加入字段约束，比如： 1NSString *sql = @&quot;create table if not exists stu (ID integer primary key, name text not null, gender text default &apos;男&apos;)&quot;; 以下是 SQLite 中常用的字段约束条件： NOT NULL 非空，确保某列不能有 NULL 值。 UNIQUE 唯一，确保某列中的所有值是不同的。 PRIMARY KEY 主键，唯一标识数据库表中的各行/记录。 CHECK 条件检查，确保一列中的所有值满足一定条件 DEFAULT 默认，当某列没有指定值时，为该列提供默认值 当写完上面代码后，只要运行程序我们就能在相对应的模拟器路径下找到 Person.sqlite 文件了，当然为了调试方便，看程序是否执行成功，最好还是在电脑上安装一个 SQLite 的工具，以便查看数据库。我推荐如下图这个工具吧，具体的使用还是看个人的习惯。（不要问我从哪下。。。我相信你们找得到😀） 存储数据（修改数据）修改数据时，会使用到的 SQL 语句有 insert 、update 、delete 、insert or replace 等。这次 Demo 中存储数据使用的是 insert or replace ，因为这里没有对数据进行很好的规划，没有对如果主键的数据是相同的情况作出处理，如果用 insert 的话，主键相同的时候，就会存储数据失败，修改数据的操作步骤都是一样的，只是 SQL 语句不一样。 修改数据的主要步骤如下： 使用 sqlite3_open 函数打开数据库 使用 sqlite3_prepare_v2 函数与处理 SQL 语句 使用 sqlite3_bind_text 函数来绑定参数 使用 sqlite3_step 函数执行 SQL 语句 查询结束后使用 sqlite3_ finalize 和 sqlite3_close 函数释放资源 Demo 中只是存储了简单的数据类型，因为在写这个 Demo 时我忽略了数据库类型 BLOB 我也不知道，图片，音频，视频，是怎么存储进去的😂。 但是，但是就在我写这个博客日记前，我算是知道怎么存储进去的了。如果要存储图片，音频，视频文件的话，需要先使用 NSData 类将文件转换成二进制，然后用 BLOB 类型存入 SQLite 数据库，这个具体的操作我会在 Demo 中更新。 存储数据的方法在 Demo 中我也用了一个专门的方法（- (BOOL)saveName:(NSString *)name AndPhone:(NSString *)phone WithAge:(NSString *)age ;）来存储数据，并返回一个 BOOL 值来确定是否储存成功。 1234567891011121314151617181920212223242526272829- (BOOL)saveName:(NSString *)name AndPhone:(NSString *)phone WithAge:(NSString *)age &#123; //返回成功与否 BOOL isSuccess = YES; if (sqlite3_open([dataBasePath UTF8String], &amp;db) != SQLITE_OK) &#123; sqlite3_close(db); isSuccess = NO; NSAssert(NO, @&quot;数据库打开失败&quot;); &#125; else &#123; NSString *insertSQLString = [NSString stringWithFormat:@&quot;INSERT OR REPLACE INTO Person (name, phone, age) VALUES (?, ?, ?)&quot;]; //预处理函数 int result = sqlite3_prepare_v2(db, [insertSQLString UTF8String], -1, &amp;statment, NULL); if (result == SQLITE_OK) &#123; //绑定数据 sqlite3_bind_text(statment, 1, [name UTF8String], -1, NULL); sqlite3_bind_text(statment, 2, [phone UTF8String], -1, NULL); sqlite3_bind_text(statment, 3, [age UTF8String], -1, NULL); //插入数据 if (sqlite3_step(statment) != SQLITE_DONE) &#123; isSuccess = NO; NSAssert(NO, @&quot;插入数据失败&quot;); &#125; else &#123; isSuccess = YES; &#125; &#125; &#125; sqlite3_finalize(statment); sqlite3_close(db); return isSuccess;&#125; 查询数据查询数据和修改数据的步骤基本是一样的，只是在第4步后多了一个字段数据提取的步骤。查询所有 Person 的代码如下： 1234567891011121314151617181920212223242526272829303132- (NSArray *)findAllPerson &#123; NSMutableArray *personArray = [NSMutableArray array]; if (sqlite3_open([dataBasePath UTF8String], &amp;db) != SQLITE_OK) &#123; sqlite3_close(db); NSAssert(NO, @&quot;数据库打开失败&quot;); &#125; else &#123; NSString *findAllPersonSQLString = @&quot;SELECT name,phone,age FROM Person&quot;; int result = sqlite3_prepare_v2(db, [findAllPersonSQLString UTF8String], -1, &amp;statment, NULL); if (result == SQLITE_OK) &#123; while (sqlite3_step(statment) == SQLITE_ROW) &#123; // 获取记录中的字段值 // 第一个参数是语句对象，第二个参数是字段的下标，从0开始 NSString *name = [NSString stringWithUTF8String:(const char *) sqlite3_column_text(statment, 0)]; NSString *phone = [NSString stringWithUTF8String:(const char *) sqlite3_column_text(statment, 1)]; NSString *age = [NSString stringWithUTF8String:(const char *) sqlite3_column_text(statment, 2)]; Person *person = [[Person alloc]init]; person.name = name; person.phone = phone; person.age = age; [personArray addObject:person]; &#125; &#125; sqlite3_finalize(statment); sqlite3_close(db); &#125; return [personArray copy];&#125; 这段代码中查询的是数据库表中所有的数据。按条件查询数据的方法和这个基本也是差不多的，区别在于查询所有数据没有查询条件，不需要绑定参数，遍历数据的时候使用的是 while 循环语句，而不是 if 条件判断语句。查找对应 phone 的 Person 如下： 123456789101112131415161718192021222324252627282930313233- (Person *)findPersonWithPhone:(NSString *)phone &#123; NSMutableArray *personArray = [NSMutableArray array]; if (sqlite3_open([dataBasePath UTF8String], &amp;db) != SQLITE_OK) &#123; sqlite3_close(db); NSAssert(NO, @&quot;数据库打开失败&quot;); &#125; else &#123; NSString *findAllPersonSQLString = @&quot;SELECT * FROM Person WHERE phone = ?&quot;; int result = sqlite3_prepare_v2(db, [findAllPersonSQLString UTF8String], -1, &amp;statment, NULL); if (result == SQLITE_OK) &#123; //和查询所有数据的区别就在这里，先绑定数据，再用if去过滤查询结果 //绑定数据 sqlite3_bind_text(statment,1,[phone UTF8String],-1,NULL) if (sqlite3_step(statment) == SQLITE_ROW) &#123; // 获取记录中的字段值 // 第一个参数是语句对象，第二个参数是字段的下标，从0开始 NSString *name = [NSString stringWithUTF8String:(const char *) sqlite3_column_text(statment, 0)]; NSString *phone = [NSString stringWithUTF8String:(const char *) sqlite3_column_text(statment, 1)]; NSString *age = [NSString stringWithUTF8String:(const char *) sqlite3_column_text(statment, 2)]; Person *person = [[Person alloc]init]; person.name = name; person.phone = phone; person.age = age; &#125; &#125; sqlite3_finalize(statment); sqlite3_close(db); &#125; return person;&#125; SQLite 的查询语句当然也是可以添加一些条件的，比如： 计算某字段记录的数量： SELECT COUNT （字段）FROM 表名； 示例🌰： 1NSString *findAllPersonCountSQLString = @&quot;SELECT COUNT (phone) FROM Person &quot;; 查询结果按顺序排列： SELECT * FROM 表名 ORDER BY 字段 ; 示例🌰： 查找Person并按照降序排列（ DESC 降序，ASC 升序） 1NSString *findAllPersonSQLStringByDesc = @&quot;SELECT * FROM Person ORDER BY phone DESC &quot;; 控制查询结果的数量： SELECT * FROM 表名 LIMIT 数值1, 数值2 ; 示例🌰： 跳过第0跳数据取10条数据 1NSString *findAllPersonSQLString = @&quot;SELECT * FROM Person LIMIT 0，10 &quot;; 其实还有更多的SQL查询语句，想要知道更多查询语句的可以在我前面给出的网站中自行学习。 删除数据123456789101112131415161718192021222324- (BOOL)deletePersonWithName:(NSString *)name &#123; BOOL isSucces = YES; if (sqlite3_open([dataBasePath UTF8String], &amp;db) != SQLITE_OK) &#123; sqlite3_close(db); return NO; NSAssert(NO, @&quot;数据库打开失败&quot;); &#125; else &#123; NSString *deletePersonSQLString = @&quot;DELETE FROM Person WHERE name =?&quot;; int result = sqlite3_prepare_v2(db, [deletePersonSQLString UTF8String], -1, &amp;statment, NULL); if (result == SQLITE_OK) &#123; sqlite3_bind_text(statment, 1, [name UTF8String], -1, NULL); if (sqlite3_step(statment) != SQLITE_DONE) &#123; return isSucces = NO; NSAssert(NO, @&quot;数据库删除失败&quot;); &#125; else &#123; NSLog(@&quot;数据删除成功&quot;); return isSucces = YES; &#125; &#125; &#125; sqlite3_finalize(statment); sqlite3_close(db); return isSucces;&#125; 关于SQLite更多的学习 Demo下载地址","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"Aaronzjp.cn/tags/数据库/"},{"name":"SQLite","slug":"SQLite","permalink":"Aaronzjp.cn/tags/SQLite/"}]},{"title":"KVO/KVC的使用","slug":"KVO-KVC","date":"2016-03-31T02:40:37.000Z","updated":"2017-07-27T02:55:23.000Z","comments":true,"path":"2016/03/31/KVO-KVC/","link":"","permalink":"Aaronzjp.cn/2016/03/31/KVO-KVC/","excerpt":"KVO（key-value observing）和KVC（Key-value coding）这两种模式其实是一种观察者模式的设计，可以让我们更加灵活的利用Objective-C语言的动态特性来编写代码。KVO和KVC其实是一套非正式的协议，是在其NSObject类中实现的，所以只有继承了该类就可以使用这一非正式的协议。","text":"KVO（key-value observing）和KVC（Key-value coding）这两种模式其实是一种观察者模式的设计，可以让我们更加灵活的利用Objective-C语言的动态特性来编写代码。KVO和KVC其实是一套非正式的协议，是在其NSObject类中实现的，所以只有继承了该类就可以使用这一非正式的协议。 KVC（Key-value coding）简介KVC（Key-value coding）从全称来看一般被翻译成了键值编码，使用KVC我们可以通过字符串去访问一个对象的实例变量。 KVC的使用使用KVC我们可以通过字符串去访问对象相对应的实例变量，其本质大概就是通过使用对应的字符串向对象发送消息。其中主要的方法如下： 1234- (id)valueForKey:(NSString *)key; - (void)setValue:(id)value forKey:(NSString *)key; - (id)valueForKeyPath:(NSString *)keyPath; - (void)setValue:(id)value forKeyPath:(NSString *)keyPath; 普通情况下我们都是使用对象的设置方法和取值方法去访问其属性，但是在KVC中我们可以通过这样的方式去访问对象的属性，最简单的KVC的使用可以通过这样的方式去访问属性： 12345678//被访问的属性@property (nonatomic,copy) NSString *name;//取值NSString *name = [object valueForKey:@&quot;name&quot;];//设值[object setValue:@&quot;Aaron&quot; forKey:!&quot;name&quot;]; 在KVC中除了可以访问对象的属性外，还可以访问对象的一些数据类型属性（如：int ，CGFloat，CGRect等数据类型和集合）。Foudation框架会对此进行封装和处理。 12345678//被访问的数据类型属性@property (nonatomic) CGFloat number;//取值CGFloat number = [object valueForKey@&quot;number&quot;];//设值[object setValue:@(20) forKey:@&quot;number&quot;] 在上面我们通过KVC可以使用字符串来访问对象的属性，这个字符串我们称之为”键” 键路径（Key Path）上面使用了键去访问对象的属性，同样的KVC也可以通过键路径的关系去访问对象。 假设有一个Person对象，该对象有一个dog属性，dog属性有sleep属性，我们可以通过键路径来访问这个sleep属性： 1[person valueForKeyPath:@&quot;dog.sleep&quot;] 通过建路径也可以用相对应的方法去设值。 KVO（key-value observing）简介KVO（key-value observing），其实是一种观察者模式，KVO是基于KVC的另一种实现的观察者模式，利用该模式可以监听想要观察的属性，当其发生变化时就会调用监视器指定的方法。 KVO的使用在KVO模式中比较重要的几个方法如下： 12345678910111213141516//添加对象的观察者- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context;//观察者需要实现的方法，当被观察者发生改变时，会调用此方法- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context&#123; NSLog(@&quot;old: %@&quot;, [change objectForKey:NSKeyValueChangeOldKey]); NSLog(@&quot;old: %@&quot;, [change objectForKey:NSKeyValueChangeNewKey]); NSLog(@&quot;context: %@&quot;, context);&#125;//移除观察者- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath 键值验证（KVV，Key-Value Validate）KVV也是KVC API中的一部分，这是用来验证属性值的API，保证了数据的一致性，KVC是不会做任何的验证，也不会自动的去调用KVV的方法，我们要想验证数据的一致性，只用通过KVV来实现我们自己的验证方法以便来保证他们的一致性。 我们一般通过调用此方法来验证数据： 1- (BOOL)validateValue:(inout id *)ioValue forKey:(NSString *)inKey error:(out NSError **)outError; 比如当我们需要验证Person类中name字段不为空，可以这样： 123456789NSString *name = @&quot;LiLei&quot;;NSString *key = @&quot;name&quot;;NSError *error = nil;if (Person validateValue:&amp;name forKey:key error:&amp;error) &#123; NSLog(@&quot;name is nil&quot;)&#125; else &#123; NSLog(@&quot;name is not nil&quot;)&#125; 当然我们也可以通过重写此方法，以便通过我们自己的逻辑来验证数据 ： 123456789- (BOOL)validateName:(NSString **)name error:(NSError * __autoreleasing *)outError&#123; if ((*name).length == 0) &#123; (*name) = @&quot;default name&quot;; return NO; &#125; return YES;&#125; 手动通知和自动通知KVO作为观察者，当我们观察的属性发生变化时就会发出通知告诉我们被观察者发生了改变。通过自动属性，建立键值观察，都属于自动键值观察。因为使用这种方法，只要设置键值，就会自动发出通知。而手动键值观察，不能使用自动化属性，需要自己写 setter/getter 方法，手动发送通知。 手动通知的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142//手动通知的实现@interface Person : NSObject&#123; NSString *name;&#125;- (NSString *)name;- (void)setName:(int)theName;@end@implementation Person- (id) init&#123; self = [super init]; if (nil != self) &#123; name = @&quot;Aaron&quot;; &#125; return self;&#125;- (NSString *)name&#123; return name;&#125;- (void)setName:(NSString *)theName&#123; //发送通知：键值即将改变 [self willChangeValueForKey:@&quot;name&quot;]; name = theName; //发送通知：键值已经修改 [self didChangeValueForKey:@&quot;name&quot;];&#125;/** * 当设置键值之后，通过此方法，决定是否发送通知 */+ (BOOL) automaticallyNotifiesObserversForKey:(NSString *)key&#123; //当 key 为 name时，手动发送通知 if ([key isEqualToString:@&quot;age&quot;]) &#123; return NO; &#125; //当为其他key时，自动发送通知 return [super automaticallyNotifiesObserversForKey:key];&#125;@end 属性依赖在某些特殊的情况下，一个类的几个属性之间有相互的关系，但是我们需要观察这些有相互关系的属性，这个时候我们就要使用属性依赖。比如一个Person类中有三个属性fullName，firstName，lastName，如果在不了解属性依赖之前，我们要观察名字的变化就只有添加三个观察者，但是在使用属性依赖的时候，我们只需要对其中一个属性添加观察，同时对观察的这个属性设置属性依赖后择业我们就可以观察名字的变化了。KVC中刚刚好就提供了这样的方法： 1+ (NSSet *)keyPathsForValuesAffectingValueForKey:(NSString *)key 添加属性依赖到被观察者上： 1234567/设置属性依赖：fullName属性依赖于firstName、lastName//如果观察name，当firstName、lastName发生变化时，观察者也会收到name变化通知+ (NSSet *)keyPathsForValuesAffectingFullName&#123; NSSet *set = [NSSet setWithObjects:@&quot;firstName&quot;, @&quot;lastName&quot;, nil]; return set;&#125; 在添加好属性依赖后，我们只需要像平常使用KVO观察一样的，对fullName添加观察者即可。","categories":[],"tags":[{"name":"KVO/KVC","slug":"KVO-KVC","permalink":"Aaronzjp.cn/tags/KVO-KVC/"},{"name":"设计模式","slug":"设计模式","permalink":"Aaronzjp.cn/tags/设计模式/"}]},{"title":"block的使用","slug":"Block","date":"2016-03-29T13:53:52.000Z","updated":"2018-11-24T09:31:43.086Z","comments":true,"path":"2016/03/29/Block/","link":"","permalink":"Aaronzjp.cn/2016/03/29/Block/","excerpt":"​ block（代码块）他的本质其实是和其他的变量类似的，不同的就是block（代码块中存储的是一个函数体，或者一段代码）。在使用block的时候可以像调用方法一样的，传入参数，然后得到返回值。 ^（脱字符）是block的语法标记，下面是block的声明：","text":"​ block（代码块）他的本质其实是和其他的变量类似的，不同的就是block（代码块中存储的是一个函数体，或者一段代码）。在使用block的时候可以像调用方法一样的，传入参数，然后得到返回值。 ^（脱字符）是block的语法标记，下面是block的声明： 下面就来声明一个block变量试试： 12345678//声明一个block变量int multiplier = 7;int (^myBlock)(int) = ^(int num) &#123; return num * multiplier;&#125;;//block变量可以像函数一样使用NSLog(@&quot;%d&quot;,myBlock(8)); block实际使用结合typedef使用​ 上面只是简单的说了block在声明方式，和block变量的声明和使用，block是一个很灵活好用的东西，block的使用也十分的广泛，block可以用做属性，可以用作函数的返回值，也可以作为函数的参数来传递使用。 ​ 其实block也可以结合typedef来使用，用typedef给我们的block起一个别名，这样在使用block的时候回更加方便，易读。 1typedef void (^ReturnTextBlock) (NSString *showText); 使用block回调传值​ 使用情景，有两个控制器（控制器一，控制器二）。在控制器二中输入一段文字，在返回到控制器一时，显示出来。 ​ 首先，新建工程并创建两个控制器类，如图： ​ 在控制器二的头文件中声明一个block属性，并声明一个回调方法： 1234567891011121314//给block定义一个别名typedef void (^ReturnTextBlock) (NSString *showText);@interface SecondViewController : UIViewController@property (nonatomic,copy) NSString *name;//声明一个block属性@property (nonatomic, copy) ReturnTextBlock returnTextBlock;//使用此方法回调，获取本控制器中输入的文字（也可以通过block属性来获取控制器中输入的文字）- (void)returnText:(ReturnTextBlock)block;@end ​ 在控制器二中，点击按钮回返回控制器一的时候我们将这个block属性赋值： 123456- (void)viewWillDisappear:(BOOL)animated &#123; if (self.returnTextBlock != nil) &#123; //给returnTextBlock赋值 self.returnTextBlock(self.inputTF.text); &#125;&#125; ​ 然后在回到控制器一的时候获取block中的值即可到达block传值的目的： 1234567891011121314- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender&#123; SecondViewController *tfVC = segue.destinationViewController; //通过回调方法获取控制器二block中的值 [tfVC returnText:^(NSString *showText) &#123; self.TestLabel.text = showText; &#125;]; //通过属性的方式获取控制器二block中的值// tfVC.returnTextBlock = ^(NSString *showText) &#123;// self.TestLabel.text = showText;// &#125;;&#125; block作为函数返回值​ 有时候，我们会把block作为函数的返回值来处理，用来提供给外部来调用： 12345678910111213141516//定义一个blocktypedef void (^TextBlock) (NSString *str);//把block作为函数的返回值- (TextBlock)returnAStringWithName &#123; TextBlock block = ^(NSString *str) &#123; NSLog(@&quot;他的名字叫%@&quot;,str); &#125;; return block;&#125;//调用返回值为block的方法 TextBlock block = [self returnAStringWithName]; NSString *a = @&quot;王八蛋&quot;; //使用返回的block block(a); ​ block的使用方式还有很多，后续会介绍更多更方便的block的使用方式。 BlockDemo","categories":[],"tags":[{"name":"block","slug":"block","permalink":"Aaronzjp.cn/tags/block/"}]},{"title":"App皮肤，更换皮肤思路","slug":"AppThemes","date":"2016-03-26T06:35:20.000Z","updated":"2017-07-27T02:58:38.000Z","comments":true,"path":"2016/03/26/AppThemes/","link":"","permalink":"Aaronzjp.cn/2016/03/26/AppThemes/","excerpt":"​ 最近遇到了一个需求，就是做App皮肤的换肤的功能，因为之前一直没有涉及到这方面的需求，所以刚刚拿到这个需求的时候我也不知道怎么做，后面通过查看相关的资料终于完成了这个需求。下面就是我对本次这个需求的一点想法和具体完成的方法。","text":"​ 最近遇到了一个需求，就是做App皮肤的换肤的功能，因为之前一直没有涉及到这方面的需求，所以刚刚拿到这个需求的时候我也不知道怎么做，后面通过查看相关的资料终于完成了这个需求。下面就是我对本次这个需求的一点想法和具体完成的方法。 主题管理​ 首先想到主题是什么，就是App的皮肤，皮肤其实划分细一点这里就要考虑到App皮肤是否有布局的改变，有布局的改变的皮肤就需要针对皮肤做出对应的布局的约束，有布局改变的皮肤不在本次的讨论之中，因为现在还没有涉及到有布局变化的需求，这里只说下简单的皮肤的变更。App的皮肤其实就是UI界面的图片，和颜色的改变，那我们用什么来存储这些UI的皮肤图片和颜色呢？这里我们就需要一个皮肤管理器了，这个皮肤管理器的作用其实就是一个皮肤相关的资源管理器，皮肤其实重点在于资源，这是一个只关心皮肤相关资源的管理器，而且这个资源管理器又是只能整个App唯一的一个资源管理器，如果有多个的话那我们设置皮肤的时候使用哪一个呢？这样岂不是乱套了。所有只能有一个。所以这里就用单例来作为皮肤管理器比较好。 1234567891011121314+ (ThemeManager *)sharedeThemeManager&#123; if (!themeManager) &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken,^&#123; themeManager = [[super allocWithZone:NULL]init]; &#125;); &#125; return themeManager;&#125;+ (id)allocWithZone:(struct _NSZone *)zone &#123; return [ThemeManager sharedeThemeManager];&#125; 主题资源管理​ 主题管理器有了，下面就是具体的资源了。资源我直接使用的是本地资源化来管理皮肤资源： 其中颜色和文字描述也放在了对应的主题文件夹类，使用plist文件来进行储存。 每次获取主题的对应的相关资源时就会根据主题的主题名属性来获取主题的相关资源： @property (nonatomic,copy) NSString *themeName; 根据主题的名字来判断主题管理器去获取主题对应的资源的路径： 12345//通过主题名字来设置主题的路径- (NSString *)themePath &#123; NSString *themePath = [[[[NSBundle mainBundle]resourcePath]stringByAppendingPathComponent:THEME_BUNDLE_PATH]stringByAppendingPathComponent:self.themeName ? : DEFAULT_THEME]; return themePath;&#125; 通过这样的方法就可以让主题管理器通过主题的名字来获取对应主题的相关资源。其中图片的资源就可以直接通过上面的这个themePath路径来获取相对于的图片资源了。(下面的这三个方法就需要在.h文件中声明，暴露在外部，其他的UI类就能通过下面的这三个方法获取对应主题的图片文件和颜色了)。 1234//获取的图片的方法的实现- (UIImage *)getImageFromThemeWithName:(NSString *)imageName &#123; return [UIImage imageWithContentsOfFile:[self.themePath stringByAppendingPathComponent:imageName]];&#125; 主题相关的颜色因为是从对应主题文件夹的plist文件去读取，所以这里最好设计一个获取对应主题的plist文件的路径方法并把plist文件通过字典的方式读取出来，返回一个字典： 1234567//主题的颜色文字的配置- (NSDictionary *)themeConfig &#123; if (!_themeConfig) &#123; _themeConfig = [NSDictionary dictionaryWithContentsOfFile:[self.themePath stringByAppendingPathComponent:THEME_CONFIG]]; &#125; return _themeConfig;&#125; 主题文字和颜色在plist文件中是这样存储的： 这里的颜色是按照16进制的方式存储的，在iOS中使用这个存储的方式的颜色的时候就需要把改颜色转换层RGB的颜色，这个这里就不细说了，百度iOS16进制颜色转换就能找到转换方法。 下面就是对应的文件和颜色的读取方式，通过获取这个plist文件的内容返回的字典，从这个字典中去获取对应主题的相关的文字和颜色： 1234567891011//获取颜色的方法的实现- (UIColor *)getColorFromThemeWithColorNmae:(NSString *)colorName &#123; NSString *color = self.themeConfig[@&quot;Color&quot;][colorName]; return [UIColor colorWithHexString:color];&#125;//获取文字的方法的实现- (NSString *)getStringFromThemeWithStringName:(NSString *)stringNmae &#123; NSString *string = self.themeConfig[@&quot;Text&quot;][stringNmae]; return string;&#125; 皮肤变更通知​ 当App的主题皮肤的名字被改变的时候，加载新的页面的时候App的皮肤也就会根据，皮肤管理器的这个themeName的变化切换对应的皮肤。对于没有显示在当前屏幕的页面皮肤就会根据主题名自动变化。但是在已经加载的页面（一般都是切换主题按钮的这个页面），主题对应的变化就需要设置一个监听器，或者通知时间去键盘主题的变化了，这样才能在主题变化的时候，及时的变更已加载页面的主题，让界面重新从主题管理器获取资源再加载。因为这类通知一般属于全局性的所以这里最好使用通知NSNotification ​ 所以这里在主题名字themeName发生变化的时候就要调用[NSNotificaitonCenter defaultCenter]的postNotificationName:object:发出通知，而在各个涉及到主题更换的ViewController中使用addObserver:selector:name:object:监听通知事件，并响应通知做出皮肤变更通知的响应处理方式。 总结​ 其实整个主题管理器就相当于一个资源管理器，这里针对这个资源管理器进行了封装。通过调用外部的获取图片资源和颜色以及文字的接口，就可以返回对应主题的文字，颜色和图片。其实大部分的自定义控件和UI模块都是如此，将内部的实现封装起来，按照这个管理器的规则来使用和调用接口，就可以简单的使用这个管理器来管理皮肤，设计大都是相似的，多一个中间层，就会让程序变得更加灵活易用。 项目Demo地址","categories":[],"tags":[{"name":"思路","slug":"思路","permalink":"Aaronzjp.cn/tags/思路/"}]},{"title":"使用Masonry布局UI","slug":"UseMasonryLayoutUI","date":"2016-03-20T08:29:23.000Z","updated":"2018-11-24T09:37:03.543Z","comments":true,"path":"2016/03/20/UseMasonryLayoutUI/","link":"","permalink":"Aaronzjp.cn/2016/03/20/UseMasonryLayoutUI/","excerpt":"Masonry 是一个针对 AutoLayout 的封装的轻量级的布局框架，拥有自己的语法描述，通过链式语法封装 AutoLayout，大大的提高了代码的可读性和简洁度。","text":"Masonry 是一个针对 AutoLayout 的封装的轻量级的布局框架，拥有自己的语法描述，通过链式语法封装 AutoLayout，大大的提高了代码的可读性和简洁度。 AutoLayout介绍iOS UI布局目前有很多种方式，从最开始的只需要简单的计算下相对位置，到 AutoresizingMask 布局，再到 AutoLayout 布局。从这些 UI 布局到方式就可以看出 iOS 设备屏幕尺寸的改变，为了兼容多个屏幕尺寸苹果推出了上面提到的这些 UI 布局技术，目前使用最多的就是 AutoLayout 布局。在 Storyboard 上使用还是比较直接的，设置约束后就会立即生效，所见即所得。但是 Storyboard 在相对复杂的 UI 布局上就显得不是那么好用了，还是得使用代码进行布局。那么使用代码布局的时候问题就来了，使用过都知道简直就是难以忍受，可以说这样的代码简直是啰嗦。 不信看一下： 12345678910111213141516171819 UIView *redView = [[UIView alloc]init]; redView.backgroundColor = [UIColor redColor]; //给每个视图代码添加NSLayoutConstraint约束的时候要关闭这个属性 redView.translatesAutoresizingMaskIntoConstraints = NO; //在给视图添加约束的时候要先将视图添加到父视图，不然会报错 [self.view addSubview:redView]; //相对于父控件的左边距 NSLayoutConstraint *redViewLeft = [NSLayoutConstraint constraintWithItem:redView attribute:NSLayoutAttributeLeft relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeLeft multiplier:1.0 constant:20.0]; [self.view addConstraint:redViewLeft]; //相对于父控件的下边距 NSLayoutConstraint *redViewBottom = [NSLayoutConstraint constraintWithItem:redView attribute:NSLayoutAttributeBottom relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeBottom multiplier:1.0 constant:-20.0]; [self.view addConstraint:redViewBottom]; //自身宽度约束（这里是直接添加宽度约束） NSLayoutConstraint *redViewWidth = [NSLayoutConstraint constraintWithItem:redView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:kNilOptions multiplier:1.0 constant:50]; [redView addConstraint:redViewWidth]; //自身高度约束（这里是直接添加高度约束） NSLayoutConstraint *redViewHeight = [NSLayoutConstraint constraintWithItem:redView attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:nil attribute:kNilOptions multiplier:1.0 constant:50]; [redView addConstraint:redViewHeight]; 是不是觉得这样来布局 UI 代码很啰嗦，也很难读？这仅仅是对一个 View 的布局，想象一下一个复杂的控制器，里面有多个的视图。。。 再来对比下 Masonry： 12345678910UIView *redView = [[UIView alloc]init];redView.backgroundColor = [UIColor redColor];[self.view addSubview:redView];//添加约束[redView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(self.view).offset(20); make.bottom.equalTo(self.view).offset(-20); make.size.mas_equalTo(CGSizeMake(50, 50)); &#125;]; 没错，上面那么大一堆代码，在 Masonry 上只需要这么几句。 Masonry的使用首先在 Masonry 有三个方法用来修改约束的，通过名字大概也能了解到这三个方法的用处。 123456//用来添加约束的，注意的是AutoLayout不能同时存在两条约束同时针对一个对象，会报错- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block;//用来更新约束，不存在相同约束针对同一个对象，相同的会被更新- (NSArray *)mas_updateConstraints:(void(^)(MASConstraintMaker *))block;//清除之前所有的约束，并更新现在添加的约束- (NSArray *)mas_remakeConstraints:(void(^)(MASConstraintMaker *make))block; equalTo 和 mas_equalTo 的区别： 这里 mas_equalTo 是对其中的参数做了一个BOX操作（装箱操作），看了下源码很长，具体的我也没看太懂，这个后面有时间仔细了解下。目前我在使用中的时候如果是相对于 View 的约束操作是使用 equalTo ，相对于直接的数值和结构体的约束是使用 mas_equalTo。 介绍完一些基本的使用方法后就来做一些实际操作。 例子1首先来居中显示一个红色 View： 12345678910111213UIView *redView = [[UIView alloc]init];redView.backgroundColor = [UIColor redColor];//添加约束前需要先把视图添加到superView上，否则会报错[self.view addSubview:redView];[redView mas_makeConstraints:^(MASConstraintMaker *make) &#123; //中心点等于self.view make.center.equalTo(self.view); //view的宽和高等于300 make.width.and.height.mas_equalTo(300); // 这一句和上面一句是等同的，也是设置view的宽和高的约束等于300 // make.width.and.height.equalTo(@300);&#125;]; 效果如下： 例子2在例子1的基础上创建两个视图，边距相互为10，且高相等，宽相等： 12345678910111213141516171819202122232425262728293031323334353637//首先添加这两个 View 到 redView 上UIView *view1 = [[UIView alloc]init];view1.backgroundColor = [UIColor purpleColor];[redView addSubview:view1];UIView *view2 = [[UIView alloc]init];view2.backgroundColor = [UIColor orangeColor];[redView addSubview:view2];//添加 View1 的约束[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123; //左边和顶部相对 redView 相距10 make.left.and.top.equalTo(redView).offset(10); //右边相对于 View2 的左边相距 10 make.right.equalTo(view2.mas_left).offset(-10); //中心点相对于 redView 中心Y轴对齐 make.centerY.equalTo(redView.mas_centerY); //底部相对于 redView 的底部相距10 make.bottom.equalTo(redView).offset(-10); //宽相对于 View2 的宽相等 make.width.equalTo(view2.mas_width);&#125;];[view2 mas_makeConstraints:^(MASConstraintMaker *make) &#123; //左边相对于 View1 的右边相距10 make.left.equalTo(view1.mas_right).offset(10); //右边相对于 redView 的右边相距10 make.right.equalTo(redView).offset(-10); //中心点相对于 redView 中心Y轴对齐 make.centerY.equalTo(redView.mas_centerY); //顶部相对于 redView 的边距为10 make.top.equalTo(redView).offset(10); //底部相对于 redView 的边距为10 make.bottom.equalTo(redView).offset(-10); //宽相对于 View1 的宽相等 make.width.equalTo(view1.mas_width);&#125;]; 效果如下：","categories":[],"tags":[{"name":"AutoLayout","slug":"AutoLayout","permalink":"Aaronzjp.cn/tags/AutoLayout/"}]},{"title":"代码实现AutoLayout布局","slug":"AutoLayout-UI","date":"2016-03-06T15:00:17.000Z","updated":"2018-11-24T09:31:36.614Z","comments":true,"path":"2016/03/06/AutoLayout-UI/","link":"","permalink":"Aaronzjp.cn/2016/03/06/AutoLayout-UI/","excerpt":"​ 在代码中添加Autolayout约束的方法就如下的整个demo介绍。下面demo中还介绍到了怎么在Autolayout下做动画，以及约束的优先级。 在约束添加中要注意以下几个地方： 两个相同一层级的视图的约束要添加到共同的父视图上 两个不同层级的视图的约束要添加到他们最近的共有的父视图上 子视图与父视图之间的约束添加到父视图上","text":"​ 在代码中添加Autolayout约束的方法就如下的整个demo介绍。下面demo中还介绍到了怎么在Autolayout下做动画，以及约束的优先级。 在约束添加中要注意以下几个地方： 两个相同一层级的视图的约束要添加到共同的父视图上 两个不同层级的视图的约束要添加到他们最近的共有的父视图上 子视图与父视图之间的约束添加到父视图上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#import &quot;ViewController.h&quot;@interface ViewController ()&#123; UIView *blueView;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [self addRedView];&#125;- (void)addRedView&#123; //首先创建这个View UIView *redView = [[UIView alloc]init]; redView.backgroundColor = [UIColor redColor]; //给每个视图代码添加NSLayoutConstraint约束的时候要关闭这个属性 redView.translatesAutoresizingMaskIntoConstraints = NO; //在给视图添加约束的时候要先将视图添加到父视图，不然会报错 [self.view addSubview:redView]; //相对于父控件的左边距 NSLayoutConstraint *redViewLeft = [NSLayoutConstraint constraintWithItem:redView attribute:NSLayoutAttributeLeft relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeLeft multiplier:1.0 constant:20.0]; [self.view addConstraint:redViewLeft]; //相对于父控件的下边距 NSLayoutConstraint *redViewBottom = [NSLayoutConstraint constraintWithItem:redView attribute:NSLayoutAttributeBottom relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeBottom multiplier:1.0 constant:-20.0]; [self.view addConstraint:redViewBottom]; //自身宽度约束（这里是直接添加宽度约束） NSLayoutConstraint *redViewWidth = [NSLayoutConstraint constraintWithItem:redView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:kNilOptions multiplier:1.0 constant:50]; [redView addConstraint:redViewWidth]; //自身高度约束（这里是直接添加高度约束） NSLayoutConstraint *redViewHeight = [NSLayoutConstraint constraintWithItem:redView attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:nil attribute:kNilOptions multiplier:1.0 constant:50]; [redView addConstraint:redViewHeight]; //蓝色的小方块 blueView = [[UIView alloc]init]; blueView.backgroundColor = [UIColor blueColor]; blueView.translatesAutoresizingMaskIntoConstraints = NO; [self.view addSubview:blueView]; //相对于红色视图的顶部约束 NSLayoutConstraint *blueViewTop = [NSLayoutConstraint constraintWithItem:blueView attribute:NSLayoutAttributeTop relatedBy:NSLayoutRelationEqual toItem:redView attribute:NSLayoutAttributeTop multiplier:1.0 constant:0]; [self.view addConstraint:blueViewTop]; //视图左边的边距（相对于红色视图的右边的边距） NSLayoutConstraint *blueViewLeft = [NSLayoutConstraint constraintWithItem:blueView attribute:NSLayoutAttributeLeft relatedBy:NSLayoutRelationEqual toItem:redView attribute:NSLayoutAttributeRight multiplier:1.0 constant:20]; [self.view addConstraint:blueViewLeft]; //等于红色视图的宽 NSLayoutConstraint *blueViewWidth = [NSLayoutConstraint constraintWithItem:blueView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:redView attribute:NSLayoutAttributeWidth multiplier:1.0 constant:0]; [self.view addConstraint:blueViewWidth]; //等于红色视图的高 NSLayoutConstraint *blueViewHeight = [NSLayoutConstraint constraintWithItem:blueView attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:redView attribute:NSLayoutAttributeHeight multiplier:1.0 constant:0]; [self.view addConstraint:blueViewHeight]; //黑色的视图 UIView *blackView = [[UIView alloc]init]; blackView.backgroundColor = [UIColor blackColor]; blackView.translatesAutoresizingMaskIntoConstraints = NO; [self.view addSubview:blackView]; //相对于红色视图的顶部约束 NSLayoutConstraint *blackViewTop = [NSLayoutConstraint constraintWithItem:blackView attribute:NSLayoutAttributeTop relatedBy:NSLayoutRelationEqual toItem:redView attribute:NSLayoutAttributeTop multiplier:1.0 constant:0]; [self.view addConstraint:blackViewTop]; //视图左边的边距（相对于红色视图的右边的边距） NSLayoutConstraint *blackViewLeft = [NSLayoutConstraint constraintWithItem:blackView attribute:NSLayoutAttributeLeft relatedBy:NSLayoutRelationEqual toItem:blueView attribute:NSLayoutAttributeRight multiplier:1.0 constant:20]; [self.view addConstraint:blackViewLeft]; //直接添加黑色视图的宽度约束 NSLayoutConstraint *blackViewWidth = [NSLayoutConstraint constraintWithItem:blackView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:kNilOptions multiplier:1.0 constant:50]; [self.view addConstraint:blackViewWidth]; //直接添加黑色视图的高度约束 NSLayoutConstraint *blackViewHeight = [NSLayoutConstraint constraintWithItem:blackView attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:nil attribute:kNilOptions multiplier:1.0 constant:50]; [self.view addConstraint:blackViewHeight]; //这里介绍了在AutoLayout中做动画的方法。当蓝色视图消失后，这个视图的左边距要设置为相对于红色视图的右边距 NSLayoutConstraint *blackViewWithredViewLeft = [NSLayoutConstraint constraintWithItem:blackView attribute:NSLayoutAttributeLeft relatedBy:NSLayoutRelationEqual toItem:redView attribute:NSLayoutAttributeRight multiplier:1.0 constant:20]; //重复添加约束是回报错的，不正确的做法。但是这里如果蓝色视图消失不改变约束的话就达不到想要的约束效果 //解决方法就是设置约束的优先级 优先级范围为：0 - 1000 数值越大优先级越高 默认为1000 UILayoutPriority left = 200; blackViewWithredViewLeft.priority = left; [self.view addConstraint:blackViewWithredViewLeft];&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; [blueView removeFromSuperview]; [UIView animateWithDuration:2 animations:^&#123; //当视图发生改变需要更新约束 [self.view layoutIfNeeded]; &#125;];&#125;","categories":[],"tags":[{"name":"Autolayout","slug":"Autolayout","permalink":"Aaronzjp.cn/tags/Autolayout/"}]},{"title":"利用Storyboard或Xib实现自适应Cell","slug":"StoryboardOrXibRealizeAutoLayoutCell","date":"2015-12-26T12:47:35.000Z","updated":"2018-11-24T09:36:09.545Z","comments":true,"path":"2015/12/26/StoryboardOrXibRealizeAutoLayoutCell/","link":"","permalink":"Aaronzjp.cn/2015/12/26/StoryboardOrXibRealizeAutoLayoutCell/","excerpt":"​ 首先，UITableView这东西怎么用就不用说了吧，可以拖一个UITableview到UIController中，也可以直接拖一个UITableViewController出来。拖UITableView的时候不要忘记加代理和数据源就对了。 完成这一步后就可以在storyboard中对cell进行约束布局了，就用一个简单的demo来说。","text":"​ 首先，UITableView这东西怎么用就不用说了吧，可以拖一个UITableview到UIController中，也可以直接拖一个UITableViewController出来。拖UITableView的时候不要忘记加代理和数据源就对了。 完成这一步后就可以在storyboard中对cell进行约束布局了，就用一个简单的demo来说。 这里选择你需要自适应换行的label。到右边的属性选择中设置下，这样label就可以自动换行了。不能约束label的高，否则自动换行就无效。设置好约束后，在右边把Lines的选项设置为0（默认为1），这里的0代表不限制label的行数。 设置好以上步骤后，在代码中实现以下代码就已经成功的实现cell的高度只适应了。 1234567//这里是设置单元格的预判高度，根据自己的预估单元格的平均高度随便填写一个就行。self.tableView.estimatedRowHeight = 200;//这里是设置单元格默认的行高，就是会根据自己的计算来获得实际高度;self.tableView.rowHeight = UITableViewAutomaticDimension; 如果对cell的内容有更复杂的需求，需要做cell自适应的话，还是建议用代码来实现。","categories":[],"tags":[{"name":"自适应Cell","slug":"自适应Cell","permalink":"Aaronzjp.cn/tags/自适应Cell/"}]},{"title":"iOS9http请求","slug":"iOS9-http-Request","date":"2015-09-14T06:23:06.000Z","updated":"2018-11-24T09:33:22.304Z","comments":true,"path":"2015/09/14/iOS9-http-Request/","link":"","permalink":"Aaronzjp.cn/2015/09/14/iOS9-http-Request/","excerpt":"因为升级iOS9以后苹果要求App内访问网络时必须使用HTTPS协议，在新建的工程中都是默认使用HTTPS协议的，在不修改的情况下无法正常的访问HTTP协议的网络。以前遇到这个问题解决后就没管，现在记录一下方便查找。","text":"因为升级iOS9以后苹果要求App内访问网络时必须使用HTTPS协议，在新建的工程中都是默认使用HTTPS协议的，在不修改的情况下无法正常的访问HTTP协议的网络。以前遇到这个问题解决后就没管，现在记录一下方便查找。 解决方式找到工程的Info.plist文件在其中添加一个App Transport Security Settings的字段属性，然后在该字典属性下添加一个Allow Arbitrary Loads属性，设置为YES即可。 如下图：","categories":[],"tags":[{"name":"疑难杂症","slug":"疑难杂症","permalink":"Aaronzjp.cn/tags/疑难杂症/"}]},{"title":"git的简单使用","slug":"UseGit","date":"2015-07-05T06:04:25.000Z","updated":"2017-04-19T09:18:41.000Z","comments":true,"path":"2015/07/05/UseGit/","link":"","permalink":"Aaronzjp.cn/2015/07/05/UseGit/","excerpt":"关于安装git因为在Mac上安装Xcode后就会自动的安装git，所有Mac端的安装方式就不需要怎么说了，在Linux下具体的就不怎么说了，自行Google，因为Linux的版本太多，各个版本之间都存在微小的差异。在Windows下推荐使用git for Windows，它包括了图形工具以及命令的使用。","text":"关于安装git因为在Mac上安装Xcode后就会自动的安装git，所有Mac端的安装方式就不需要怎么说了，在Linux下具体的就不怎么说了，自行Google，因为Linux的版本太多，各个版本之间都存在微小的差异。在Windows下推荐使用git for Windows，它包括了图形工具以及命令的使用。 配置git安装完git后我们第一件事要做的就是配置git，其中配置git方式如下： git config –global user.name “用户名” git config –global user.email “邮箱” 配置好这两项后，就能通过git的配置知道谁在git仓库中做了什么。 创建一个新的git仓库创建一个git仓库后，git会把该项目的所有文件以及历史记录通过快照的方式保存在项目中，在创建仓库的时候，首先要进入到项目的根目录下，然后创建git仓库。创建完成后git会在该文件夹下创建一个隐藏的文件夹以.git结尾。 cd desktop/test git init 这样就为这个test的工程创建了一个git仓库。 查看git仓库的状态git仓库的状态是很重要的一个东西，我们通过git仓库的状态可以判断出来该项目仓库中的东西是否为最新的，以及项目是否被(commit)提交到git仓库保存。 git status 通过这个命令就可以在terminal中显示出当前git仓库的状态。 暂存git中有个叫暂存区的东西，我们在提交代码前都先要将代码保存到暂存区在进行代码的提交。如下提交代码到git暂存区的命令： 提交单个的文件到暂存区： git add 文件命 提交所有的文件到暂存区： git add -A 将文件提交到暂存区后再次使用git status查看状态就会发现文件已经提交了，其中的信息还会告诉我们哪些文件发生了改变，修改了什么东西。 提交文件被存到暂存区后我们还是需要提交代码到git git commit 当然我们也可以对提交的代码加以描述，以便清楚的表达我们修改了什么，等等，这样我们能更好的找到某个阶段的代码，回滚等等的其他操作 git commit -m “描述内容” 提交代码到远端仓库上面我们所有的操作都是在本地，文件也都是被保存在本地的，但是当我们处于多人协同开发时，我们需要将代码发布到远端的仓库以便其他的工程师pull以及push代码及时的修改代码和提交合并代码。 这里远端仓库就用github作为示例，首先在github上创建一个仓库，然后找到仓库的ssh地址或者http地址。然后在terminal中输入如下命令： git remote add origin 仓库地址 在本地仓库中添加好远端仓库的地址后就可以提交代码到远端仓库了： git push origin master 成功push到远端仓库后该项目的其他人就可以从远端仓库拉取刚刚push上去的最新的代码： git pull origin master 创建分支每个仓库在默认的时候都只有一个默认的分支master，但是在项目中有时候我们需要开一些新的分支，新开分支： git branch 分支名 查看分支状态： git branch 新开一个分支后我们需要试试看切换到新的分支，切换分支： git checkout 分支名 合并分支，在合并分支的时候，一定要把要合并的分支切换到当前分支，然后去合并被合并的分支，这里就是用master去合并一个分支： git checkout master git merge 分支名 删除分支： git branch -d 分支名 其他使用查看git提交日志： git log 要查看每次更新具体都更新了什么东西： git show 提交的id 查看两次提交的不同： git diff 提交的id..提交的id 差不多git的基本使用就是这些了，已经足够在平常的工作中使用了，最后我还是建议能用图形工具还是使用图形工具吧，因为图形工具更便捷，更清楚明了还不容易出错，有什么不好的呢。OS X上我现在正在使用的是SourceTree，具体使用什么这个看个人的喜好和习惯。","categories":[],"tags":[{"name":"git","slug":"git","permalink":"Aaronzjp.cn/tags/git/"}]},{"title":"一个App多个UITabBar的处理","slug":"Multiple-UITabBar","date":"2015-06-30T07:55:43.000Z","updated":"2018-11-24T09:35:26.664Z","comments":true,"path":"2015/06/30/Multiple-UITabBar/","link":"","permalink":"Aaronzjp.cn/2015/06/30/Multiple-UITabBar/","excerpt":"​ 平时很多常规的App都是一个App只有一个UITabBar，但是这次要做的需求是在不同的ViewController下就会显示不同的UITabBar，因为自己也是第一次做这样的需求的处理，所以一开始就在网上找类似需求的资料，结果是找了半天也没有怎么找到。于是也就只能慢慢的琢磨了，","text":"​ 平时很多常规的App都是一个App只有一个UITabBar，但是这次要做的需求是在不同的ViewController下就会显示不同的UITabBar，因为自己也是第一次做这样的需求的处理，所以一开始就在网上找类似需求的资料，结果是找了半天也没有怎么找到。于是也就只能慢慢的琢磨了， 最开始我想的是多做一个UITabBarController，在那个需要变更TabBar的Controller中就push出另外一个UITabBarController，但是。。。但是。。。但是做出来了发现并没有任何变化。 如下图这样： ​ 试了一下感觉不行，怎么办？删了？正准备删了的时候突发奇想的会不会是上一个TabBar的视图把push出来的这个视图给挡住了呢？于是我在push出第二个TabBar的时候尝试隐藏掉上一个视图的TabBar和NavigationBar： 12[self.navigationController.navigationBar setHidden:YES];[self.tabBarController.tabBar setHidden:YES]; 隐藏后真的可以了，在push出第二个TabBar的时候成功的变更了TabBar但是新的问题又出现了，这样push后原先的navigationBar已经被隐藏了，没有了返回按钮，无法返回到主页面。于是这里就只能自己添加上一个返回按钮，然后pop到根视图： 1234567self.view.backgroundColor = [UIColor whiteColor];UIBarButtonItem *backButton = [[UIBarButtonItem alloc]initWithTitle:@&quot;返回&quot;style:UIBarButtonItemStylePlain target:self action:@selector(backToRootViewController)];//注意这里的不同- (void)backToRootViewController &#123; [self.tabBarController.navigationController popToRootViewControllerAnimated:YES];&#125; 注意这里是self.tabBarController.navigationController 如果是self.navigationController的话是没有效果的，具体原因可能就是TabBar被和navigationBar被嵌套后就要获取到tabBarController的navigationBar来pop到主页的根视图。","categories":[],"tags":[{"name":"思路","slug":"思路","permalink":"Aaronzjp.cn/tags/思路/"}]},{"title":"iOS-预处理程序","slug":"iOS-Precompiling","date":"2015-06-21T04:13:45.000Z","updated":"2018-11-24T09:34:07.372Z","comments":true,"path":"2015/06/21/iOS-Precompiling/","link":"","permalink":"Aaronzjp.cn/2015/06/21/iOS-Precompiling/","excerpt":"预处理程序，即预编译。预处理程序是程序编译过程中的一部分。顾名思义大概就是在程序编译之前就处理这些预编译程序指令。在平常开发工作中可能经常看到一大堆的全大写的代码有的还用下划线来连接起来，其实这个就是预编译代码。","text":"预处理程序，即预编译。预处理程序是程序编译过程中的一部分。顾名思义大概就是在程序编译之前就处理这些预编译程序指令。在平常开发工作中可能经常看到一大堆的全大写的代码有的还用下划线来连接起来，其实这个就是预编译代码。 讲到预编译指令首先就要说 #define 宏定义。 #define#define 宏定义语句的主要用途就是替换，只要在程序中出现该宏定义的地方就会把其替换为宏定义后的常量或者表达式。 宏定义的简单使用如下： 123456789101112#define ONE 1#define IRON_MAN @&quot;iron man&quot;if (a == ONE) &#123; NSLog(@&quot;a = 1&quot;);&#125; else &#123; NSLog(@&quot;a != 1&quot;);&#125;NSString *ironman = @&quot;iron man&quot;;if ([ironman isEqualToString:IRON_MAN]) &#123; NSLog(IRON_MAN);&#125; 输出： 12a = 1iron man 可以看到这里的宏定义只是做出了简单的替换，但是接着看，宏定义还有更高级的用法，宏定义也可以是表达式，或者带参数的宏定义。 12#define TWO_FIVE 5 + 5NSLog(@&quot;%f&quot;,TWO_FIVE); 这里这个宏定义是一个简短的表达式，这里会输出10。再来看一下带有参数的宏定义是什么样的吧。如下： 12#define MAX_OF_NUMBER(a,b) a &gt;b ? a : bNSLog(@&quot;%d&quot;,MAX_OF_NUMBER(5, 10)); 这段代码会输出10，该宏定义是带有两个参数的宏定义，其作用是取这两个数的最大值。 消除宏定义可以使用 #undef 语句，如下： 如果要在宏定义中换行，则需呀在每行的结尾处添加反斜杠\\。 这里不讨论宏定义的正确性，只是简单介绍一下宏定义的使用，关于宏定义可以参考下面的资料。 宏定义的黑魔法 - 宏菜鸟起飞手册 条件编译条件编译的语句： #if 在预处理指令中的条件判断，相当于 if #ifdef 在预处理指令中判断某个宏是否已经被定义 #ifndef 与上一条相反，判断某个宏定义是否未定义 #elif 预处理指令中如果其他条件不满足则执行 #elif 内的语句，和 else if 一样 #else 预处理指令中如果其他条件都不满足则执行 #else 后的语句，和 else 一样 #endif 条件语句结束的标志语句 值得注意的就是这里的语句都是判断后面的条件是否满足，只有 #ifdef 是判断某个宏是否被定义。在使用上这两个是相同的： 1234567#ifdef IPHONE NSLog(IPHONE);#endif// ********************* #if defined (IPHONE) NSLog(IPHONE);#endif 其中 defined () 也是判断某个宏是否已经被定义，条件编译语句和普通的条件判断语句一样也是可以嵌套的。这里贴出一部分 Foudation 框架中的代码参考，可以看一下别人的使用。 另外在很多时候创建头文件中都会有如下的代码： 1234#ifndef Header_h #define Header_h #endif 上面的这些预编于指令代码其实就是为了防止头文件重复导入。 文件导入文件导入其实也是属于预处理程序的一种，但是文件导入像什么 #import #include @class经常都在使用已经很熟悉其中的用法和含义了这里就不记录了。","categories":[],"tags":[{"name":"宏","slug":"宏","permalink":"Aaronzjp.cn/tags/宏/"}]},{"title":"如何搭建自己的个人博客","slug":"CreateBlog","date":"2015-03-04T17:04:20.000Z","updated":"2017-04-19T09:09:07.000Z","comments":true,"path":"2015/03/05/CreateBlog/","link":"","permalink":"Aaronzjp.cn/2015/03/05/CreateBlog/","excerpt":"自己也搭建了个人博客，在搭建的过程中也又遇到了很多问题，所以在这里我自己来总结一下，搭建一个博客的过程。方便以后博客出问题的时候来这里查找。","text":"自己也搭建了个人博客，在搭建的过程中也又遇到了很多问题，所以在这里我自己来总结一下，搭建一个博客的过程。方便以后博客出问题的时候来这里查找。 首先环境搭建 安装Node.js。官网下载，下载后打开按照提示一步一步的安装即可。 git这个不用多说，因为我使用的是Mac电脑，所以自带git。 npm的安装，npm使用命令安装 npm install -g hexo-cli,也可以到官网下载下来进行安装官网链接 上面几步做好后我们的准备工作就做的差不多了，查看上面的工具是否安装成功可以通过查看版本的方式来查看。如：node -v 建立本地站点 hexo init &lt;文件夹名称&gt; cd &lt;文件夹名称&gt; npm install 克隆主题&emsp;&emsp;不知道在哪找主题吧，可以进入到官网链接去查看，点击主题里面有一部分的主题，也可以去这里 有哪些好看的hexo主题？ 发布到github 注册github这些我就不说了吧，进入到githu登陆账号后，点击New repository创建一个新的项目，注意这里的这个项目命名是有规定的，必须是如下的这种格式命名： 你的github名称.github.io ​ 因为github规定只能是这样命名的才能以page的样式展现，其他的全部默认就好，创建完成后，我们可以像平时使用github一样的，把博客的文件push到这个项目即可。（注意push博客的时候是push&lt;文件夹名称&gt;–&gt;public这个文件夹下所有的文件）。 为了更方便的管理博客和平时文件的更新，我们来配置一个deploy。打开站点配置文件_config.yml，找到deploy字段，修改成如下的样式即可。 1234567&gt; # Deployment&gt; ## Docs: http://hexo.io/docs/deployment.html&gt; deploy:&gt; type: git&gt; repository: git@github.com:用户名/用户名.github.io.git&gt; branch: master&gt; 这样配置好以后，有新的博客添加，或者修改后，只需要执行如下的操作就可以将博客发布到github： hexo g //生成静态网页 hexo s //部署在本地，此步操作完后就可以在本地查看网页预览 hexo deploy //没有问题后就可以部署到github上了 这三步操作完成后就其他人也可以通过github来访问你的个人博客了。 ⚠️注意：使用hexo d来部署博客到github首先要安装一个插件hexo-deployer-git，安装方式，cd 到你当前的博客根目录文件夹下执行以下命令： npm install hexo-deployer-git –save 发布新的文章hexo new &quot;文章标题名称&quot; 执行以上命令后，相应文件夹中生成.md文件，找到编辑并保存后。执行以上发布到github这部分，就可以把文章发布出去了。 hexo clean清理，这个操作会将public文件夹删除，这个慎用，在遇到问题的时候可以通过这个来清除后再通过hexo g重新生成，并同步到github。","categories":[{"name":"其他","slug":"其他","permalink":"Aaronzjp.cn/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"Aaronzjp.cn/tags/其他/"}]}]}