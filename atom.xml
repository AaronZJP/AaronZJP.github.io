<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Aaron的博客</title>
  <subtitle>技术博客，记录和学习</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="Aaronzjp.cn/"/>
  <updated>2018-05-18T16:10:20.895Z</updated>
  <id>Aaronzjp.cn/</id>
  
  <author>
    <name>Aaron_36</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iPad 设计指南（Code + Design 翻译）</title>
    <link href="Aaronzjp.cn/2018/05/19/Designing-for-iPad/"/>
    <id>Aaronzjp.cn/2018/05/19/Designing-for-iPad/</id>
    <published>2018-05-18T16:10:12.000Z</published>
    <updated>2018-05-18T16:10:20.895Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;针对 iPad 的设计并不是像翻转一个开关的那样简单，或者仅仅是将所有的东西变大。更大的屏幕提供了一个真正的机会来呈现更多的内容，同时也要遵守导航，排版，视觉层次的一些基本规则。不要仅仅是当作一个大的 iPhone 来对待 iPad。应该更多的像对待一个可以触摸的桌面电脑一样。换句话说，你的用户可以更加高效，查看更多的内容，更快的执行任务，比如，输入，拖放，以及多任务。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Design+Code" scheme="Aaronzjp.cn/tags/Design-Code/"/>
    
      <category term="iOS编程和设计" scheme="Aaronzjp.cn/tags/iOS%E7%BC%96%E7%A8%8B%E5%92%8C%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>iPhone X 设计指南（Code + Design 翻译）</title>
    <link href="Aaronzjp.cn/2018/05/18/Designing-for-iPhoneX/"/>
    <id>Aaronzjp.cn/2018/05/18/Designing-for-iPhoneX/</id>
    <published>2018-05-18T10:24:12.000Z</published>
    <updated>2018-05-18T10:24:42.672Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;iOS 11 标志着 iPhone X 的推出，这款高得多的 iPhone 几乎没有边框。5.8 英寸的 OLED 屏幕比 iPhone 8 Plus 的 5.5英寸的屏幕还要大，同时机身尺寸几乎和 iPhone 8 一样大。对于设计师来说，这意味着我们有更多的画布。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Design+Code" scheme="Aaronzjp.cn/tags/Design-Code/"/>
    
      <category term="iOS编程和设计" scheme="Aaronzjp.cn/tags/iOS%E7%BC%96%E7%A8%8B%E5%92%8C%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>iOS 发现与自定义图标（Code + Design 翻译）</title>
    <link href="Aaronzjp.cn/2018/05/15/iOS-Icons/"/>
    <id>Aaronzjp.cn/2018/05/15/iOS-Icons/</id>
    <published>2018-05-15T15:39:12.000Z</published>
    <updated>2018-05-18T10:33:46.053Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;好的图标总是给人很熟悉的感觉，因为他们与我们每天看到的事物都是有联系的：相机，垃圾桶，云朵☁️。它们没有文字，但是设置了很友好的色调。在这一节中，你将要学到怎么找到好的图标，什么时候使用，什么时候不使用，以及如何自己制作，这样就可以使图标在你的应用程序中设计得更加漂亮。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Design+Code" scheme="Aaronzjp.cn/tags/Design-Code/"/>
    
      <category term="iOS编程和设计" scheme="Aaronzjp.cn/tags/iOS%E7%BC%96%E7%A8%8B%E5%92%8C%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>iOS11设计概览（Code + Design 翻译）</title>
    <link href="Aaronzjp.cn/2018/04/22/iOS11-design-guide/"/>
    <id>Aaronzjp.cn/2018/04/22/iOS11-design-guide/</id>
    <published>2018-04-22T14:23:12.000Z</published>
    <updated>2018-05-02T09:08:40.370Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在过去的五年时间扁平化设计已经变得很普遍了，但是在 iOS7 之前却并不普遍。正是因为这样设计风格开始转变，但是说这样的设计没有太多的变化是不准确的。iOS 的设计已经适应了更大的屏幕，与之前超写实拟物设计风格恰恰相反。现在扁平化的设计更加的微妙，在去掉了渐变、阴影、卡片等设计后。&lt;/p&gt;
&lt;h1 id=&quot;iOS的演变&quot;&gt;&lt;a href=&quot;#iOS的演变&quot; class=&quot;headerlink&quot; title=&quot;iOS的演变&quot;&gt;&lt;/a&gt;iOS的演变&lt;/h1&gt;&lt;p&gt;让我们从头开始，看看下面的一组图片。在最左边是超写实设计，也就是我们所熟知的拟物化设计。这样的拟物化的设计在2007年是很有效的，因为那个时候很少人熟悉放在你口袋里的超级计算机。&lt;/p&gt;
&lt;p&gt;在中间的这个图中，我们去掉了所有的装饰，使用带有色彩，漂亮字体以及简介清楚的内容的扁平化设计。由于人们对现代技术越来越熟悉适应，以及对智能手机的熟悉，所以在设计上去掉了原本厚重的装饰。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Design+Code" scheme="Aaronzjp.cn/tags/Design-Code/"/>
    
      <category term="iOS编程和设计" scheme="Aaronzjp.cn/tags/iOS%E7%BC%96%E7%A8%8B%E5%92%8C%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-BOMAndDOM</title>
    <link href="Aaronzjp.cn/2018/04/19/JavaScript-BOMAndDOM/"/>
    <id>Aaronzjp.cn/2018/04/19/JavaScript-BOMAndDOM/</id>
    <published>2018-04-19T06:37:13.000Z</published>
    <updated>2018-04-19T09:20:31.981Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;BOM-浏览器对象模型&quot;&gt;&lt;a href=&quot;#BOM-浏览器对象模型&quot; class=&quot;headerlink&quot; title=&quot;BOM(浏览器对象模型)&quot;&gt;&lt;/a&gt;BOM(浏览器对象模型)&lt;/h1&gt;&lt;p&gt;JavaScript 可以获取浏览器提供的很多对象。浏览器对象模型（Browser Object Model）尚无正式标准。由于浏览器已经实现了 JavaScript 交互性方面的相同方法和属性，因此常被认为是 BOM 的方法和属性。&lt;/p&gt;
&lt;h2 id=&quot;window-对象&quot;&gt;&lt;a href=&quot;#window-对象&quot; class=&quot;headerlink&quot; title=&quot;window 对象&quot;&gt;&lt;/a&gt;window 对象&lt;/h2&gt;&lt;p&gt;所有的浏览器都支持 &lt;code&gt;window&lt;/code&gt; 对象，表示浏览器窗口。&lt;code&gt;window&lt;/code&gt; 是一个全局对象，不但这样所有 JavaScript 全局对象、函数以及变量都会成为 &lt;code&gt;window&lt;/code&gt; 对象的成员。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript-面向对象编程</title>
    <link href="Aaronzjp.cn/2018/04/11/JavaScript-OOP/"/>
    <id>Aaronzjp.cn/2018/04/11/JavaScript-OOP/</id>
    <published>2018-04-11T05:56:16.000Z</published>
    <updated>2018-04-20T09:24:07.699Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JavaScript-标准对象&quot;&gt;&lt;a href=&quot;#JavaScript-标准对象&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 标准对象&quot;&gt;&lt;/a&gt;JavaScript 标准对象&lt;/h1&gt;&lt;h2 id=&quot;对象的类型&quot;&gt;&lt;a href=&quot;#对象的类型&quot; class=&quot;headerlink&quot; title=&quot;对象的类型&quot;&gt;&lt;/a&gt;对象的类型&lt;/h2&gt;&lt;p&gt;在 JavaScript 中一切都是对象，但是 JavaScript 中的对象是有类型的，在 JavaScript 中使用 &lt;code&gt;typeof&lt;/code&gt; 来获取对象的类型，返回的是类型的字符串&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// &#39;number&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NaN&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// &#39;number&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;str&#39;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// &#39;string&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// &#39;boolean&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// &#39;undefined&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Math&lt;/span&gt;.abs; &lt;span class=&quot;comment&quot;&gt;// &#39;function&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// &#39;object&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; []; &lt;span class=&quot;comment&quot;&gt;// &#39;object&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &amp;#123;&amp;#125;; &lt;span class=&quot;comment&quot;&gt;// &#39;object&#39;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;感觉没啥卵用，根本区分不出来对象的类型。。。。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JS学习" scheme="Aaronzjp.cn/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="JS基础" scheme="Aaronzjp.cn/tags/JS%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-函数</title>
    <link href="Aaronzjp.cn/2018/03/12/JavaScript-Function/"/>
    <id>Aaronzjp.cn/2018/03/12/JavaScript-Function/</id>
    <published>2018-03-12T06:16:24.000Z</published>
    <updated>2018-04-11T05:57:21.780Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JavaScript-函数&quot;&gt;&lt;a href=&quot;#JavaScript-函数&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 函数&quot;&gt;&lt;/a&gt;JavaScript 函数&lt;/h1&gt;&lt;h2 id=&quot;定义函数&quot;&gt;&lt;a href=&quot;#定义函数&quot; class=&quot;headerlink&quot; title=&quot;定义函数&quot;&gt;&lt;/a&gt;定义函数&lt;/h2&gt;&lt;p&gt;在 JavaScript 中定义函数的方式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sum&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;number1,number2&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; number1 === &lt;span class=&quot;string&quot;&gt;&#39;number&#39;&lt;/span&gt; &amp;amp;&amp;amp; &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; number2 === &lt;span class=&quot;string&quot;&gt;&#39;number&#39;&lt;/span&gt;)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; number1 + number2;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;Not a number&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;sum(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;JavaScript 如果函数没有 &lt;code&gt;return&lt;/code&gt; 语句，但是也是会有返回值的。其返回的结果是 &lt;code&gt;undefined&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JS学习" scheme="Aaronzjp.cn/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="JS基础" scheme="Aaronzjp.cn/tags/JS%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 基础</title>
    <link href="Aaronzjp.cn/2018/03/12/JavaScript-Basic/"/>
    <id>Aaronzjp.cn/2018/03/12/JavaScript-Basic/</id>
    <published>2018-03-12T06:02:10.000Z</published>
    <updated>2018-04-11T05:57:01.248Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-Script基础&quot;&gt;&lt;a href=&quot;#Java-Script基础&quot; class=&quot;headerlink&quot; title=&quot;Java Script基础&quot;&gt;&lt;/a&gt;Java Script基础&lt;/h1&gt;&lt;p&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 元素&lt;/p&gt;
&lt;p&gt;向 HTML 页面中插入 JavaScirpt 的主要方法就是使用 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 元素。在使用&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 元素嵌入 JavaScript 代码时，只须为&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 指定 type 属性。然后，像下面这样把 JavaScript 代码直接放在元素内部即可：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;script type=&lt;span class=&quot;string&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sayHi&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        alert(&lt;span class=&quot;string&quot;&gt;&quot;Hi!&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;&lt;span class=&quot;regexp&quot;&gt;/script&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其实不写 type 类型也是可以的，因为现在大部分浏览器默认就是 text/javascript 类型。&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 元素来包含外部 Javascript 文件，需要用到 src 属性，该属性的值时指向一个外部 JavaScript 文件等链接，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;script type=&lt;span class=&quot;string&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt; src=&lt;span class=&quot;string&quot;&gt;&quot;example.js&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="JS学习" scheme="Aaronzjp.cn/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="JS基础" scheme="Aaronzjp.cn/tags/JS%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>《HTTP权威指南》读书笔记之 - Cookie</title>
    <link href="Aaronzjp.cn/2017/12/12/HTTP-Cookie/"/>
    <id>Aaronzjp.cn/2017/12/12/HTTP-Cookie/</id>
    <published>2017-12-12T08:44:28.000Z</published>
    <updated>2017-12-12T08:46:32.003Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="HTTP" scheme="Aaronzjp.cn/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>《HTTP权威指南》读书笔记之 - HTTP报文</title>
    <link href="Aaronzjp.cn/2017/12/06/HTTP-Protocol/"/>
    <id>Aaronzjp.cn/2017/12/06/HTTP-Protocol/</id>
    <published>2017-12-05T23:40:35.000Z</published>
    <updated>2018-04-27T09:44:01.630Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;​    HTTP 协议最初设计目的是用来接收和发布 HTML 网页的，因为其数据传输的可靠性后来被广泛的使用，HTTP 是一种可靠的数据传输协议，该协议位于 TCP/IP 协议族中的应用层。目前 HTTP 已经不只是用来传输简单的网页了。我们在网络上浏览的所有的资源都是存储在 Web 服务器中的，这些资源通过 HTTP 协议被传输到我们的设备中让我们使用。这些使用 HTTP 协议传输数据的服务器就被称为 HTTP 服务器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="HTTP" scheme="Aaronzjp.cn/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>《HTTP权威指南》读书笔记之 - URL与资源</title>
    <link href="Aaronzjp.cn/2017/12/02/HTTP-URL-and-Resource/"/>
    <id>Aaronzjp.cn/2017/12/02/HTTP-URL-and-Resource/</id>
    <published>2017-12-02T13:31:46.000Z</published>
    <updated>2018-02-08T03:05:37.583Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;​    如今我们随时随地都在通过各种设备上网，我们通过网络听歌，查看图片，浏览网页。那我们所访问的这些东西，音乐，图片，网页是从哪来的呢？放在什么地方呢？我们通过什么样的方式使用手中的设备去访问的这些资源呢？&lt;/p&gt;
&lt;p&gt;​    其实我们所访问的这些资源都是存储在世界各地的 Web 服务器的，我们通过 URL 在网络上定位和访问这些资源。我们最常见的 URL 就是我们在上网时打开浏览器后在地址栏输入的网址，这个就是 URL。URL 是 URI 的子集。&lt;/p&gt;
    
    </summary>
    
    
      <category term="HTTP" scheme="Aaronzjp.cn/tags/HTTP/"/>
    
      <category term="URL" scheme="Aaronzjp.cn/tags/URL/"/>
    
  </entry>
  
  <entry>
    <title>What&#39;s new in iOS11</title>
    <link href="Aaronzjp.cn/2017/10/12/Whats-new-in-iOS11/"/>
    <id>Aaronzjp.cn/2017/10/12/Whats-new-in-iOS11/</id>
    <published>2017-10-12T03:06:03.000Z</published>
    <updated>2018-02-08T02:43:27.814Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;iOS 11正式发布后也一直没有去整理这些东西，现在才整理一点点出来。下面就是在iOS11中新加入的一些东西，可能不是很全面，但是后续会有补充吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WWDC2017" scheme="Aaronzjp.cn/tags/WWDC2017/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa框架概览</title>
    <link href="Aaronzjp.cn/2017/09/06/ReactiveCocoa-Framework-Overview/"/>
    <id>Aaronzjp.cn/2017/09/06/ReactiveCocoa-Framework-Overview/</id>
    <published>2017-09-06T13:25:22.000Z</published>
    <updated>2018-05-06T12:09:26.705Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;框架概览&quot;&gt;&lt;a href=&quot;#框架概览&quot; class=&quot;headerlink&quot; title=&quot;框架概览&quot;&gt;&lt;/a&gt;框架概览&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文档翻译自 ReactiveCocoa ( ReactiveObjC ) 中的 &lt;a href=&quot;https://github.com/ReactiveCocoa/ReactiveObjC/blob/master/Documentation/FrameworkOverview.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Framework Overview&lt;/a&gt; 文档，主要是用来帮助了解 ReactiveCocoa 这个框架的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该文档主要包含了 ReactiveCocoa 框架中底层不同组件的相关介绍，并介绍了他们是如何一起工作，和划分工作的。这是学习这个新模块和找到更多相关知识文档的起点。&lt;/p&gt;
&lt;p&gt;例如帮助我们理解怎么使用 RAC，可以查看这个&lt;a href=&quot;https://github.com/ReactiveCocoa/ReactiveObjC/blob/master/Documentation/README.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;使用文档&lt;/a&gt; 以及&lt;a href=&quot;https://github.com/ReactiveCocoa/ReactiveObjC/blob/master/Documentation/DesignGuidelines.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;设计概览&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&quot;Stream-流&quot;&gt;&lt;a href=&quot;#Stream-流&quot; class=&quot;headerlink&quot; title=&quot;Stream (流)&quot;&gt;&lt;/a&gt;Stream (流)&lt;/h1&gt;&lt;p&gt;流，在框架中使用 &lt;strong&gt;RACStream&lt;/strong&gt; 这个抽象类表示，是一系列的对象值。&lt;/p&gt;
&lt;p&gt;这些值是可以立刻获取到的，或者在将来可以获取使用的，但是必须要按顺序检索。在流中不使用或者等待第一个值的情况下是没有办法跳过直接获取检索第二个值的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Reactive Cocoa" scheme="Aaronzjp.cn/tags/Reactive-Cocoa/"/>
    
      <category term="响应式编程" scheme="Aaronzjp.cn/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa 和 MVVM 的简单使用</title>
    <link href="Aaronzjp.cn/2017/08/28/ReactiveCocoa-and-MVVM/"/>
    <id>Aaronzjp.cn/2017/08/28/ReactiveCocoa-and-MVVM/</id>
    <published>2017-08-28T05:14:55.000Z</published>
    <updated>2017-11-16T07:08:39.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MVVM&quot;&gt;&lt;a href=&quot;#MVVM&quot; class=&quot;headerlink&quot; title=&quot;MVVM&quot;&gt;&lt;/a&gt;MVVM&lt;/h1&gt;&lt;p&gt;在 iOS 中最开始的时候以及我们一开始学习的时候就是使用的 MVC 的模式来进行iOS App 开发的。MVC 的模式总的来说就是分为三个部分 Model(数据模型)、View(界面，视图)、Controller(控制器)。&lt;/p&gt;
&lt;p&gt;在 MVC 中他们的通信方式如下图所示，该图来自斯坦福公开课中的 PDF 文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Reactive Cocoa" scheme="Aaronzjp.cn/tags/Reactive-Cocoa/"/>
    
      <category term="MVVM" scheme="Aaronzjp.cn/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa的基本使用</title>
    <link href="Aaronzjp.cn/2017/08/03/Use-ReactiveCocoa/"/>
    <id>Aaronzjp.cn/2017/08/03/Use-ReactiveCocoa/</id>
    <published>2017-08-03T01:59:47.000Z</published>
    <updated>2018-04-27T09:26:24.317Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是ReactiveCocoa？&quot;&gt;&lt;a href=&quot;#什么是ReactiveCocoa？&quot; class=&quot;headerlink&quot; title=&quot;什么是ReactiveCocoa？&quot;&gt;&lt;/a&gt;什么是ReactiveCocoa？&lt;/h1&gt;&lt;p&gt;最近因为公司的一个项目因为是用 ReactiveCocoa 结合 MVVM 来写的，所以在我接手的时候我也打算继续使用这种模式，因为我觉得这种模式还是有一定的好处的，通过 ReactiveCocoa 的使用强化了项目中围绕数据变化所做的改变。所以最近还是学习一下 ReactiveCocoa 的一些基本的使用。&lt;/p&gt;
&lt;p&gt;ReactiveCocoa（其简称为RAC）是由Github工程师们开发的一个应用于iOS和OS X开发的函数响应式编程新框架。ReactiveCocoa 的灵感来源于 函数式响应式编程。ReactiveCocoa 的优点是可以很轻松的处理状态以及状态之间依赖过多的问题，同时也是一种很好的消息传递的机制。通过对 RACSignal (信号) 的使用，可以很好的处理事件流，以及事件的监控，状态改变的处理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Reactive Cocoa" scheme="Aaronzjp.cn/tags/Reactive-Cocoa/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa 基础教程 2-2（译）</title>
    <link href="Aaronzjp.cn/2017/06/20/ReactiveCocoa-Tutorial-2-2/"/>
    <id>Aaronzjp.cn/2017/06/20/ReactiveCocoa-Tutorial-2-2/</id>
    <published>2017-06-20T14:32:12.000Z</published>
    <updated>2018-05-02T09:23:04.069Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文是翻译自国外网站的文章，其实这篇文章有很多的现成的翻译，但是看了过后感觉我自己很难理解别人的翻译方式，所以用自己的方式翻译了一遍，顺便也是加深一下印象。&lt;a href=&quot;https://www.raywenderlich.com/62796/reactivecocoa-tutorial-pt2&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ReactiveCocoa 这个框架允许将响应式编程技术应用到你的 iOS App 项目中。在上一个章节教程中介绍了如何使用事件流以及信号去替换标准的事件操作，以及事件处理逻辑。同时也介绍了如何改变信号中传递的数据，以及分割信号，合并信号。&lt;/p&gt;
&lt;p&gt;在这一部分将要介绍 ReactiveCocoa 中更多高级的用法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;另外的两个事件类型 &lt;strong&gt;error&lt;/strong&gt; 和 &lt;strong&gt;complete&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;节流(Throttling)&lt;/li&gt;
&lt;li&gt;线程&lt;/li&gt;
&lt;li&gt;持续性(Continuations)&lt;/li&gt;
&lt;li&gt;更多&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;是时候开始了！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Reactive Cocoa" scheme="Aaronzjp.cn/tags/Reactive-Cocoa/"/>
    
      <category term="响应式编程" scheme="Aaronzjp.cn/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa 基础教程 2-1（译）</title>
    <link href="Aaronzjp.cn/2017/05/22/ReactiveCocoa-Tutorial-2-1/"/>
    <id>Aaronzjp.cn/2017/05/22/ReactiveCocoa-Tutorial-2-1/</id>
    <published>2017-05-22T12:31:22.000Z</published>
    <updated>2018-05-03T05:20:25.711Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文是翻译自国外网站的文章，其实这篇文章有很多的现成的翻译，但是看了过后感觉我自己很难理解别人的翻译方式，所以用自己的方式翻译了一遍，顺便也是加深一下印象。&lt;a href=&quot;https://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作为一个iOS开发，几乎编写的每一行代码都是在处理事件的响应。比如按钮的点击，接收的网络消息，属性的改变(Key Value Observing)，或者用户改变了当前的位置，都是很好的例子。然而这些事件以不同的编码方式散布在各个地方，比如动作触发，代理(delegates)，KVO，回调或者其他的。ReactiveCocoa 则定义了一套完整的处理这些事件的标准接口，因此可以使用它很容易的处理事件链接，过滤，组合等。&lt;/p&gt;
&lt;p&gt;听起来很困惑？很有趣？….吹牛逼？继续看下去。&lt;/p&gt;
&lt;p&gt;ReactiveCocoa 结合了以下几种编程风格：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数式编程，利用高阶函数，即其他函数作为函数的参数或返回值。&lt;/li&gt;
&lt;li&gt;响应式编程，着重于数据流以及数据变化和传值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过这些原因，你应该知道 ReactiveCocoa 被称作为&lt;strong&gt;响应式函数编程&lt;/strong&gt;框架。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Reactive Cocoa" scheme="Aaronzjp.cn/tags/Reactive-Cocoa/"/>
    
      <category term="响应式编程" scheme="Aaronzjp.cn/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Swift-枚举</title>
    <link href="Aaronzjp.cn/2017/04/20/Swift-Enum/"/>
    <id>Aaronzjp.cn/2017/04/20/Swift-Enum/</id>
    <published>2017-04-20T07:01:27.000Z</published>
    <updated>2017-08-01T07:06:31.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在 Swift 中枚举是一等类型。 Swift 中枚举是一个很强大的类型，在 C 语言中枚举会为一组整型值分配相关联的名称。但是在 Swift 中不是必须的，如果给枚举成员赋值(在 Swift 中又叫原始值)，则该值的类型可以是字符、字符串、整型、或者是一个浮点数。除了这些以为 Swift 中的枚举还可以指定任意类型的关联值到枚举成员中，还可以添加计算属性，实例方法，还可以定义构造函数，还可以遵守协议。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="Aaronzjp.cn/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>自定义转场动画（ViewController Transition）</title>
    <link href="Aaronzjp.cn/2017/04/19/TransitionAnimation/"/>
    <id>Aaronzjp.cn/2017/04/19/TransitionAnimation/</id>
    <published>2017-04-19T09:28:41.000Z</published>
    <updated>2017-07-27T02:52:28.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;什么是转场动画，转场动画就是从一个 Controller 跳转到另一个 Controller 时呈现的动画。在现在的iOS App 中很多 App 都实现了自己的转场动画，要知道自定义转场动画在 iOS7 以前是没有这么轻松的，在 iOS7 以前要想自定义转场动画那就只能自己去一步一步的实现，很久以前我隐约记得我看过一篇文章是关于自定义控制器容易器转场动画的，大概意思就是自定&lt;/p&gt;
    
    </summary>
    
    
      <category term="转场动画" scheme="Aaronzjp.cn/tags/%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>Swift-构造过程</title>
    <link href="Aaronzjp.cn/2017/03/27/Swift-Initializer/"/>
    <id>Aaronzjp.cn/2017/03/27/Swift-Initializer/</id>
    <published>2017-03-27T14:06:28.000Z</published>
    <updated>2017-07-31T19:35:42.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Swift 构造过程是在使用类、结构体或者枚举类型的实例之前所做的准备工作。在使用类型实例之前为了确保类型实例能够正确的实例化，需要在实例化过程中对存储属性等设置初始值，和一些必须执行和初始化的工作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="Aaronzjp.cn/tags/Swift/"/>
    
  </entry>
  
</feed>
